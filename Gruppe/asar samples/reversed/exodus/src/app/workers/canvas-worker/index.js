!(function (t) {
  var e = {};
  function i(r) {
    if (e[r]) return e[r].exports;
    var s = (e[r] = { i: r, l: !1, exports: {} });
    return t[r].call(s.exports, s, s.exports, i), (s.l = !0), s.exports;
  }
  (i.m = t),
    (i.c = e),
    (i.d = function (t, e, r) {
      i.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r });
    }),
    (i.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (i.t = function (t, e) {
      if ((1 & e && (t = i(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var r = Object.create(null);
      if (
        (i.r(r),
        Object.defineProperty(r, "default", { enumerable: !0, value: t }),
        2 & e && "string" != typeof t)
      )
        for (var s in t)
          i.d(
            r,
            s,
            function (e) {
              return t[e];
            }.bind(null, s),
          );
      return r;
    }),
    (i.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return i.d(e, "a", e), e;
    }),
    (i.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (i.p = ""),
    i((i.s = 6));
})([
  function (t, e, i) {
    const { toObject: r } = i(2);
    t.exports = {
      installHandler: function (t) {
        self.onmessage = async (e) => {
          try {
            const { method: i, args: s } = e.data,
              n = await t(i, s);
            postMessage({ result: n, id: e.data.id });
          } catch (t) {
            postMessage({ error: r(t), id: e.data.id });
          }
        };
      },
    };
  },
  function (t, e, i) {
    "use strict";
    i.r(e);
    var r = i(0);
    const s = [];
    for (let t = 0; t < 256; t++) s[t] = (t < 16 ? "0" : "") + t.toString(16);
    let n = 1234567;
    const a = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: function () {
        const t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0,
          r = (4294967295 * Math.random()) | 0;
        return (
          s[255 & t] +
          s[(t >> 8) & 255] +
          s[(t >> 16) & 255] +
          s[(t >> 24) & 255] +
          "-" +
          s[255 & e] +
          s[(e >> 8) & 255] +
          "-" +
          s[((e >> 16) & 15) | 64] +
          s[(e >> 24) & 255] +
          "-" +
          s[(63 & i) | 128] +
          s[(i >> 8) & 255] +
          "-" +
          s[(i >> 16) & 255] +
          s[(i >> 24) & 255] +
          s[255 & r] +
          s[(r >> 8) & 255] +
          s[(r >> 16) & 255] +
          s[(r >> 24) & 255]
        ).toUpperCase();
      },
      clamp: function (t, e, i) {
        return Math.max(e, Math.min(i, t));
      },
      euclideanModulo: function (t, e) {
        return ((t % e) + e) % e;
      },
      mapLinear: function (t, e, i, r, s) {
        return r + ((t - e) * (s - r)) / (i - e);
      },
      lerp: function (t, e, i) {
        return (1 - i) * t + i * e;
      },
      smoothstep: function (t, e, i) {
        return t <= e
          ? 0
          : t >= i
          ? 1
          : (t = (t - e) / (i - e)) * t * (3 - 2 * t);
      },
      smootherstep: function (t, e, i) {
        return t <= e
          ? 0
          : t >= i
          ? 1
          : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10);
      },
      randInt: function (t, e) {
        return t + Math.floor(Math.random() * (e - t + 1));
      },
      randFloat: function (t, e) {
        return t + Math.random() * (e - t);
      },
      randFloatSpread: function (t) {
        return t * (0.5 - Math.random());
      },
      seededRandom: function (t) {
        return (
          void 0 !== t && (n = t % 2147483647),
          ((n = (16807 * n) % 2147483647) - 1) / 2147483646
        );
      },
      degToRad: function (t) {
        return t * a.DEG2RAD;
      },
      radToDeg: function (t) {
        return t * a.RAD2DEG;
      },
      isPowerOfTwo: function (t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      },
      ceilPowerOfTwo: function (t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      },
      floorPowerOfTwo: function (t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      },
      setQuaternionFromProperEuler: function (t, e, i, r, s) {
        const n = Math.cos,
          a = Math.sin,
          o = n(i / 2),
          h = a(i / 2),
          l = n((e + r) / 2),
          u = a((e + r) / 2),
          c = n((e - r) / 2),
          p = a((e - r) / 2),
          d = n((r - e) / 2),
          m = a((r - e) / 2);
        switch (s) {
          case "XYX":
            t.set(o * u, h * c, h * p, o * l);
            break;
          case "YZY":
            t.set(h * p, o * u, h * c, o * l);
            break;
          case "ZXZ":
            t.set(h * c, h * p, o * u, o * l);
            break;
          case "XZX":
            t.set(o * u, h * m, h * d, o * l);
            break;
          case "YXY":
            t.set(h * d, o * u, h * m, o * l);
            break;
          case "ZYZ":
            t.set(h * m, h * d, o * u, o * l);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                s,
            );
        }
      },
    };
    class o {
      constructor(t = 0, e = 0, i = 0, r = 1) {
        Object.defineProperty(this, "isQuaternion", { value: !0 }),
          (this._x = t),
          (this._y = e),
          (this._z = i),
          (this._w = r);
      }
      static slerp(t, e, i, r) {
        return i.copy(t).slerp(e, r);
      }
      static slerpFlat(t, e, i, r, s, n, a) {
        let o = i[r + 0],
          h = i[r + 1],
          l = i[r + 2],
          u = i[r + 3];
        const c = s[n + 0],
          p = s[n + 1],
          d = s[n + 2],
          m = s[n + 3];
        if (u !== m || o !== c || h !== p || l !== d) {
          let t = 1 - a;
          const e = o * c + h * p + l * d + u * m,
            i = e >= 0 ? 1 : -1,
            r = 1 - e * e;
          if (r > Number.EPSILON) {
            const s = Math.sqrt(r),
              n = Math.atan2(s, e * i);
            (t = Math.sin(t * n) / s), (a = Math.sin(a * n) / s);
          }
          const s = a * i;
          if (
            ((o = o * t + c * s),
            (h = h * t + p * s),
            (l = l * t + d * s),
            (u = u * t + m * s),
            t === 1 - a)
          ) {
            const t = 1 / Math.sqrt(o * o + h * h + l * l + u * u);
            (o *= t), (h *= t), (l *= t), (u *= t);
          }
        }
        (t[e] = o), (t[e + 1] = h), (t[e + 2] = l), (t[e + 3] = u);
      }
      static multiplyQuaternionsFlat(t, e, i, r, s, n) {
        const a = i[r],
          o = i[r + 1],
          h = i[r + 2],
          l = i[r + 3],
          u = s[n],
          c = s[n + 1],
          p = s[n + 2],
          d = s[n + 3];
        return (
          (t[e] = a * d + l * u + o * p - h * c),
          (t[e + 1] = o * d + l * c + h * u - a * p),
          (t[e + 2] = h * d + l * p + a * c - o * u),
          (t[e + 3] = l * d - a * u - o * c - h * p),
          t
        );
      }
      get x() {
        return this._x;
      }
      set x(t) {
        (this._x = t), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(t) {
        (this._y = t), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(t) {
        (this._z = t), this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(t) {
        (this._w = t), this._onChangeCallback();
      }
      set(t, e, i, r) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = i),
          (this._w = r),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(t) {
        return (
          (this._x = t.x),
          (this._y = t.y),
          (this._z = t.z),
          (this._w = t.w),
          this._onChangeCallback(),
          this
        );
      }
      setFromEuler(t, e) {
        if (!t || !t.isEuler)
          throw new Error(
            "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.",
          );
        const i = t._x,
          r = t._y,
          s = t._z,
          n = t._order,
          a = Math.cos,
          o = Math.sin,
          h = a(i / 2),
          l = a(r / 2),
          u = a(s / 2),
          c = o(i / 2),
          p = o(r / 2),
          d = o(s / 2);
        switch (n) {
          case "XYZ":
            (this._x = c * l * u + h * p * d),
              (this._y = h * p * u - c * l * d),
              (this._z = h * l * d + c * p * u),
              (this._w = h * l * u - c * p * d);
            break;
          case "YXZ":
            (this._x = c * l * u + h * p * d),
              (this._y = h * p * u - c * l * d),
              (this._z = h * l * d - c * p * u),
              (this._w = h * l * u + c * p * d);
            break;
          case "ZXY":
            (this._x = c * l * u - h * p * d),
              (this._y = h * p * u + c * l * d),
              (this._z = h * l * d + c * p * u),
              (this._w = h * l * u - c * p * d);
            break;
          case "ZYX":
            (this._x = c * l * u - h * p * d),
              (this._y = h * p * u + c * l * d),
              (this._z = h * l * d - c * p * u),
              (this._w = h * l * u + c * p * d);
            break;
          case "YZX":
            (this._x = c * l * u + h * p * d),
              (this._y = h * p * u + c * l * d),
              (this._z = h * l * d - c * p * u),
              (this._w = h * l * u - c * p * d);
            break;
          case "XZY":
            (this._x = c * l * u - h * p * d),
              (this._y = h * p * u - c * l * d),
              (this._z = h * l * d + c * p * u),
              (this._w = h * l * u + c * p * d);
            break;
          default:
            console.warn(
              "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                n,
            );
        }
        return !1 !== e && this._onChangeCallback(), this;
      }
      setFromAxisAngle(t, e) {
        const i = e / 2,
          r = Math.sin(i);
        return (
          (this._x = t.x * r),
          (this._y = t.y * r),
          (this._z = t.z * r),
          (this._w = Math.cos(i)),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(t) {
        const e = t.elements,
          i = e[0],
          r = e[4],
          s = e[8],
          n = e[1],
          a = e[5],
          o = e[9],
          h = e[2],
          l = e[6],
          u = e[10],
          c = i + a + u;
        if (c > 0) {
          const t = 0.5 / Math.sqrt(c + 1);
          (this._w = 0.25 / t),
            (this._x = (l - o) * t),
            (this._y = (s - h) * t),
            (this._z = (n - r) * t);
        } else if (i > a && i > u) {
          const t = 2 * Math.sqrt(1 + i - a - u);
          (this._w = (l - o) / t),
            (this._x = 0.25 * t),
            (this._y = (r + n) / t),
            (this._z = (s + h) / t);
        } else if (a > u) {
          const t = 2 * Math.sqrt(1 + a - i - u);
          (this._w = (s - h) / t),
            (this._x = (r + n) / t),
            (this._y = 0.25 * t),
            (this._z = (o + l) / t);
        } else {
          const t = 2 * Math.sqrt(1 + u - i - a);
          (this._w = (n - r) / t),
            (this._x = (s + h) / t),
            (this._y = (o + l) / t),
            (this._z = 0.25 * t);
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(t, e) {
        let i = t.dot(e) + 1;
        return (
          i < 1e-6
            ? ((i = 0),
              Math.abs(t.x) > Math.abs(t.z)
                ? ((this._x = -t.y),
                  (this._y = t.x),
                  (this._z = 0),
                  (this._w = i))
                : ((this._x = 0),
                  (this._y = -t.z),
                  (this._z = t.y),
                  (this._w = i)))
            : ((this._x = t.y * e.z - t.z * e.y),
              (this._y = t.z * e.x - t.x * e.z),
              (this._z = t.x * e.y - t.y * e.x),
              (this._w = i)),
          this.normalize()
        );
      }
      angleTo(t) {
        return 2 * Math.acos(Math.abs(a.clamp(this.dot(t), -1, 1)));
      }
      rotateTowards(t, e) {
        const i = this.angleTo(t);
        if (0 === i) return this;
        const r = Math.min(1, e / i);
        return this.slerp(t, r), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      inverse() {
        return this.conjugate();
      }
      conjugate() {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this._onChangeCallback(),
          this
        );
      }
      dot(t) {
        return (
          this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        );
      }
      lengthSq() {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      }
      length() {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w,
        );
      }
      normalize() {
        let t = this.length();
        return (
          0 === t
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((t = 1 / t),
              (this._x = this._x * t),
              (this._y = this._y * t),
              (this._z = this._z * t),
              (this._w = this._w * t)),
          this._onChangeCallback(),
          this
        );
      }
      multiply(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.",
            ),
            this.multiplyQuaternions(t, e))
          : this.multiplyQuaternions(this, t);
      }
      premultiply(t) {
        return this.multiplyQuaternions(t, this);
      }
      multiplyQuaternions(t, e) {
        const i = t._x,
          r = t._y,
          s = t._z,
          n = t._w,
          a = e._x,
          o = e._y,
          h = e._z,
          l = e._w;
        return (
          (this._x = i * l + n * a + r * h - s * o),
          (this._y = r * l + n * o + s * a - i * h),
          (this._z = s * l + n * h + i * o - r * a),
          (this._w = n * l - i * a - r * o - s * h),
          this._onChangeCallback(),
          this
        );
      }
      slerp(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        const i = this._x,
          r = this._y,
          s = this._z,
          n = this._w;
        let a = n * t._w + i * t._x + r * t._y + s * t._z;
        if (
          (a < 0
            ? ((this._w = -t._w),
              (this._x = -t._x),
              (this._y = -t._y),
              (this._z = -t._z),
              (a = -a))
            : this.copy(t),
          a >= 1)
        )
          return (
            (this._w = n), (this._x = i), (this._y = r), (this._z = s), this
          );
        const o = 1 - a * a;
        if (o <= Number.EPSILON) {
          const t = 1 - e;
          return (
            (this._w = t * n + e * this._w),
            (this._x = t * i + e * this._x),
            (this._y = t * r + e * this._y),
            (this._z = t * s + e * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        const h = Math.sqrt(o),
          l = Math.atan2(h, a),
          u = Math.sin((1 - e) * l) / h,
          c = Math.sin(e * l) / h;
        return (
          (this._w = n * u + this._w * c),
          (this._x = i * u + this._x * c),
          (this._y = r * u + this._y * c),
          (this._z = s * u + this._z * c),
          this._onChangeCallback(),
          this
        );
      }
      equals(t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._w === this._w
        );
      }
      fromArray(t, e = 0) {
        return (
          (this._x = t[e]),
          (this._y = t[e + 1]),
          (this._z = t[e + 2]),
          (this._w = t[e + 3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._w),
          t
        );
      }
      fromBufferAttribute(t, e) {
        return (
          (this._x = t.getX(e)),
          (this._y = t.getY(e)),
          (this._z = t.getZ(e)),
          (this._w = t.getW(e)),
          this
        );
      }
      _onChange(t) {
        return (this._onChangeCallback = t), this;
      }
      _onChangeCallback() {}
    }
    class h {
      constructor(t = 0, e = 0, i = 0) {
        Object.defineProperty(this, "isVector3", { value: !0 }),
          (this.x = t),
          (this.y = e),
          (this.z = i);
      }
      set(t, e, i) {
        return (
          void 0 === i && (i = this.z),
          (this.x = t),
          (this.y = e),
          (this.z = i),
          this
        );
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), (this.z = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setZ(t) {
        return (this.z = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(t) {
        return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
      }
      add(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), (this.z += t), this;
      }
      addVectors(t, e) {
        return (
          (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
        );
      }
      addScaledVector(t, e) {
        return (
          (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
        );
      }
      sub(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), this;
      }
      subVectors(t, e) {
        return (
          (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
        );
      }
      multiply(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.",
            ),
            this.multiplyVectors(t, e))
          : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), this;
      }
      multiplyVectors(t, e) {
        return (
          (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
        );
      }
      applyEuler(t) {
        return (
          (t && t.isEuler) ||
            console.error(
              "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.",
            ),
          this.applyQuaternion(u.setFromEuler(t))
        );
      }
      applyAxisAngle(t, e) {
        return this.applyQuaternion(u.setFromAxisAngle(t, e));
      }
      applyMatrix3(t) {
        const e = this.x,
          i = this.y,
          r = this.z,
          s = t.elements;
        return (
          (this.x = s[0] * e + s[3] * i + s[6] * r),
          (this.y = s[1] * e + s[4] * i + s[7] * r),
          (this.z = s[2] * e + s[5] * i + s[8] * r),
          this
        );
      }
      applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize();
      }
      applyMatrix4(t) {
        const e = this.x,
          i = this.y,
          r = this.z,
          s = t.elements,
          n = 1 / (s[3] * e + s[7] * i + s[11] * r + s[15]);
        return (
          (this.x = (s[0] * e + s[4] * i + s[8] * r + s[12]) * n),
          (this.y = (s[1] * e + s[5] * i + s[9] * r + s[13]) * n),
          (this.z = (s[2] * e + s[6] * i + s[10] * r + s[14]) * n),
          this
        );
      }
      applyQuaternion(t) {
        const e = this.x,
          i = this.y,
          r = this.z,
          s = t.x,
          n = t.y,
          a = t.z,
          o = t.w,
          h = o * e + n * r - a * i,
          l = o * i + a * e - s * r,
          u = o * r + s * i - n * e,
          c = -s * e - n * i - a * r;
        return (
          (this.x = h * o + c * -s + l * -a - u * -n),
          (this.y = l * o + c * -n + u * -s - h * -a),
          (this.z = u * o + c * -a + h * -n - l * -s),
          this
        );
      }
      project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
          t.projectionMatrix,
        );
      }
      unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
          t.matrixWorld,
        );
      }
      transformDirection(t) {
        const e = this.x,
          i = this.y,
          r = this.z,
          s = t.elements;
        return (
          (this.x = s[0] * e + s[4] * i + s[8] * r),
          (this.y = s[1] * e + s[5] * i + s[9] * r),
          (this.z = s[2] * e + s[6] * i + s[10] * r),
          this.normalize()
        );
      }
      divide(t) {
        return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          this
        );
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(t, Math.min(e, i)),
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          this
        );
      }
      lerpVectors(t, e, i) {
        return (
          (this.x = t.x + (e.x - t.x) * i),
          (this.y = t.y + (e.y - t.y) * i),
          (this.z = t.z + (e.z - t.z) * i),
          this
        );
      }
      cross(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.",
            ),
            this.crossVectors(t, e))
          : this.crossVectors(this, t);
      }
      crossVectors(t, e) {
        const i = t.x,
          r = t.y,
          s = t.z,
          n = e.x,
          a = e.y,
          o = e.z;
        return (
          (this.x = r * o - s * a),
          (this.y = s * n - i * o),
          (this.z = i * a - r * n),
          this
        );
      }
      projectOnVector(t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const i = t.dot(this) / e;
        return this.copy(t).multiplyScalar(i);
      }
      projectOnPlane(t) {
        return l.copy(this).projectOnVector(t), this.sub(l);
      }
      reflect(t) {
        return this.sub(l.copy(t).multiplyScalar(2 * this.dot(t)));
      }
      angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const i = this.dot(t) / e;
        return Math.acos(a.clamp(i, -1, 1));
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x,
          i = this.y - t.y,
          r = this.z - t.z;
        return e * e + i * i + r * r;
      }
      manhattanDistanceTo(t) {
        return (
          Math.abs(this.x - t.x) +
          Math.abs(this.y - t.y) +
          Math.abs(this.z - t.z)
        );
      }
      setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      }
      setFromSphericalCoords(t, e, i) {
        const r = Math.sin(e) * t;
        return (
          (this.x = r * Math.sin(i)),
          (this.y = Math.cos(e) * t),
          (this.z = r * Math.cos(i)),
          this
        );
      }
      setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      }
      setFromCylindricalCoords(t, e, i) {
        return (
          (this.x = t * Math.sin(e)),
          (this.y = i),
          (this.z = t * Math.cos(e)),
          this
        );
      }
      setFromMatrixPosition(t) {
        const e = t.elements;
        return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
      }
      setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(),
          i = this.setFromMatrixColumn(t, 1).length(),
          r = this.setFromMatrixColumn(t, 2).length();
        return (this.x = e), (this.y = i), (this.z = r), this;
      }
      setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, 4 * e);
      }
      setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, 3 * e);
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      }
      fromArray(t, e = 0) {
        return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
      }
      fromBufferAttribute(t, e, i) {
        return (
          void 0 !== i &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute().",
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          this
        );
      }
    }
    const l = new h(),
      u = new o();
    class c {
      constructor() {
        Object.defineProperty(this, "isMatrix4", { value: !0 }),
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.",
            );
      }
      set(t, e, i, r, s, n, a, o, h, l, u, c, p, d, m, f) {
        const g = this.elements;
        return (
          (g[0] = t),
          (g[4] = e),
          (g[8] = i),
          (g[12] = r),
          (g[1] = s),
          (g[5] = n),
          (g[9] = a),
          (g[13] = o),
          (g[2] = h),
          (g[6] = l),
          (g[10] = u),
          (g[14] = c),
          (g[3] = p),
          (g[7] = d),
          (g[11] = m),
          (g[15] = f),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new c().fromArray(this.elements);
      }
      copy(t) {
        const e = this.elements,
          i = t.elements;
        return (
          (e[0] = i[0]),
          (e[1] = i[1]),
          (e[2] = i[2]),
          (e[3] = i[3]),
          (e[4] = i[4]),
          (e[5] = i[5]),
          (e[6] = i[6]),
          (e[7] = i[7]),
          (e[8] = i[8]),
          (e[9] = i[9]),
          (e[10] = i[10]),
          (e[11] = i[11]),
          (e[12] = i[12]),
          (e[13] = i[13]),
          (e[14] = i[14]),
          (e[15] = i[15]),
          this
        );
      }
      copyPosition(t) {
        const e = this.elements,
          i = t.elements;
        return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this;
      }
      extractBasis(t, e, i) {
        return (
          t.setFromMatrixColumn(this, 0),
          e.setFromMatrixColumn(this, 1),
          i.setFromMatrixColumn(this, 2),
          this
        );
      }
      makeBasis(t, e, i) {
        return (
          this.set(
            t.x,
            e.x,
            i.x,
            0,
            t.y,
            e.y,
            i.y,
            0,
            t.z,
            e.z,
            i.z,
            0,
            0,
            0,
            0,
            1,
          ),
          this
        );
      }
      extractRotation(t) {
        const e = this.elements,
          i = t.elements,
          r = 1 / p.setFromMatrixColumn(t, 0).length(),
          s = 1 / p.setFromMatrixColumn(t, 1).length(),
          n = 1 / p.setFromMatrixColumn(t, 2).length();
        return (
          (e[0] = i[0] * r),
          (e[1] = i[1] * r),
          (e[2] = i[2] * r),
          (e[3] = 0),
          (e[4] = i[4] * s),
          (e[5] = i[5] * s),
          (e[6] = i[6] * s),
          (e[7] = 0),
          (e[8] = i[8] * n),
          (e[9] = i[9] * n),
          (e[10] = i[10] * n),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      }
      makeRotationFromEuler(t) {
        (t && t.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.",
          );
        const e = this.elements,
          i = t.x,
          r = t.y,
          s = t.z,
          n = Math.cos(i),
          a = Math.sin(i),
          o = Math.cos(r),
          h = Math.sin(r),
          l = Math.cos(s),
          u = Math.sin(s);
        if ("XYZ" === t.order) {
          const t = n * l,
            i = n * u,
            r = a * l,
            s = a * u;
          (e[0] = o * l),
            (e[4] = -o * u),
            (e[8] = h),
            (e[1] = i + r * h),
            (e[5] = t - s * h),
            (e[9] = -a * o),
            (e[2] = s - t * h),
            (e[6] = r + i * h),
            (e[10] = n * o);
        } else if ("YXZ" === t.order) {
          const t = o * l,
            i = o * u,
            r = h * l,
            s = h * u;
          (e[0] = t + s * a),
            (e[4] = r * a - i),
            (e[8] = n * h),
            (e[1] = n * u),
            (e[5] = n * l),
            (e[9] = -a),
            (e[2] = i * a - r),
            (e[6] = s + t * a),
            (e[10] = n * o);
        } else if ("ZXY" === t.order) {
          const t = o * l,
            i = o * u,
            r = h * l,
            s = h * u;
          (e[0] = t - s * a),
            (e[4] = -n * u),
            (e[8] = r + i * a),
            (e[1] = i + r * a),
            (e[5] = n * l),
            (e[9] = s - t * a),
            (e[2] = -n * h),
            (e[6] = a),
            (e[10] = n * o);
        } else if ("ZYX" === t.order) {
          const t = n * l,
            i = n * u,
            r = a * l,
            s = a * u;
          (e[0] = o * l),
            (e[4] = r * h - i),
            (e[8] = t * h + s),
            (e[1] = o * u),
            (e[5] = s * h + t),
            (e[9] = i * h - r),
            (e[2] = -h),
            (e[6] = a * o),
            (e[10] = n * o);
        } else if ("YZX" === t.order) {
          const t = n * o,
            i = n * h,
            r = a * o,
            s = a * h;
          (e[0] = o * l),
            (e[4] = s - t * u),
            (e[8] = r * u + i),
            (e[1] = u),
            (e[5] = n * l),
            (e[9] = -a * l),
            (e[2] = -h * l),
            (e[6] = i * u + r),
            (e[10] = t - s * u);
        } else if ("XZY" === t.order) {
          const t = n * o,
            i = n * h,
            r = a * o,
            s = a * h;
          (e[0] = o * l),
            (e[4] = -u),
            (e[8] = h * l),
            (e[1] = t * u + s),
            (e[5] = n * l),
            (e[9] = i * u - r),
            (e[2] = r * u - i),
            (e[6] = a * l),
            (e[10] = s * u + t);
        }
        return (
          (e[3] = 0),
          (e[7] = 0),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      }
      makeRotationFromQuaternion(t) {
        return this.compose(m, t, f);
      }
      lookAt(t, e, i) {
        const r = this.elements;
        return (
          x.subVectors(t, e),
          0 === x.lengthSq() && (x.z = 1),
          x.normalize(),
          g.crossVectors(i, x),
          0 === g.lengthSq() &&
            (1 === Math.abs(i.z) ? (x.x += 1e-4) : (x.z += 1e-4),
            x.normalize(),
            g.crossVectors(i, x)),
          g.normalize(),
          y.crossVectors(x, g),
          (r[0] = g.x),
          (r[4] = y.x),
          (r[8] = x.x),
          (r[1] = g.y),
          (r[5] = y.y),
          (r[9] = x.y),
          (r[2] = g.z),
          (r[6] = y.z),
          (r[10] = x.z),
          this
        );
      }
      multiply(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.",
            ),
            this.multiplyMatrices(t, e))
          : this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const i = t.elements,
          r = e.elements,
          s = this.elements,
          n = i[0],
          a = i[4],
          o = i[8],
          h = i[12],
          l = i[1],
          u = i[5],
          c = i[9],
          p = i[13],
          d = i[2],
          m = i[6],
          f = i[10],
          g = i[14],
          y = i[3],
          x = i[7],
          b = i[11],
          v = i[15],
          M = r[0],
          w = r[4],
          _ = r[8],
          E = r[12],
          T = r[1],
          S = r[5],
          A = r[9],
          R = r[13],
          L = r[2],
          F = r[6],
          z = r[10],
          P = r[14],
          N = r[3],
          U = r[7],
          B = r[11],
          C = r[15];
        return (
          (s[0] = n * M + a * T + o * L + h * N),
          (s[4] = n * w + a * S + o * F + h * U),
          (s[8] = n * _ + a * A + o * z + h * B),
          (s[12] = n * E + a * R + o * P + h * C),
          (s[1] = l * M + u * T + c * L + p * N),
          (s[5] = l * w + u * S + c * F + p * U),
          (s[9] = l * _ + u * A + c * z + p * B),
          (s[13] = l * E + u * R + c * P + p * C),
          (s[2] = d * M + m * T + f * L + g * N),
          (s[6] = d * w + m * S + f * F + g * U),
          (s[10] = d * _ + m * A + f * z + g * B),
          (s[14] = d * E + m * R + f * P + g * C),
          (s[3] = y * M + x * T + b * L + v * N),
          (s[7] = y * w + x * S + b * F + v * U),
          (s[11] = y * _ + x * A + b * z + v * B),
          (s[15] = y * E + x * R + b * P + v * C),
          this
        );
      }
      multiplyScalar(t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[4] *= t),
          (e[8] *= t),
          (e[12] *= t),
          (e[1] *= t),
          (e[5] *= t),
          (e[9] *= t),
          (e[13] *= t),
          (e[2] *= t),
          (e[6] *= t),
          (e[10] *= t),
          (e[14] *= t),
          (e[3] *= t),
          (e[7] *= t),
          (e[11] *= t),
          (e[15] *= t),
          this
        );
      }
      determinant() {
        const t = this.elements,
          e = t[0],
          i = t[4],
          r = t[8],
          s = t[12],
          n = t[1],
          a = t[5],
          o = t[9],
          h = t[13],
          l = t[2],
          u = t[6],
          c = t[10],
          p = t[14];
        return (
          t[3] *
            (+s * o * u -
              r * h * u -
              s * a * c +
              i * h * c +
              r * a * p -
              i * o * p) +
          t[7] *
            (+e * o * p -
              e * h * c +
              s * n * c -
              r * n * p +
              r * h * l -
              s * o * l) +
          t[11] *
            (+e * h * u -
              e * a * p -
              s * n * u +
              i * n * p +
              s * a * l -
              i * h * l) +
          t[15] *
            (-r * a * l -
              e * o * u +
              e * a * c +
              r * n * u -
              i * n * c +
              i * o * l)
        );
      }
      transpose() {
        const t = this.elements;
        let e;
        return (
          (e = t[1]),
          (t[1] = t[4]),
          (t[4] = e),
          (e = t[2]),
          (t[2] = t[8]),
          (t[8] = e),
          (e = t[6]),
          (t[6] = t[9]),
          (t[9] = e),
          (e = t[3]),
          (t[3] = t[12]),
          (t[12] = e),
          (e = t[7]),
          (t[7] = t[13]),
          (t[13] = e),
          (e = t[11]),
          (t[11] = t[14]),
          (t[14] = e),
          this
        );
      }
      setPosition(t, e, i) {
        const r = this.elements;
        return (
          t.isVector3
            ? ((r[12] = t.x), (r[13] = t.y), (r[14] = t.z))
            : ((r[12] = t), (r[13] = e), (r[14] = i)),
          this
        );
      }
      getInverse(t, e) {
        void 0 !== e &&
          console.warn(
            "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.",
          );
        const i = this.elements,
          r = t.elements,
          s = r[0],
          n = r[1],
          a = r[2],
          o = r[3],
          h = r[4],
          l = r[5],
          u = r[6],
          c = r[7],
          p = r[8],
          d = r[9],
          m = r[10],
          f = r[11],
          g = r[12],
          y = r[13],
          x = r[14],
          b = r[15],
          v =
            d * x * c -
            y * m * c +
            y * u * f -
            l * x * f -
            d * u * b +
            l * m * b,
          M =
            g * m * c -
            p * x * c -
            g * u * f +
            h * x * f +
            p * u * b -
            h * m * b,
          w =
            p * y * c -
            g * d * c +
            g * l * f -
            h * y * f -
            p * l * b +
            h * d * b,
          _ =
            g * d * u -
            p * y * u -
            g * l * m +
            h * y * m +
            p * l * x -
            h * d * x,
          E = s * v + n * M + a * w + o * _;
        if (0 === E)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / E;
        return (
          (i[0] = v * T),
          (i[1] =
            (y * m * o -
              d * x * o -
              y * a * f +
              n * x * f +
              d * a * b -
              n * m * b) *
            T),
          (i[2] =
            (l * x * o -
              y * u * o +
              y * a * c -
              n * x * c -
              l * a * b +
              n * u * b) *
            T),
          (i[3] =
            (d * u * o -
              l * m * o -
              d * a * c +
              n * m * c +
              l * a * f -
              n * u * f) *
            T),
          (i[4] = M * T),
          (i[5] =
            (p * x * o -
              g * m * o +
              g * a * f -
              s * x * f -
              p * a * b +
              s * m * b) *
            T),
          (i[6] =
            (g * u * o -
              h * x * o -
              g * a * c +
              s * x * c +
              h * a * b -
              s * u * b) *
            T),
          (i[7] =
            (h * m * o -
              p * u * o +
              p * a * c -
              s * m * c -
              h * a * f +
              s * u * f) *
            T),
          (i[8] = w * T),
          (i[9] =
            (g * d * o -
              p * y * o -
              g * n * f +
              s * y * f +
              p * n * b -
              s * d * b) *
            T),
          (i[10] =
            (h * y * o -
              g * l * o +
              g * n * c -
              s * y * c -
              h * n * b +
              s * l * b) *
            T),
          (i[11] =
            (p * l * o -
              h * d * o -
              p * n * c +
              s * d * c +
              h * n * f -
              s * l * f) *
            T),
          (i[12] = _ * T),
          (i[13] =
            (p * y * a -
              g * d * a +
              g * n * m -
              s * y * m -
              p * n * x +
              s * d * x) *
            T),
          (i[14] =
            (g * l * a -
              h * y * a -
              g * n * u +
              s * y * u +
              h * n * x -
              s * l * x) *
            T),
          (i[15] =
            (h * d * a -
              p * l * a +
              p * n * u -
              s * d * u -
              h * n * m +
              s * l * m) *
            T),
          this
        );
      }
      scale(t) {
        const e = this.elements,
          i = t.x,
          r = t.y,
          s = t.z;
        return (
          (e[0] *= i),
          (e[4] *= r),
          (e[8] *= s),
          (e[1] *= i),
          (e[5] *= r),
          (e[9] *= s),
          (e[2] *= i),
          (e[6] *= r),
          (e[10] *= s),
          (e[3] *= i),
          (e[7] *= r),
          (e[11] *= s),
          this
        );
      }
      getMaxScaleOnAxis() {
        const t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, i, r));
      }
      makeTranslation(t, e, i) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
      }
      makeRotationX(t) {
        const e = Math.cos(t),
          i = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(t) {
        const e = Math.cos(t),
          i = Math.sin(t);
        return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(t) {
        const e = Math.cos(t),
          i = Math.sin(t);
        return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(t, e) {
        const i = Math.cos(e),
          r = Math.sin(e),
          s = 1 - i,
          n = t.x,
          a = t.y,
          o = t.z,
          h = s * n,
          l = s * a;
        return (
          this.set(
            h * n + i,
            h * a - r * o,
            h * o + r * a,
            0,
            h * a + r * o,
            l * a + i,
            l * o - r * n,
            0,
            h * o - r * a,
            l * o + r * n,
            s * o * o + i,
            0,
            0,
            0,
            0,
            1,
          ),
          this
        );
      }
      makeScale(t, e, i) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
      }
      makeShear(t, e, i) {
        return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this;
      }
      compose(t, e, i) {
        const r = this.elements,
          s = e._x,
          n = e._y,
          a = e._z,
          o = e._w,
          h = s + s,
          l = n + n,
          u = a + a,
          c = s * h,
          p = s * l,
          d = s * u,
          m = n * l,
          f = n * u,
          g = a * u,
          y = o * h,
          x = o * l,
          b = o * u,
          v = i.x,
          M = i.y,
          w = i.z;
        return (
          (r[0] = (1 - (m + g)) * v),
          (r[1] = (p + b) * v),
          (r[2] = (d - x) * v),
          (r[3] = 0),
          (r[4] = (p - b) * M),
          (r[5] = (1 - (c + g)) * M),
          (r[6] = (f + y) * M),
          (r[7] = 0),
          (r[8] = (d + x) * w),
          (r[9] = (f - y) * w),
          (r[10] = (1 - (c + m)) * w),
          (r[11] = 0),
          (r[12] = t.x),
          (r[13] = t.y),
          (r[14] = t.z),
          (r[15] = 1),
          this
        );
      }
      decompose(t, e, i) {
        const r = this.elements;
        let s = p.set(r[0], r[1], r[2]).length();
        const n = p.set(r[4], r[5], r[6]).length(),
          a = p.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
          (t.x = r[12]),
          (t.y = r[13]),
          (t.z = r[14]),
          d.copy(this);
        const o = 1 / s,
          h = 1 / n,
          l = 1 / a;
        return (
          (d.elements[0] *= o),
          (d.elements[1] *= o),
          (d.elements[2] *= o),
          (d.elements[4] *= h),
          (d.elements[5] *= h),
          (d.elements[6] *= h),
          (d.elements[8] *= l),
          (d.elements[9] *= l),
          (d.elements[10] *= l),
          e.setFromRotationMatrix(d),
          (i.x = s),
          (i.y = n),
          (i.z = a),
          this
        );
      }
      makePerspective(t, e, i, r, s, n) {
        void 0 === n &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.",
          );
        const a = this.elements,
          o = (2 * s) / (e - t),
          h = (2 * s) / (i - r),
          l = (e + t) / (e - t),
          u = (i + r) / (i - r),
          c = -(n + s) / (n - s),
          p = (-2 * n * s) / (n - s);
        return (
          (a[0] = o),
          (a[4] = 0),
          (a[8] = l),
          (a[12] = 0),
          (a[1] = 0),
          (a[5] = h),
          (a[9] = u),
          (a[13] = 0),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = c),
          (a[14] = p),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = -1),
          (a[15] = 0),
          this
        );
      }
      makeOrthographic(t, e, i, r, s, n) {
        const a = this.elements,
          o = 1 / (e - t),
          h = 1 / (i - r),
          l = 1 / (n - s),
          u = (e + t) * o,
          c = (i + r) * h,
          p = (n + s) * l;
        return (
          (a[0] = 2 * o),
          (a[4] = 0),
          (a[8] = 0),
          (a[12] = -u),
          (a[1] = 0),
          (a[5] = 2 * h),
          (a[9] = 0),
          (a[13] = -c),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = -2 * l),
          (a[14] = -p),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = 0),
          (a[15] = 1),
          this
        );
      }
      equals(t) {
        const e = this.elements,
          i = t.elements;
        for (let t = 0; t < 16; t++) if (e[t] !== i[t]) return !1;
        return !0;
      }
      fromArray(t, e = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const i = this.elements;
        return (
          (t[e] = i[0]),
          (t[e + 1] = i[1]),
          (t[e + 2] = i[2]),
          (t[e + 3] = i[3]),
          (t[e + 4] = i[4]),
          (t[e + 5] = i[5]),
          (t[e + 6] = i[6]),
          (t[e + 7] = i[7]),
          (t[e + 8] = i[8]),
          (t[e + 9] = i[9]),
          (t[e + 10] = i[10]),
          (t[e + 11] = i[11]),
          (t[e + 12] = i[12]),
          (t[e + 13] = i[13]),
          (t[e + 14] = i[14]),
          (t[e + 15] = i[15]),
          t
        );
      }
    }
    const p = new h(),
      d = new c(),
      m = new h(0, 0, 0),
      f = new h(1, 1, 1),
      g = new h(),
      y = new h(),
      x = new h();
    function b() {}
    Object.assign(b.prototype, {
      addEventListener: function (t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const i = this._listeners;
        void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e);
      },
      hasEventListener: function (t, e) {
        if (void 0 === this._listeners) return !1;
        const i = this._listeners;
        return void 0 !== i[t] && -1 !== i[t].indexOf(e);
      },
      removeEventListener: function (t, e) {
        if (void 0 === this._listeners) return;
        const i = this._listeners[t];
        if (void 0 !== i) {
          const t = i.indexOf(e);
          -1 !== t && i.splice(t, 1);
        }
      },
      dispatchEvent: function (t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          const i = e.slice(0);
          for (let e = 0, r = i.length; e < r; e++) i[e].call(this, t);
        }
      },
    });
    class v {
      constructor(t = 0, e = 0, i = 0, r = v.DefaultOrder) {
        Object.defineProperty(this, "isEuler", { value: !0 }),
          (this._x = t),
          (this._y = e),
          (this._z = i),
          (this._order = r);
      }
      get x() {
        return this._x;
      }
      set x(t) {
        (this._x = t), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(t) {
        (this._y = t), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(t) {
        (this._z = t), this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(t) {
        (this._order = t), this._onChangeCallback();
      }
      set(t, e, i, r) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = i),
          (this._order = r || this._order),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(t) {
        return (
          (this._x = t._x),
          (this._y = t._y),
          (this._z = t._z),
          (this._order = t._order),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(t, e, i) {
        const r = a.clamp,
          s = t.elements,
          n = s[0],
          o = s[4],
          h = s[8],
          l = s[1],
          u = s[5],
          c = s[9],
          p = s[2],
          d = s[6],
          m = s[10];
        switch ((e = e || this._order)) {
          case "XYZ":
            (this._y = Math.asin(r(h, -1, 1))),
              Math.abs(h) < 0.9999999
                ? ((this._x = Math.atan2(-c, m)), (this._z = Math.atan2(-o, n)))
                : ((this._x = Math.atan2(d, u)), (this._z = 0));
            break;
          case "YXZ":
            (this._x = Math.asin(-r(c, -1, 1))),
              Math.abs(c) < 0.9999999
                ? ((this._y = Math.atan2(h, m)), (this._z = Math.atan2(l, u)))
                : ((this._y = Math.atan2(-p, n)), (this._z = 0));
            break;
          case "ZXY":
            (this._x = Math.asin(r(d, -1, 1))),
              Math.abs(d) < 0.9999999
                ? ((this._y = Math.atan2(-p, m)), (this._z = Math.atan2(-o, u)))
                : ((this._y = 0), (this._z = Math.atan2(l, n)));
            break;
          case "ZYX":
            (this._y = Math.asin(-r(p, -1, 1))),
              Math.abs(p) < 0.9999999
                ? ((this._x = Math.atan2(d, m)), (this._z = Math.atan2(l, n)))
                : ((this._x = 0), (this._z = Math.atan2(-o, u)));
            break;
          case "YZX":
            (this._z = Math.asin(r(l, -1, 1))),
              Math.abs(l) < 0.9999999
                ? ((this._x = Math.atan2(-c, u)), (this._y = Math.atan2(-p, n)))
                : ((this._x = 0), (this._y = Math.atan2(h, m)));
            break;
          case "XZY":
            (this._z = Math.asin(-r(o, -1, 1))),
              Math.abs(o) < 0.9999999
                ? ((this._x = Math.atan2(d, u)), (this._y = Math.atan2(h, n)))
                : ((this._x = Math.atan2(-c, m)), (this._y = 0));
            break;
          default:
            console.warn(
              "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                e,
            );
        }
        return (this._order = e), !1 !== i && this._onChangeCallback(), this;
      }
      setFromQuaternion(t, e, i) {
        return (
          M.makeRotationFromQuaternion(t), this.setFromRotationMatrix(M, e, i)
        );
      }
      setFromVector3(t, e) {
        return this.set(t.x, t.y, t.z, e || this._order);
      }
      reorder(t) {
        return w.setFromEuler(this), this.setFromQuaternion(w, t);
      }
      equals(t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._order === this._order
        );
      }
      fromArray(t) {
        return (
          (this._x = t[0]),
          (this._y = t[1]),
          (this._z = t[2]),
          void 0 !== t[3] && (this._order = t[3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._order),
          t
        );
      }
      toVector3(t) {
        return t
          ? t.set(this._x, this._y, this._z)
          : new h(this._x, this._y, this._z);
      }
      _onChange(t) {
        return (this._onChangeCallback = t), this;
      }
      _onChangeCallback() {}
    }
    (v.DefaultOrder = "XYZ"),
      (v.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
    const M = new c(),
      w = new o();
    class _ {
      constructor() {
        this.mask = 1;
      }
      set(t) {
        this.mask = (1 << t) | 0;
      }
      enable(t) {
        this.mask |= (1 << t) | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(t) {
        this.mask ^= (1 << t) | 0;
      }
      disable(t) {
        this.mask &= ~((1 << t) | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(t) {
        return 0 != (this.mask & t.mask);
      }
    }
    class E {
      constructor() {
        Object.defineProperty(this, "isMatrix3", { value: !0 }),
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.",
            );
      }
      set(t, e, i, r, s, n, a, o, h) {
        const l = this.elements;
        return (
          (l[0] = t),
          (l[1] = r),
          (l[2] = a),
          (l[3] = e),
          (l[4] = s),
          (l[5] = o),
          (l[6] = i),
          (l[7] = n),
          (l[8] = h),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
      copy(t) {
        const e = this.elements,
          i = t.elements;
        return (
          (e[0] = i[0]),
          (e[1] = i[1]),
          (e[2] = i[2]),
          (e[3] = i[3]),
          (e[4] = i[4]),
          (e[5] = i[5]),
          (e[6] = i[6]),
          (e[7] = i[7]),
          (e[8] = i[8]),
          this
        );
      }
      extractBasis(t, e, i) {
        return (
          t.setFromMatrix3Column(this, 0),
          e.setFromMatrix3Column(this, 1),
          i.setFromMatrix3Column(this, 2),
          this
        );
      }
      setFromMatrix4(t) {
        const e = t.elements;
        return (
          this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        );
      }
      multiply(t) {
        return this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const i = t.elements,
          r = e.elements,
          s = this.elements,
          n = i[0],
          a = i[3],
          o = i[6],
          h = i[1],
          l = i[4],
          u = i[7],
          c = i[2],
          p = i[5],
          d = i[8],
          m = r[0],
          f = r[3],
          g = r[6],
          y = r[1],
          x = r[4],
          b = r[7],
          v = r[2],
          M = r[5],
          w = r[8];
        return (
          (s[0] = n * m + a * y + o * v),
          (s[3] = n * f + a * x + o * M),
          (s[6] = n * g + a * b + o * w),
          (s[1] = h * m + l * y + u * v),
          (s[4] = h * f + l * x + u * M),
          (s[7] = h * g + l * b + u * w),
          (s[2] = c * m + p * y + d * v),
          (s[5] = c * f + p * x + d * M),
          (s[8] = c * g + p * b + d * w),
          this
        );
      }
      multiplyScalar(t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[3] *= t),
          (e[6] *= t),
          (e[1] *= t),
          (e[4] *= t),
          (e[7] *= t),
          (e[2] *= t),
          (e[5] *= t),
          (e[8] *= t),
          this
        );
      }
      determinant() {
        const t = this.elements,
          e = t[0],
          i = t[1],
          r = t[2],
          s = t[3],
          n = t[4],
          a = t[5],
          o = t[6],
          h = t[7],
          l = t[8];
        return (
          e * n * l - e * a * h - i * s * l + i * a * o + r * s * h - r * n * o
        );
      }
      getInverse(t, e) {
        void 0 !== e &&
          console.warn(
            "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.",
          );
        const i = t.elements,
          r = this.elements,
          s = i[0],
          n = i[1],
          a = i[2],
          o = i[3],
          h = i[4],
          l = i[5],
          u = i[6],
          c = i[7],
          p = i[8],
          d = p * h - l * c,
          m = l * u - p * o,
          f = c * o - h * u,
          g = s * d + n * m + a * f;
        if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const y = 1 / g;
        return (
          (r[0] = d * y),
          (r[1] = (a * c - p * n) * y),
          (r[2] = (l * n - a * h) * y),
          (r[3] = m * y),
          (r[4] = (p * s - a * u) * y),
          (r[5] = (a * o - l * s) * y),
          (r[6] = f * y),
          (r[7] = (n * u - c * s) * y),
          (r[8] = (h * s - n * o) * y),
          this
        );
      }
      transpose() {
        let t;
        const e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[3]),
          (e[3] = t),
          (t = e[2]),
          (e[2] = e[6]),
          (e[6] = t),
          (t = e[5]),
          (e[5] = e[7]),
          (e[7] = t),
          this
        );
      }
      getNormalMatrix(t) {
        return this.setFromMatrix4(t).getInverse(this).transpose();
      }
      transposeIntoArray(t) {
        const e = this.elements;
        return (
          (t[0] = e[0]),
          (t[1] = e[3]),
          (t[2] = e[6]),
          (t[3] = e[1]),
          (t[4] = e[4]),
          (t[5] = e[7]),
          (t[6] = e[2]),
          (t[7] = e[5]),
          (t[8] = e[8]),
          this
        );
      }
      setUvTransform(t, e, i, r, s, n, a) {
        const o = Math.cos(s),
          h = Math.sin(s);
        this.set(
          i * o,
          i * h,
          -i * (o * n + h * a) + n + t,
          -r * h,
          r * o,
          -r * (-h * n + o * a) + a + e,
          0,
          0,
          1,
        );
      }
      scale(t, e) {
        const i = this.elements;
        return (
          (i[0] *= t),
          (i[3] *= t),
          (i[6] *= t),
          (i[1] *= e),
          (i[4] *= e),
          (i[7] *= e),
          this
        );
      }
      rotate(t) {
        const e = Math.cos(t),
          i = Math.sin(t),
          r = this.elements,
          s = r[0],
          n = r[3],
          a = r[6],
          o = r[1],
          h = r[4],
          l = r[7];
        return (
          (r[0] = e * s + i * o),
          (r[3] = e * n + i * h),
          (r[6] = e * a + i * l),
          (r[1] = -i * s + e * o),
          (r[4] = -i * n + e * h),
          (r[7] = -i * a + e * l),
          this
        );
      }
      translate(t, e) {
        const i = this.elements;
        return (
          (i[0] += t * i[2]),
          (i[3] += t * i[5]),
          (i[6] += t * i[8]),
          (i[1] += e * i[2]),
          (i[4] += e * i[5]),
          (i[7] += e * i[8]),
          this
        );
      }
      equals(t) {
        const e = this.elements,
          i = t.elements;
        for (let t = 0; t < 9; t++) if (e[t] !== i[t]) return !1;
        return !0;
      }
      fromArray(t, e = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const i = this.elements;
        return (
          (t[e] = i[0]),
          (t[e + 1] = i[1]),
          (t[e + 2] = i[2]),
          (t[e + 3] = i[3]),
          (t[e + 4] = i[4]),
          (t[e + 5] = i[5]),
          (t[e + 6] = i[6]),
          (t[e + 7] = i[7]),
          (t[e + 8] = i[8]),
          t
        );
      }
    }
    let T = 0;
    const S = new h(),
      A = new o(),
      R = new c(),
      L = new h(),
      F = new h(),
      z = new h(),
      P = new o(),
      N = new h(1, 0, 0),
      U = new h(0, 1, 0),
      B = new h(0, 0, 1),
      C = { type: "added" },
      O = { type: "removed" };
    function D() {
      Object.defineProperty(this, "id", { value: T++ }),
        (this.uuid = a.generateUUID()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = D.DefaultUp.clone());
      const t = new h(),
        e = new v(),
        i = new o(),
        r = new h(1, 1, 1);
      e._onChange(function () {
        i.setFromEuler(e, !1);
      }),
        i._onChange(function () {
          e.setFromQuaternion(i, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: i },
          scale: { configurable: !0, enumerable: !0, value: r },
          modelViewMatrix: { value: new c() },
          normalMatrix: { value: new E() },
        }),
        (this.matrix = new c()),
        (this.matrixWorld = new c()),
        (this.matrixAutoUpdate = D.DefaultMatrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new _()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.userData = {});
    }
    function I() {
      D.call(this),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new c()),
        (this.projectionMatrix = new c()),
        (this.projectionMatrixInverse = new c());
    }
    function k(t, e, i, r) {
      I.call(this),
        (this.type = "PerspectiveCamera"),
        (this.fov = void 0 !== t ? t : 50),
        (this.zoom = 1),
        (this.near = void 0 !== i ? i : 0.1),
        (this.far = void 0 !== r ? r : 2e3),
        (this.focus = 10),
        (this.aspect = void 0 !== e ? e : 1),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    (D.DefaultUp = new h(0, 1, 0)),
      (D.DefaultMatrixAutoUpdate = !0),
      (D.prototype = Object.assign(Object.create(b.prototype), {
        constructor: D,
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix4: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function (t) {
          return this.quaternion.premultiply(t), this;
        },
        setRotationFromAxisAngle: function (t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        },
        setRotationFromEuler: function (t) {
          this.quaternion.setFromEuler(t, !0);
        },
        setRotationFromMatrix: function (t) {
          this.quaternion.setFromRotationMatrix(t);
        },
        setRotationFromQuaternion: function (t) {
          this.quaternion.copy(t);
        },
        rotateOnAxis: function (t, e) {
          return A.setFromAxisAngle(t, e), this.quaternion.multiply(A), this;
        },
        rotateOnWorldAxis: function (t, e) {
          return A.setFromAxisAngle(t, e), this.quaternion.premultiply(A), this;
        },
        rotateX: function (t) {
          return this.rotateOnAxis(N, t);
        },
        rotateY: function (t) {
          return this.rotateOnAxis(U, t);
        },
        rotateZ: function (t) {
          return this.rotateOnAxis(B, t);
        },
        translateOnAxis: function (t, e) {
          return (
            S.copy(t).applyQuaternion(this.quaternion),
            this.position.add(S.multiplyScalar(e)),
            this
          );
        },
        translateX: function (t) {
          return this.translateOnAxis(N, t);
        },
        translateY: function (t) {
          return this.translateOnAxis(U, t);
        },
        translateZ: function (t) {
          return this.translateOnAxis(B, t);
        },
        localToWorld: function (t) {
          return t.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function (t) {
          return t.applyMatrix4(R.getInverse(this.matrixWorld));
        },
        lookAt: function (t, e, i) {
          t.isVector3 ? L.copy(t) : L.set(t, e, i);
          const r = this.parent;
          this.updateWorldMatrix(!0, !1),
            F.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? R.lookAt(F, L, this.up)
              : R.lookAt(L, F, this.up),
            this.quaternion.setFromRotationMatrix(R),
            r &&
              (R.extractRotation(r.matrixWorld),
              A.setFromRotationMatrix(R),
              this.quaternion.premultiply(A.inverse()));
        },
        add: function (t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t,
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(C))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t,
                  ),
              this);
        },
        remove: function (t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
              this.remove(arguments[t]);
            return this;
          }
          const e = this.children.indexOf(t);
          return (
            -1 !== e &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(O)),
            this
          );
        },
        removeAll: function () {
          for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            (e.parent = null), e.dispatchEvent(O);
          }
          return (this.children.length = 0), this;
        },
        attach: function (t) {
          return (
            this.updateWorldMatrix(!0, !1),
            R.getInverse(this.matrixWorld),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              R.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(R),
            t.updateWorldMatrix(!1, !1),
            this.add(t),
            this
          );
        },
        getObjectById: function (t) {
          return this.getObjectByProperty("id", t);
        },
        getObjectByName: function (t) {
          return this.getObjectByProperty("name", t);
        },
        getObjectByProperty: function (t, e) {
          if (this[t] === e) return this;
          for (let i = 0, r = this.children.length; i < r; i++) {
            const r = this.children[i].getObjectByProperty(t, e);
            if (void 0 !== r) return r;
          }
        },
        getWorldPosition: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required",
              ),
              (t = new h())),
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        },
        getWorldQuaternion: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required",
              ),
              (t = new o())),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(F, t, z),
            t
          );
        },
        getWorldScale: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required",
              ),
              (t = new h())),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(F, P, t),
            t
          );
        },
        getWorldDirection: function (t) {
          void 0 === t &&
            (console.warn(
              "THREE.Object3D: .getWorldDirection() target is now required",
            ),
            (t = new h())),
            this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        },
        raycast: function () {},
        traverse: function (t) {
          t(this);
          const e = this.children;
          for (let i = 0, r = e.length; i < r; i++) e[i].traverse(t);
        },
        traverseVisible: function (t) {
          if (!1 === this.visible) return;
          t(this);
          const e = this.children;
          for (let i = 0, r = e.length; i < r; i++) e[i].traverseVisible(t);
        },
        traverseAncestors: function (t) {
          const e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        },
        updateMatrix: function () {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        },
        updateMatrixWorld: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix,
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          const e = this.children;
          for (let i = 0, r = e.length; i < r; i++) e[i].updateMatrixWorld(t);
        },
        updateWorldMatrix: function (t, e) {
          const i = this.parent;
          if (
            (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix,
                ),
            !0 === e)
          ) {
            const t = this.children;
            for (let e = 0, i = t.length; e < i; e++)
              t[e].updateWorldMatrix(!1, !0);
          }
        },
        toJSON: function (t) {
          const e = void 0 === t || "string" == typeof t,
            i = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
            }),
            (i.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const r = {};
          function s(e, i) {
            return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid;
          }
          if (
            ((r.uuid = this.uuid),
            (r.type = this.type),
            "" !== this.name && (r.name = this.name),
            !0 === this.castShadow && (r.castShadow = !0),
            !0 === this.receiveShadow && (r.receiveShadow = !0),
            !1 === this.visible && (r.visible = !1),
            !1 === this.frustumCulled && (r.frustumCulled = !1),
            0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) &&
              (r.userData = this.userData),
            (r.layers = this.layers.mask),
            (r.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((r.type = "InstancedMesh"),
              (r.count = this.count),
              (r.instanceMatrix = this.instanceMatrix.toJSON())),
            this.isMesh || this.isLine || this.isPoints)
          ) {
            r.geometry = s(t.geometries, this.geometry);
            const e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
              const i = e.shapes;
              if (Array.isArray(i))
                for (let e = 0, r = i.length; e < r; e++) {
                  const r = i[e];
                  s(t.shapes, r);
                }
              else s(t.shapes, i);
            }
          }
          if (void 0 !== this.material)
            if (Array.isArray(this.material)) {
              const e = [];
              for (let i = 0, r = this.material.length; i < r; i++)
                e.push(s(t.materials, this.material[i]));
              r.material = e;
            } else r.material = s(t.materials, this.material);
          if (this.children.length > 0) {
            r.children = [];
            for (let e = 0; e < this.children.length; e++)
              r.children.push(this.children[e].toJSON(t).object);
          }
          if (e) {
            const e = n(t.geometries),
              r = n(t.materials),
              s = n(t.textures),
              a = n(t.images),
              o = n(t.shapes);
            e.length > 0 && (i.geometries = e),
              r.length > 0 && (i.materials = r),
              s.length > 0 && (i.textures = s),
              a.length > 0 && (i.images = a),
              o.length > 0 && (i.shapes = o);
          }
          return (i.object = r), i;
          function n(t) {
            const e = [];
            for (const i in t) {
              const r = t[i];
              delete r.metadata, e.push(r);
            }
            return e;
          }
        },
        clone: function (t) {
          return new this.constructor().copy(this, t);
        },
        copy: function (t, e) {
          if (
            (void 0 === e && (e = !0),
            (this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let e = 0; e < t.children.length; e++) {
              const i = t.children[e];
              this.add(i.clone());
            }
          return this;
        },
      })),
      (I.prototype = Object.assign(Object.create(D.prototype), {
        constructor: I,
        isCamera: !0,
        copy: function (t, e) {
          return (
            D.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          );
        },
        getWorldDirection: function (t) {
          void 0 === t &&
            (console.warn(
              "THREE.Camera: .getWorldDirection() target is now required",
            ),
            (t = new h())),
            this.updateMatrixWorld(!0);
          const e = this.matrixWorld.elements;
          return t.set(-e[8], -e[9], -e[10]).normalize();
        },
        updateMatrixWorld: function (t) {
          D.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        updateWorldMatrix: function (t, e) {
          D.prototype.updateWorldMatrix.call(this, t, e),
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      })),
      (k.prototype = Object.assign(Object.create(I.prototype), {
        constructor: k,
        isPerspectiveCamera: !0,
        copy: function (t, e) {
          return (
            I.prototype.copy.call(this, t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        },
        setFocalLength: function (t) {
          const e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * a.RAD2DEG * Math.atan(e)),
            this.updateProjectionMatrix();
        },
        getFocalLength: function () {
          const t = Math.tan(0.5 * a.DEG2RAD * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        },
        getEffectiveFOV: function () {
          return (
            2 *
            a.RAD2DEG *
            Math.atan(Math.tan(0.5 * a.DEG2RAD * this.fov) / this.zoom)
          );
        },
        getFilmWidth: function () {
          return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function () {
          return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function (t, e, i, r, s, n) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = n),
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
          const t = this.near;
          let e = (t * Math.tan(0.5 * a.DEG2RAD * this.fov)) / this.zoom,
            i = 2 * e,
            r = this.aspect * i,
            s = -0.5 * r;
          const n = this.view;
          if (null !== this.view && this.view.enabled) {
            const t = n.fullWidth,
              a = n.fullHeight;
            (s += (n.offsetX * r) / t),
              (e -= (n.offsetY * i) / a),
              (r *= n.width / t),
              (i *= n.height / a);
          }
          const o = this.filmOffset;
          0 !== o && (s += (t * o) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              s,
              s + r,
              e,
              e - i,
              t,
              this.far,
            ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function (t) {
          const e = D.prototype.toJSON.call(this, t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        },
      }));
    const G = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      W = { h: 0, s: 0, l: 0 },
      V = { h: 0, s: 0, l: 0 };
    function H(t, e, i) {
      return (
        i < 0 && (i += 1),
        i > 1 && (i -= 1),
        i < 1 / 6
          ? t + 6 * (e - t) * i
          : i < 0.5
          ? e
          : i < 2 / 3
          ? t + 6 * (e - t) * (2 / 3 - i)
          : t
      );
    }
    function X(t) {
      return t < 0.04045
        ? 0.0773993808 * t
        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
    }
    function j(t) {
      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
    }
    class q {
      constructor(t, e, i) {
        return (
          Object.defineProperty(this, "isColor", { value: !0 }),
          void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        );
      }
      set(t) {
        return (
          t && t.isColor
            ? this.copy(t)
            : "number" == typeof t
            ? this.setHex(t)
            : "string" == typeof t && this.setStyle(t),
          this
        );
      }
      setScalar(t) {
        return (this.r = t), (this.g = t), (this.b = t), this;
      }
      setHex(t) {
        return (
          (t = Math.floor(t)),
          (this.r = ((t >> 16) & 255) / 255),
          (this.g = ((t >> 8) & 255) / 255),
          (this.b = (255 & t) / 255),
          this
        );
      }
      setRGB(t, e, i) {
        return (this.r = t), (this.g = e), (this.b = i), this;
      }
      setHSL(t, e, i) {
        if (
          ((t = a.euclideanModulo(t, 1)),
          (e = a.clamp(e, 0, 1)),
          (i = a.clamp(i, 0, 1)),
          0 === e)
        )
          this.r = this.g = this.b = i;
        else {
          const r = i <= 0.5 ? i * (1 + e) : i + e - i * e,
            s = 2 * i - r;
          (this.r = H(s, r, t + 1 / 3)),
            (this.g = H(s, r, t)),
            (this.b = H(s, r, t - 1 / 3));
        }
        return this;
      }
      setStyle(t) {
        function e(e) {
          void 0 !== e &&
            parseFloat(e) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + t + " will be ignored.",
            );
        }
        let i;
        if ((i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
          let t;
          const r = i[1],
            s = i[2];
          switch (r) {
            case "rgb":
            case "rgba":
              if (
                (t =
                  /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    s,
                  ))
              )
                return (
                  (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                  e(t[5]),
                  this
                );
              if (
                (t =
                  /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    s,
                  ))
              )
                return (
                  (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                  e(t[5]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (t =
                  /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    s,
                  ))
              ) {
                const i = parseFloat(t[1]) / 360,
                  r = parseInt(t[2], 10) / 100,
                  s = parseInt(t[3], 10) / 100;
                return e(t[5]), this.setHSL(i, r, s);
              }
          }
        } else if ((i = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
          const t = i[1],
            e = t.length;
          if (3 === e)
            return (
              (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
              (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
              (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
              this
            );
          if (6 === e)
            return (
              (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
              (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
              (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
              this
            );
        }
        return t && t.length > 0 ? this.setColorName(t) : this;
      }
      setColorName(t) {
        const e = G[t];
        return (
          void 0 !== e
            ? this.setHex(e)
            : console.warn("THREE.Color: Unknown color " + t),
          this
        );
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(t) {
        return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
      }
      copyGammaToLinear(t, e) {
        return (
          void 0 === e && (e = 2),
          (this.r = Math.pow(t.r, e)),
          (this.g = Math.pow(t.g, e)),
          (this.b = Math.pow(t.b, e)),
          this
        );
      }
      copyLinearToGamma(t, e) {
        void 0 === e && (e = 2);
        const i = e > 0 ? 1 / e : 1;
        return (
          (this.r = Math.pow(t.r, i)),
          (this.g = Math.pow(t.g, i)),
          (this.b = Math.pow(t.b, i)),
          this
        );
      }
      convertGammaToLinear(t) {
        return this.copyGammaToLinear(this, t), this;
      }
      convertLinearToGamma(t) {
        return this.copyLinearToGamma(this, t), this;
      }
      copySRGBToLinear(t) {
        return (this.r = X(t.r)), (this.g = X(t.g)), (this.b = X(t.b)), this;
      }
      copyLinearToSRGB(t) {
        return (this.r = j(t.r)), (this.g = j(t.g)), (this.b = j(t.b)), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex() {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(t) {
        void 0 === t &&
          (console.warn("THREE.Color: .getHSL() target is now required"),
          (t = { h: 0, s: 0, l: 0 }));
        const e = this.r,
          i = this.g,
          r = this.b,
          s = Math.max(e, i, r),
          n = Math.min(e, i, r);
        let a, o;
        const h = (n + s) / 2;
        if (n === s) (a = 0), (o = 0);
        else {
          const t = s - n;
          switch (((o = h <= 0.5 ? t / (s + n) : t / (2 - s - n)), s)) {
            case e:
              a = (i - r) / t + (i < r ? 6 : 0);
              break;
            case i:
              a = (r - e) / t + 2;
              break;
            case r:
              a = (e - i) / t + 4;
          }
          a /= 6;
        }
        return (t.h = a), (t.s = o), (t.l = h), t;
      }
      getStyle() {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      }
      offsetHSL(t, e, i) {
        return (
          this.getHSL(W),
          (W.h += t),
          (W.s += e),
          (W.l += i),
          this.setHSL(W.h, W.s, W.l),
          this
        );
      }
      add(t) {
        return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
      }
      addColors(t, e) {
        return (
          (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
        );
      }
      addScalar(t) {
        return (this.r += t), (this.g += t), (this.b += t), this;
      }
      sub(t) {
        return (
          (this.r = Math.max(0, this.r - t.r)),
          (this.g = Math.max(0, this.g - t.g)),
          (this.b = Math.max(0, this.b - t.b)),
          this
        );
      }
      multiply(t) {
        return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
      }
      multiplyScalar(t) {
        return (this.r *= t), (this.g *= t), (this.b *= t), this;
      }
      lerp(t, e) {
        return (
          (this.r += (t.r - this.r) * e),
          (this.g += (t.g - this.g) * e),
          (this.b += (t.b - this.b) * e),
          this
        );
      }
      lerpHSL(t, e) {
        this.getHSL(W), t.getHSL(V);
        const i = a.lerp(W.h, V.h, e),
          r = a.lerp(W.s, V.s, e),
          s = a.lerp(W.l, V.l, e);
        return this.setHSL(i, r, s), this;
      }
      equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      }
      fromArray(t, e = 0) {
        return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
      }
      fromBufferAttribute(t, e) {
        return (
          (this.r = t.getX(e)),
          (this.g = t.getY(e)),
          (this.b = t.getZ(e)),
          !0 === t.normalized &&
            ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
          this
        );
      }
      toJSON() {
        return this.getHex();
      }
    }
    (q.NAMES = G),
      (q.prototype.r = 1),
      (q.prototype.g = 1),
      (q.prototype.b = 1);
    const Y = 0,
      Z = 1,
      J = 2,
      Q = 1,
      K = 3,
      $ = 0,
      tt = 1,
      et = 2,
      it = 0,
      rt = 1,
      st = 2,
      nt = 3,
      at = 4,
      ot = 5,
      ht = 100,
      lt = 101,
      ut = 102,
      ct = 103,
      pt = 104,
      dt = 200,
      mt = 201,
      ft = 202,
      gt = 203,
      yt = 204,
      xt = 205,
      bt = 206,
      vt = 207,
      Mt = 208,
      wt = 209,
      _t = 210,
      Et = 0,
      Tt = 1,
      St = 2,
      At = 3,
      Rt = 4,
      Lt = 5,
      Ft = 6,
      zt = 7,
      Pt = 0,
      Nt = 0,
      Ut = 301,
      Bt = 302,
      Ct = 303,
      Ot = 304,
      Dt = 306,
      It = 307,
      kt = 1e3,
      Gt = 1001,
      Wt = 1002,
      Vt = 1003,
      Ht = 1004,
      Xt = 1005,
      jt = 1006,
      qt = 1007,
      Yt = 1008,
      Zt = 1009,
      Jt = 1010,
      Qt = 1011,
      Kt = 1012,
      $t = 1013,
      te = 1014,
      ee = 1015,
      ie = 1016,
      re = 1017,
      se = 1018,
      ne = 1019,
      ae = 1020,
      oe = 1021,
      he = 1022,
      le = 1023,
      ue = 1024,
      ce = 1025,
      pe = 1026,
      de = 1027,
      me = 1028,
      fe = 1029,
      ge = 1030,
      ye = 1031,
      xe = 1032,
      be = 1033,
      ve = 33776,
      Me = 33777,
      we = 33778,
      _e = 33779,
      Ee = 35840,
      Te = 35841,
      Se = 35842,
      Ae = 35843,
      Re = 36196,
      Le = 37492,
      Fe = 37496,
      ze = 37808,
      Pe = 37809,
      Ne = 37810,
      Ue = 37811,
      Be = 37812,
      Ce = 37813,
      Oe = 37814,
      De = 37815,
      Ie = 37816,
      ke = 37817,
      Ge = 37818,
      We = 37819,
      Ve = 37820,
      He = 37821,
      Xe = 36492,
      je = 37840,
      qe = 37841,
      Ye = 37842,
      Ze = 37843,
      Je = 37844,
      Qe = 37845,
      Ke = 37846,
      $e = 37847,
      ti = 37848,
      ei = 37849,
      ii = 37850,
      ri = 37851,
      si = 37852,
      ni = 37853,
      ai = 3e3,
      oi = 3200,
      hi = 3201,
      li = 0,
      ui = 1,
      ci = 7680,
      pi = 519,
      di = 35044;
    class mi {
      constructor(t = 0, e = 0) {
        Object.defineProperty(this, "isVector2", { value: !0 }),
          (this.x = t),
          (this.y = e);
      }
      get width() {
        return this.x;
      }
      set width(t) {
        this.x = t;
      }
      get height() {
        return this.y;
      }
      set height(t) {
        this.y = t;
      }
      set(t, e) {
        return (this.x = t), (this.y = e), this;
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(t) {
        return (this.x = t.x), (this.y = t.y), this;
      }
      add(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), this);
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), this;
      }
      addVectors(t, e) {
        return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
      }
      addScaledVector(t, e) {
        return (this.x += t.x * e), (this.y += t.y * e), this;
      }
      sub(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), this);
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), this;
      }
      subVectors(t, e) {
        return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
      }
      multiply(t) {
        return (this.x *= t.x), (this.y *= t.y), this;
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), this;
      }
      divide(t) {
        return (this.x /= t.x), (this.y /= t.y), this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      applyMatrix3(t) {
        const e = this.x,
          i = this.y,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[3] * i + r[6]),
          (this.y = r[1] * e + r[4] * i + r[7]),
          this
        );
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          this
        );
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(t, Math.min(e, i)),
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      }
      round() {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y;
      }
      cross(t) {
        return this.x * t.y - this.y * t.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x,
          i = this.y - t.y;
        return e * e + i * i;
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
        );
      }
      lerpVectors(t, e, i) {
        return (
          (this.x = t.x + (e.x - t.x) * i),
          (this.y = t.y + (e.y - t.y) * i),
          this
        );
      }
      equals(t) {
        return t.x === this.x && t.y === this.y;
      }
      fromArray(t, e = 0) {
        return (this.x = t[e]), (this.y = t[e + 1]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.x), (t[e + 1] = this.y), t;
      }
      fromBufferAttribute(t, e, i) {
        return (
          void 0 !== i &&
            console.warn(
              "THREE.Vector2: offset has been removed from .fromBufferAttribute().",
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          this
        );
      }
      rotateAround(t, e) {
        const i = Math.cos(e),
          r = Math.sin(e),
          s = this.x - t.x,
          n = this.y - t.y;
        return (
          (this.x = s * i - n * r + t.x), (this.y = s * r + n * i + t.y), this
        );
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
      }
    }
    let fi;
    const gi = function (t) {
      if (/^data:/i.test(t.src)) return t.src;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      let e;
      if (t instanceof HTMLCanvasElement) e = t;
      else {
        void 0 === fi &&
          (fi = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "canvas",
          )),
          (fi.width = t.width),
          (fi.height = t.height);
        const i = fi.getContext("2d");
        t instanceof ImageData
          ? i.putImageData(t, 0, 0)
          : i.drawImage(t, 0, 0, t.width, t.height),
          (e = fi);
      }
      return e.width > 2048 || e.height > 2048
        ? e.toDataURL("image/jpeg", 0.6)
        : e.toDataURL("image/png");
    };
    let yi = 0;
    function xi(t, e, i, r, s, n, o, h, l, u) {
      Object.defineProperty(this, "id", { value: yi++ }),
        (this.uuid = a.generateUUID()),
        (this.name = ""),
        (this.image = void 0 !== t ? t : xi.DEFAULT_IMAGE),
        (this.mipmaps = []),
        (this.mapping = void 0 !== e ? e : xi.DEFAULT_MAPPING),
        (this.wrapS = void 0 !== i ? i : Gt),
        (this.wrapT = void 0 !== r ? r : Gt),
        (this.magFilter = void 0 !== s ? s : jt),
        (this.minFilter = void 0 !== n ? n : Yt),
        (this.anisotropy = void 0 !== l ? l : 1),
        (this.format = void 0 !== o ? o : le),
        (this.internalFormat = null),
        (this.type = void 0 !== h ? h : Zt),
        (this.offset = new mi(0, 0)),
        (this.repeat = new mi(1, 1)),
        (this.center = new mi(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new E()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.encoding = void 0 !== u ? u : ai),
        (this.version = 0),
        (this.onUpdate = null);
    }
    function bi(t, e, i, r, s, n, a, o, h, l, u, c) {
      xi.call(this, null, n, a, o, h, l, r, s, u, c),
        (this.image = { data: t || null, width: e || 1, height: i || 1 }),
        (this.magFilter = void 0 !== h ? h : Vt),
        (this.minFilter = void 0 !== l ? l : Vt),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1),
        (this.needsUpdate = !0);
    }
    (xi.DEFAULT_IMAGE = void 0),
      (xi.DEFAULT_MAPPING = 300),
      (xi.prototype = Object.assign(Object.create(b.prototype), {
        constructor: xi,
        isTexture: !0,
        updateMatrix: function () {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y,
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            this
          );
        },
        toJSON: function (t) {
          const e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          const i = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (void 0 !== this.image) {
            const r = this.image;
            if (
              (void 0 === r.uuid && (r.uuid = a.generateUUID()),
              !e && void 0 === t.images[r.uuid])
            ) {
              let e;
              if (Array.isArray(r)) {
                e = [];
                for (let t = 0, i = r.length; t < i; t++) e.push(gi(r[t]));
              } else e = gi(r);
              t.images[r.uuid] = { uuid: r.uuid, url: e };
            }
            i.image = r.uuid;
          }
          return e || (t.textures[this.uuid] = i), i;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
        transformUv: function (t) {
          if (300 !== this.mapping) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case kt:
                t.x = t.x - Math.floor(t.x);
                break;
              case Gt:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case Wt:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case kt:
                t.y = t.y - Math.floor(t.y);
                break;
              case Gt:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case Wt:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
            }
          return this.flipY && (t.y = 1 - t.y), t;
        },
      })),
      Object.defineProperty(xi.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      (bi.prototype = Object.create(xi.prototype)),
      (bi.prototype.constructor = bi),
      (bi.prototype.isDataTexture = !0);
    class vi {
      constructor(t, e) {
        Object.defineProperty(this, "isBox3", { value: !0 }),
          (this.min = void 0 !== t ? t : new h(1 / 0, 1 / 0, 1 / 0)),
          (this.max = void 0 !== e ? e : new h(-1 / 0, -1 / 0, -1 / 0));
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      }
      setFromArray(t) {
        let e = 1 / 0,
          i = 1 / 0,
          r = 1 / 0,
          s = -1 / 0,
          n = -1 / 0,
          a = -1 / 0;
        for (let o = 0, h = t.length; o < h; o += 3) {
          const h = t[o],
            l = t[o + 1],
            u = t[o + 2];
          h < e && (e = h),
            l < i && (i = l),
            u < r && (r = u),
            h > s && (s = h),
            l > n && (n = l),
            u > a && (a = u);
        }
        return this.min.set(e, i, r), this.max.set(s, n, a), this;
      }
      setFromBufferAttribute(t) {
        let e = 1 / 0,
          i = 1 / 0,
          r = 1 / 0,
          s = -1 / 0,
          n = -1 / 0,
          a = -1 / 0;
        for (let o = 0, h = t.count; o < h; o++) {
          const h = t.getX(o),
            l = t.getY(o),
            u = t.getZ(o);
          h < e && (e = h),
            l < i && (i = l),
            u < r && (r = u),
            h > s && (s = h),
            l > n && (n = l),
            u > a && (a = u);
        }
        return this.min.set(e, i, r), this.max.set(s, n, a), this;
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      }
      setFromCenterAndSize(t, e) {
        const i = _i.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
      }
      setFromObject(t) {
        return this.makeEmpty(), this.expandByObject(t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      }
      isEmpty() {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      }
      getCenter(t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getCenter() target is now required"),
            (t = new h())),
          this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      }
      getSize(t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getSize() target is now required"),
            (t = new h())),
          this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        );
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      }
      expandByObject(t) {
        t.updateWorldMatrix(!1, !1);
        const e = t.geometry;
        void 0 !== e &&
          (null === e.boundingBox && e.computeBoundingBox(),
          Ei.copy(e.boundingBox),
          Ei.applyMatrix4(t.matrixWorld),
          this.union(Ei));
        const i = t.children;
        for (let t = 0, e = i.length; t < e; t++) this.expandByObject(i[t]);
        return this;
      }
      containsPoint(t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y ||
          t.z < this.min.z ||
          t.z > this.max.z
        );
      }
      containsBox(t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y &&
          this.min.z <= t.min.z &&
          t.max.z <= this.max.z
        );
      }
      getParameter(t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .getParameter() target is now required"),
            (e = new h())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z),
          )
        );
      }
      intersectsBox(t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y ||
          t.max.z < this.min.z ||
          t.min.z > this.max.z
        );
      }
      intersectsSphere(t) {
        return (
          this.clampPoint(t.center, _i),
          _i.distanceToSquared(t.center) <= t.radius * t.radius
        );
      }
      intersectsPlane(t) {
        let e, i;
        return (
          t.normal.x > 0
            ? ((e = t.normal.x * this.min.x), (i = t.normal.x * this.max.x))
            : ((e = t.normal.x * this.max.x), (i = t.normal.x * this.min.x)),
          t.normal.y > 0
            ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y))
            : ((e += t.normal.y * this.max.y), (i += t.normal.y * this.min.y)),
          t.normal.z > 0
            ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z))
            : ((e += t.normal.z * this.max.z), (i += t.normal.z * this.min.z)),
          e <= -t.constant && i >= -t.constant
        );
      }
      intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(zi),
          Pi.subVectors(this.max, zi),
          Ti.subVectors(t.a, zi),
          Si.subVectors(t.b, zi),
          Ai.subVectors(t.c, zi),
          Ri.subVectors(Si, Ti),
          Li.subVectors(Ai, Si),
          Fi.subVectors(Ti, Ai);
        let e = [
          0,
          -Ri.z,
          Ri.y,
          0,
          -Li.z,
          Li.y,
          0,
          -Fi.z,
          Fi.y,
          Ri.z,
          0,
          -Ri.x,
          Li.z,
          0,
          -Li.x,
          Fi.z,
          0,
          -Fi.x,
          -Ri.y,
          Ri.x,
          0,
          -Li.y,
          Li.x,
          0,
          -Fi.y,
          Fi.x,
          0,
        ];
        return (
          !!Mi(e, Ti, Si, Ai, Pi) &&
          !!Mi((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), Ti, Si, Ai, Pi) &&
          (Ni.crossVectors(Ri, Li),
          Mi((e = [Ni.x, Ni.y, Ni.z]), Ti, Si, Ai, Pi))
        );
      }
      clampPoint(t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .clampPoint() target is now required"),
            (e = new h())),
          e.copy(t).clamp(this.min, this.max)
        );
      }
      distanceToPoint(t) {
        return _i.copy(t).clamp(this.min, this.max).sub(t).length();
      }
      getBoundingSphere(t) {
        return (
          void 0 === t &&
            console.error(
              "THREE.Box3: .getBoundingSphere() target is now required",
            ),
          this.getCenter(t.center),
          (t.radius = 0.5 * this.getSize(_i).length()),
          t
        );
      }
      intersect(t) {
        return (
          this.min.max(t.min),
          this.max.min(t.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      }
      applyMatrix4(t) {
        return this.isEmpty()
          ? this
          : (wi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            wi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            wi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            wi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            wi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            wi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            wi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            wi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(wi),
            this);
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this;
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }
    function Mi(t, e, i, r, s) {
      for (let n = 0, a = t.length - 3; n <= a; n += 3) {
        Ui.fromArray(t, n);
        const a =
            s.x * Math.abs(Ui.x) + s.y * Math.abs(Ui.y) + s.z * Math.abs(Ui.z),
          o = e.dot(Ui),
          h = i.dot(Ui),
          l = r.dot(Ui);
        if (Math.max(-Math.max(o, h, l), Math.min(o, h, l)) > a) return !1;
      }
      return !0;
    }
    const wi = [
        new h(),
        new h(),
        new h(),
        new h(),
        new h(),
        new h(),
        new h(),
        new h(),
      ],
      _i = new h(),
      Ei = new vi(),
      Ti = new h(),
      Si = new h(),
      Ai = new h(),
      Ri = new h(),
      Li = new h(),
      Fi = new h(),
      zi = new h(),
      Pi = new h(),
      Ni = new h(),
      Ui = new h(),
      Bi = new vi();
    class Ci {
      constructor(t, e) {
        (this.center = void 0 !== t ? t : new h()),
          (this.radius = void 0 !== e ? e : -1);
      }
      set(t, e) {
        return this.center.copy(t), (this.radius = e), this;
      }
      setFromPoints(t, e) {
        const i = this.center;
        void 0 !== e ? i.copy(e) : Bi.setFromPoints(t).getCenter(i);
        let r = 0;
        for (let e = 0, s = t.length; e < s; e++)
          r = Math.max(r, i.distanceToSquared(t[e]));
        return (this.radius = Math.sqrt(r)), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.center.copy(t.center), (this.radius = t.radius), this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      }
      containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      }
      intersectsBox(t) {
        return t.intersectsSphere(this);
      }
      intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(t, e) {
        const i = this.center.distanceToSquared(t);
        return (
          void 0 === e &&
            (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            (e = new h())),
          e.copy(t),
          i > this.radius * this.radius &&
            (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
          e
        );
      }
      getBoundingBox(t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Sphere: .getBoundingBox() target is now required",
            ),
            (t = new vi())),
          this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t)
        );
      }
      applyMatrix4(t) {
        return (
          this.center.applyMatrix4(t),
          (this.radius = this.radius * t.getMaxScaleOnAxis()),
          this
        );
      }
      translate(t) {
        return this.center.add(t), this;
      }
      equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      }
    }
    const Oi = new h(),
      Di = new h(),
      Ii = new E();
    class ki {
      constructor(t, e) {
        Object.defineProperty(this, "isPlane", { value: !0 }),
          (this.normal = void 0 !== t ? t : new h(1, 0, 0)),
          (this.constant = void 0 !== e ? e : 0);
      }
      set(t, e) {
        return this.normal.copy(t), (this.constant = e), this;
      }
      setComponents(t, e, i, r) {
        return this.normal.set(t, e, i), (this.constant = r), this;
      }
      setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
      }
      setFromCoplanarPoints(t, e, i) {
        const r = Oi.subVectors(i, e).cross(Di.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, t), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.normal.copy(t.normal), (this.constant = t.constant), this;
      }
      normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), (this.constant *= t), this;
      }
      negate() {
        return (this.constant *= -1), this.normal.negate(), this;
      }
      distanceToPoint(t) {
        return this.normal.dot(t) + this.constant;
      }
      distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius;
      }
      projectPoint(t, e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Plane: .projectPoint() target is now required",
            ),
            (e = new h())),
          e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        );
      }
      intersectLine(t, e) {
        void 0 === e &&
          (console.warn("THREE.Plane: .intersectLine() target is now required"),
          (e = new h()));
        const i = t.delta(Oi),
          r = this.normal.dot(i);
        if (0 === r)
          return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
        const s = -(t.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1
          ? void 0
          : e.copy(i).multiplyScalar(s).add(t.start);
      }
      intersectsLine(t) {
        const e = this.distanceToPoint(t.start),
          i = this.distanceToPoint(t.end);
        return (e < 0 && i > 0) || (i < 0 && e > 0);
      }
      intersectsBox(t) {
        return t.intersectsPlane(this);
      }
      intersectsSphere(t) {
        return t.intersectsPlane(this);
      }
      coplanarPoint(t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .coplanarPoint() target is now required",
            ),
            (t = new h())),
          t.copy(this.normal).multiplyScalar(-this.constant)
        );
      }
      applyMatrix4(t, e) {
        const i = e || Ii.getNormalMatrix(t),
          r = this.coplanarPoint(Oi).applyMatrix4(t),
          s = this.normal.applyMatrix3(i).normalize();
        return (this.constant = -r.dot(s)), this;
      }
      translate(t) {
        return (this.constant -= t.dot(this.normal)), this;
      }
      equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      }
    }
    const Gi = new Ci(),
      Wi = new h();
    class Vi {
      constructor(t, e, i, r, s, n) {
        this.planes = [
          void 0 !== t ? t : new ki(),
          void 0 !== e ? e : new ki(),
          void 0 !== i ? i : new ki(),
          void 0 !== r ? r : new ki(),
          void 0 !== s ? s : new ki(),
          void 0 !== n ? n : new ki(),
        ];
      }
      set(t, e, i, r, s, n) {
        const a = this.planes;
        return (
          a[0].copy(t),
          a[1].copy(e),
          a[2].copy(i),
          a[3].copy(r),
          a[4].copy(s),
          a[5].copy(n),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
        return this;
      }
      setFromProjectionMatrix(t) {
        const e = this.planes,
          i = t.elements,
          r = i[0],
          s = i[1],
          n = i[2],
          a = i[3],
          o = i[4],
          h = i[5],
          l = i[6],
          u = i[7],
          c = i[8],
          p = i[9],
          d = i[10],
          m = i[11],
          f = i[12],
          g = i[13],
          y = i[14],
          x = i[15];
        return (
          e[0].setComponents(a - r, u - o, m - c, x - f).normalize(),
          e[1].setComponents(a + r, u + o, m + c, x + f).normalize(),
          e[2].setComponents(a + s, u + h, m + p, x + g).normalize(),
          e[3].setComponents(a - s, u - h, m - p, x - g).normalize(),
          e[4].setComponents(a - n, u - l, m - d, x - y).normalize(),
          e[5].setComponents(a + n, u + l, m + d, x + y).normalize(),
          this
        );
      }
      intersectsObject(t) {
        const e = t.geometry;
        return (
          null === e.boundingSphere && e.computeBoundingSphere(),
          Gi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
          this.intersectsSphere(Gi)
        );
      }
      intersectsSprite(t) {
        return (
          Gi.center.set(0, 0, 0),
          (Gi.radius = 0.7071067811865476),
          Gi.applyMatrix4(t.matrixWorld),
          this.intersectsSphere(Gi)
        );
      }
      intersectsSphere(t) {
        const e = this.planes,
          i = t.center,
          r = -t.radius;
        for (let t = 0; t < 6; t++) {
          if (e[t].distanceToPoint(i) < r) return !1;
        }
        return !0;
      }
      intersectsBox(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) {
          const r = e[i];
          if (
            ((Wi.x = r.normal.x > 0 ? t.max.x : t.min.x),
            (Wi.y = r.normal.y > 0 ? t.max.y : t.min.y),
            (Wi.z = r.normal.z > 0 ? t.max.z : t.min.z),
            r.distanceToPoint(Wi) < 0)
          )
            return !1;
        }
        return !0;
      }
      containsPoint(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return !1;
        return !0;
      }
    }
    class Hi {
      constructor(t = 0, e = 0, i = 0, r = 1) {
        Object.defineProperty(this, "isVector4", { value: !0 }),
          (this.x = t),
          (this.y = e),
          (this.z = i),
          (this.w = r);
      }
      get width() {
        return this.z;
      }
      set width(t) {
        this.z = t;
      }
      get height() {
        return this.w;
      }
      set height(t) {
        this.w = t;
      }
      set(t, e, i, r) {
        return (this.x = t), (this.y = e), (this.z = i), (this.w = r), this;
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setZ(t) {
        return (this.z = t), this;
      }
      setW(t) {
        return (this.w = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(t) {
        return (
          (this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.w = void 0 !== t.w ? t.w : 1),
          this
        );
      }
      add(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
            ),
            this.addVectors(t, e))
          : ((this.x += t.x),
            (this.y += t.y),
            (this.z += t.z),
            (this.w += t.w),
            this);
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
      }
      addVectors(t, e) {
        return (
          (this.x = t.x + e.x),
          (this.y = t.y + e.y),
          (this.z = t.z + e.z),
          (this.w = t.w + e.w),
          this
        );
      }
      addScaledVector(t, e) {
        return (
          (this.x += t.x * e),
          (this.y += t.y * e),
          (this.z += t.z * e),
          (this.w += t.w * e),
          this
        );
      }
      sub(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x),
            (this.y -= t.y),
            (this.z -= t.z),
            (this.w -= t.w),
            this);
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
      }
      subVectors(t, e) {
        return (
          (this.x = t.x - e.x),
          (this.y = t.y - e.y),
          (this.z = t.z - e.z),
          (this.w = t.w - e.w),
          this
        );
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
      }
      applyMatrix4(t) {
        const e = this.x,
          i = this.y,
          r = this.z,
          s = this.w,
          n = t.elements;
        return (
          (this.x = n[0] * e + n[4] * i + n[8] * r + n[12] * s),
          (this.y = n[1] * e + n[5] * i + n[9] * r + n[13] * s),
          (this.z = n[2] * e + n[6] * i + n[10] * r + n[14] * s),
          (this.w = n[3] * e + n[7] * i + n[11] * r + n[15] * s),
          this
        );
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return (
          e < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
          this
        );
      }
      setAxisAngleFromRotationMatrix(t) {
        let e, i, r, s;
        const n = t.elements,
          a = n[0],
          o = n[4],
          h = n[8],
          l = n[1],
          u = n[5],
          c = n[9],
          p = n[2],
          d = n[6],
          m = n[10];
        if (
          Math.abs(o - l) < 0.01 &&
          Math.abs(h - p) < 0.01 &&
          Math.abs(c - d) < 0.01
        ) {
          if (
            Math.abs(o + l) < 0.1 &&
            Math.abs(h + p) < 0.1 &&
            Math.abs(c + d) < 0.1 &&
            Math.abs(a + u + m - 3) < 0.1
          )
            return this.set(1, 0, 0, 0), this;
          e = Math.PI;
          const t = (a + 1) / 2,
            n = (u + 1) / 2,
            f = (m + 1) / 2,
            g = (o + l) / 4,
            y = (h + p) / 4,
            x = (c + d) / 4;
          return (
            t > n && t > f
              ? t < 0.01
                ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
                : ((r = g / (i = Math.sqrt(t))), (s = y / i))
              : n > f
              ? n < 0.01
                ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
                : ((i = g / (r = Math.sqrt(n))), (s = x / r))
              : f < 0.01
              ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
              : ((i = y / (s = Math.sqrt(f))), (r = x / s)),
            this.set(i, r, s, e),
            this
          );
        }
        let f = Math.sqrt(
          (d - c) * (d - c) + (h - p) * (h - p) + (l - o) * (l - o),
        );
        return (
          Math.abs(f) < 0.001 && (f = 1),
          (this.x = (d - c) / f),
          (this.y = (h - p) / f),
          (this.z = (l - o) / f),
          (this.w = Math.acos((a + u + m - 1) / 2)),
          this
        );
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          (this.w = Math.min(this.w, t.w)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          (this.w = Math.max(this.w, t.w)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          (this.w = Math.max(t.w, Math.min(e.w, this.w))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          (this.w = Math.max(t, Math.min(e, this.w))),
          this
        );
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(t, Math.min(e, i)),
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      }
      negate() {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
      }
      lengthSq() {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      length() {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
        );
      }
      manhattanLength() {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          (this.w += (t.w - this.w) * e),
          this
        );
      }
      lerpVectors(t, e, i) {
        return (
          (this.x = t.x + (e.x - t.x) * i),
          (this.y = t.y + (e.y - t.y) * i),
          (this.z = t.z + (e.z - t.z) * i),
          (this.w = t.w + (e.w - t.w) * i),
          this
        );
      }
      equals(t) {
        return (
          t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        );
      }
      fromArray(t, e = 0) {
        return (
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          (this.w = t[e + 3]),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          (t[e + 3] = this.w),
          t
        );
      }
      fromBufferAttribute(t, e, i) {
        return (
          void 0 !== i &&
            console.warn(
              "THREE.Vector4: offset has been removed from .fromBufferAttribute().",
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          (this.w = t.getW(e)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          (this.w = Math.random()),
          this
        );
      }
    }
    function Xi() {
      let t = null,
        e = !1,
        i = null,
        r = null;
      function s(e, n) {
        i(e, n), (r = t.requestAnimationFrame(s));
      }
      return {
        start: function () {
          !0 !== e &&
            null !== i &&
            ((r = t.requestAnimationFrame(s)), (e = !0));
        },
        stop: function () {
          t.cancelAnimationFrame(r), (e = !1);
        },
        setAnimationLoop: function (t) {
          i = t;
        },
        setContext: function (e) {
          t = e;
        },
      };
    }
    function ji(t, e) {
      const i = e.isWebGL2,
        r = new WeakMap();
      return {
        get: function (t) {
          return t.isInterleavedBufferAttribute && (t = t.data), r.get(t);
        },
        remove: function (e) {
          e.isInterleavedBufferAttribute && (e = e.data);
          const i = r.get(e);
          i && (t.deleteBuffer(i.buffer), r.delete(e));
        },
        update: function (e, s) {
          if (e.isGLBufferAttribute) {
            var n = r.get(e);
            return void (
              (!n || n.version < e.version) &&
              r.set(e, {
                buffer: e.buffer,
                type: e.type,
                bytesPerElement: e.elementSize,
                version: e.version,
              })
            );
          }
          e.isInterleavedBufferAttribute && (e = e.data);
          const a = r.get(e);
          void 0 === a
            ? r.set(
                e,
                (function (e, i) {
                  const r = e.array,
                    s = e.usage,
                    n = t.createBuffer();
                  t.bindBuffer(i, n),
                    t.bufferData(i, r, s),
                    e.onUploadCallback();
                  let a = t.FLOAT;
                  return (
                    r instanceof Float32Array
                      ? (a = t.FLOAT)
                      : r instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.",
                        )
                      : r instanceof Uint16Array
                      ? (a = t.UNSIGNED_SHORT)
                      : r instanceof Int16Array
                      ? (a = t.SHORT)
                      : r instanceof Uint32Array
                      ? (a = t.UNSIGNED_INT)
                      : r instanceof Int32Array
                      ? (a = t.INT)
                      : r instanceof Int8Array
                      ? (a = t.BYTE)
                      : r instanceof Uint8Array && (a = t.UNSIGNED_BYTE),
                    {
                      buffer: n,
                      type: a,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: e.version,
                    }
                  );
                })(e, s),
              )
            : a.version < e.version &&
              ((function (e, r, s) {
                const n = r.array,
                  a = r.updateRange;
                t.bindBuffer(s, e),
                  -1 === a.count
                    ? t.bufferSubData(s, 0, n)
                    : (i
                        ? t.bufferSubData(
                            s,
                            a.offset * n.BYTES_PER_ELEMENT,
                            n,
                            a.offset,
                            a.count,
                          )
                        : t.bufferSubData(
                            s,
                            a.offset * n.BYTES_PER_ELEMENT,
                            n.subarray(a.offset, a.offset + a.count),
                          ),
                      (a.count = -1));
              })(a.buffer, e, s),
              (a.version = e.version));
        },
      };
    }
    const qi = new h(),
      Yi = new mi();
    function Zi(t, e, i) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array.",
        );
      (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = !0 === i),
        (this.usage = di),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    function Ji(t, e, i) {
      Zi.call(this, new Int8Array(t), e, i);
    }
    function Qi(t, e, i) {
      Zi.call(this, new Uint8Array(t), e, i);
    }
    function Ki(t, e, i) {
      Zi.call(this, new Uint8ClampedArray(t), e, i);
    }
    function $i(t, e, i) {
      Zi.call(this, new Int16Array(t), e, i);
    }
    function tr(t, e, i) {
      Zi.call(this, new Uint16Array(t), e, i);
    }
    function er(t, e, i) {
      Zi.call(this, new Int32Array(t), e, i);
    }
    function ir(t, e, i) {
      Zi.call(this, new Uint32Array(t), e, i);
    }
    function rr(t, e, i) {
      Zi.call(this, new Float32Array(t), e, i);
    }
    function sr(t, e, i) {
      Zi.call(this, new Float64Array(t), e, i);
    }
    Object.defineProperty(Zi.prototype, "needsUpdate", {
      set: function (t) {
        !0 === t && this.version++;
      },
    }),
      Object.assign(Zi.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function () {},
        setUsage: function (t) {
          return (this.usage = t), this;
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            this
          );
        },
        copyAt: function (t, e, i) {
          (t *= this.itemSize), (i *= e.itemSize);
          for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[t + r] = e.array[i + r];
          return this;
        },
        copyArray: function (t) {
          return this.array.set(t), this;
        },
        copyColorsArray: function (t) {
          const e = this.array;
          let i = 0;
          for (let r = 0, s = t.length; r < s; r++) {
            let s = t[r];
            void 0 === s &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                r,
              ),
              (s = new q())),
              (e[i++] = s.r),
              (e[i++] = s.g),
              (e[i++] = s.b);
          }
          return this;
        },
        copyVector2sArray: function (t) {
          const e = this.array;
          let i = 0;
          for (let r = 0, s = t.length; r < s; r++) {
            let s = t[r];
            void 0 === s &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                r,
              ),
              (s = new mi())),
              (e[i++] = s.x),
              (e[i++] = s.y);
          }
          return this;
        },
        copyVector3sArray: function (t) {
          const e = this.array;
          let i = 0;
          for (let r = 0, s = t.length; r < s; r++) {
            let s = t[r];
            void 0 === s &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                r,
              ),
              (s = new h())),
              (e[i++] = s.x),
              (e[i++] = s.y),
              (e[i++] = s.z);
          }
          return this;
        },
        copyVector4sArray: function (t) {
          const e = this.array;
          let i = 0;
          for (let r = 0, s = t.length; r < s; r++) {
            let s = t[r];
            void 0 === s &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                r,
              ),
              (s = new Hi())),
              (e[i++] = s.x),
              (e[i++] = s.y),
              (e[i++] = s.z),
              (e[i++] = s.w);
          }
          return this;
        },
        applyMatrix3: function (t) {
          if (2 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++)
              Yi.fromBufferAttribute(this, e),
                Yi.applyMatrix3(t),
                this.setXY(e, Yi.x, Yi.y);
          else if (3 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++)
              qi.fromBufferAttribute(this, e),
                qi.applyMatrix3(t),
                this.setXYZ(e, qi.x, qi.y, qi.z);
          return this;
        },
        applyMatrix4: function (t) {
          for (let e = 0, i = this.count; e < i; e++)
            (qi.x = this.getX(e)),
              (qi.y = this.getY(e)),
              (qi.z = this.getZ(e)),
              qi.applyMatrix4(t),
              this.setXYZ(e, qi.x, qi.y, qi.z);
          return this;
        },
        applyNormalMatrix: function (t) {
          for (let e = 0, i = this.count; e < i; e++)
            (qi.x = this.getX(e)),
              (qi.y = this.getY(e)),
              (qi.z = this.getZ(e)),
              qi.applyNormalMatrix(t),
              this.setXYZ(e, qi.x, qi.y, qi.z);
          return this;
        },
        transformDirection: function (t) {
          for (let e = 0, i = this.count; e < i; e++)
            (qi.x = this.getX(e)),
              (qi.y = this.getY(e)),
              (qi.z = this.getZ(e)),
              qi.transformDirection(t),
              this.setXYZ(e, qi.x, qi.y, qi.z);
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        getX: function (t) {
          return this.array[t * this.itemSize];
        },
        setX: function (t, e) {
          return (this.array[t * this.itemSize] = e), this;
        },
        getY: function (t) {
          return this.array[t * this.itemSize + 1];
        },
        setY: function (t, e) {
          return (this.array[t * this.itemSize + 1] = e), this;
        },
        getZ: function (t) {
          return this.array[t * this.itemSize + 2];
        },
        setZ: function (t, e) {
          return (this.array[t * this.itemSize + 2] = e), this;
        },
        getW: function (t) {
          return this.array[t * this.itemSize + 3];
        },
        setW: function (t, e) {
          return (this.array[t * this.itemSize + 3] = e), this;
        },
        setXY: function (t, e, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            this
          );
        },
        setXYZ: function (t, e, i, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            (this.array[t + 2] = r),
            this
          );
        },
        setXYZW: function (t, e, i, r, s) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            (this.array[t + 2] = r),
            (this.array[t + 3] = s),
            this
          );
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        },
        clone: function () {
          return new this.constructor(this.array, this.itemSize).copy(this);
        },
        toJSON: function () {
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
        },
      }),
      (Ji.prototype = Object.create(Zi.prototype)),
      (Ji.prototype.constructor = Ji),
      (Qi.prototype = Object.create(Zi.prototype)),
      (Qi.prototype.constructor = Qi),
      (Ki.prototype = Object.create(Zi.prototype)),
      (Ki.prototype.constructor = Ki),
      ($i.prototype = Object.create(Zi.prototype)),
      ($i.prototype.constructor = $i),
      (tr.prototype = Object.create(Zi.prototype)),
      (tr.prototype.constructor = tr),
      (er.prototype = Object.create(Zi.prototype)),
      (er.prototype.constructor = er),
      (ir.prototype = Object.create(Zi.prototype)),
      (ir.prototype.constructor = ir),
      (rr.prototype = Object.create(Zi.prototype)),
      (rr.prototype.constructor = rr),
      (sr.prototype = Object.create(Zi.prototype)),
      (sr.prototype.constructor = sr);
    class nr {
      constructor() {
        (this.vertices = []),
          (this.normals = []),
          (this.colors = []),
          (this.uvs = []),
          (this.uvs2 = []),
          (this.groups = []),
          (this.morphTargets = {}),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.verticesNeedUpdate = !1),
          (this.normalsNeedUpdate = !1),
          (this.colorsNeedUpdate = !1),
          (this.uvsNeedUpdate = !1),
          (this.groupsNeedUpdate = !1);
      }
      computeGroups(t) {
        const e = [];
        let i,
          r,
          s = void 0;
        const n = t.faces;
        for (r = 0; r < n.length; r++) {
          const t = n[r];
          t.materialIndex !== s &&
            ((s = t.materialIndex),
            void 0 !== i && ((i.count = 3 * r - i.start), e.push(i)),
            (i = { start: 3 * r, materialIndex: s }));
        }
        void 0 !== i && ((i.count = 3 * r - i.start), e.push(i)),
          (this.groups = e);
      }
      fromGeometry(t) {
        const e = t.faces,
          i = t.vertices,
          r = t.faceVertexUvs,
          s = r[0] && r[0].length > 0,
          n = r[1] && r[1].length > 0,
          a = t.morphTargets,
          o = a.length;
        let h;
        if (o > 0) {
          h = [];
          for (let t = 0; t < o; t++) h[t] = { name: a[t].name, data: [] };
          this.morphTargets.position = h;
        }
        const l = t.morphNormals,
          u = l.length;
        let c;
        if (u > 0) {
          c = [];
          for (let t = 0; t < u; t++) c[t] = { name: l[t].name, data: [] };
          this.morphTargets.normal = c;
        }
        const p = t.skinIndices,
          d = t.skinWeights,
          m = p.length === i.length,
          f = d.length === i.length;
        i.length > 0 &&
          0 === e.length &&
          console.error(
            "THREE.DirectGeometry: Faceless geometries are not supported.",
          );
        for (let t = 0; t < e.length; t++) {
          const g = e[t];
          this.vertices.push(i[g.a], i[g.b], i[g.c]);
          const y = g.vertexNormals;
          if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
          else {
            const t = g.normal;
            this.normals.push(t, t, t);
          }
          const x = g.vertexColors;
          if (3 === x.length) this.colors.push(x[0], x[1], x[2]);
          else {
            const t = g.color;
            this.colors.push(t, t, t);
          }
          if (!0 === s) {
            const e = r[0][t];
            void 0 !== e
              ? this.uvs.push(e[0], e[1], e[2])
              : (console.warn(
                  "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                  t,
                ),
                this.uvs.push(new mi(), new mi(), new mi()));
          }
          if (!0 === n) {
            const e = r[1][t];
            void 0 !== e
              ? this.uvs2.push(e[0], e[1], e[2])
              : (console.warn(
                  "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                  t,
                ),
                this.uvs2.push(new mi(), new mi(), new mi()));
          }
          for (let t = 0; t < o; t++) {
            const e = a[t].vertices;
            h[t].data.push(e[g.a], e[g.b], e[g.c]);
          }
          for (let e = 0; e < u; e++) {
            const i = l[e].vertexNormals[t];
            c[e].data.push(i.a, i.b, i.c);
          }
          m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]),
            f && this.skinWeights.push(d[g.a], d[g.b], d[g.c]);
        }
        return (
          this.computeGroups(t),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          this
        );
      }
    }
    function ar(t) {
      if (0 === t.length) return -1 / 0;
      let e = t[0];
      for (let i = 1, r = t.length; i < r; ++i) t[i] > e && (e = t[i]);
      return e;
    }
    let or = 1;
    const hr = new c(),
      lr = new D(),
      ur = new h(),
      cr = new vi(),
      pr = new vi(),
      dr = new h();
    function mr() {
      Object.defineProperty(this, "id", { value: (or += 2) }),
        (this.uuid = a.generateUUID()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    mr.prototype = Object.assign(Object.create(b.prototype), {
      constructor: mr,
      isBufferGeometry: !0,
      getIndex: function () {
        return this.index;
      },
      setIndex: function (t) {
        return (
          Array.isArray(t)
            ? (this.index = new (ar(t) > 65535 ? ir : tr)(t, 1))
            : (this.index = t),
          this
        );
      },
      getAttribute: function (t) {
        return this.attributes[t];
      },
      setAttribute: function (t, e) {
        return (this.attributes[t] = e), this;
      },
      deleteAttribute: function (t) {
        return delete this.attributes[t], this;
      },
      addGroup: function (t, e, i) {
        this.groups.push({
          start: t,
          count: e,
          materialIndex: void 0 !== i ? i : 0,
        });
      },
      clearGroups: function () {
        this.groups = [];
      },
      setDrawRange: function (t, e) {
        (this.drawRange.start = t), (this.drawRange.count = e);
      },
      applyMatrix4: function (t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
        const i = this.attributes.normal;
        if (void 0 !== i) {
          const e = new E().getNormalMatrix(t);
          i.applyNormalMatrix(e), (i.needsUpdate = !0);
        }
        const r = this.attributes.tangent;
        return (
          void 0 !== r && (r.transformDirection(t), (r.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      },
      rotateX: function (t) {
        return hr.makeRotationX(t), this.applyMatrix4(hr), this;
      },
      rotateY: function (t) {
        return hr.makeRotationY(t), this.applyMatrix4(hr), this;
      },
      rotateZ: function (t) {
        return hr.makeRotationZ(t), this.applyMatrix4(hr), this;
      },
      translate: function (t, e, i) {
        return hr.makeTranslation(t, e, i), this.applyMatrix4(hr), this;
      },
      scale: function (t, e, i) {
        return hr.makeScale(t, e, i), this.applyMatrix4(hr), this;
      },
      lookAt: function (t) {
        return (
          lr.lookAt(t), lr.updateMatrix(), this.applyMatrix4(lr.matrix), this
        );
      },
      center: function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(ur).negate(),
          this.translate(ur.x, ur.y, ur.z),
          this
        );
      },
      setFromObject: function (t) {
        const e = t.geometry;
        if (t.isPoints || t.isLine) {
          const t = new rr(3 * e.vertices.length, 3),
            i = new rr(3 * e.colors.length, 3);
          if (
            (this.setAttribute("position", t.copyVector3sArray(e.vertices)),
            this.setAttribute("color", i.copyColorsArray(e.colors)),
            e.lineDistances && e.lineDistances.length === e.vertices.length)
          ) {
            const t = new rr(e.lineDistances.length, 1);
            this.setAttribute("lineDistance", t.copyArray(e.lineDistances));
          }
          null !== e.boundingSphere &&
            (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone());
        } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
        return this;
      },
      setFromPoints: function (t) {
        const e = [];
        for (let i = 0, r = t.length; i < r; i++) {
          const r = t[i];
          e.push(r.x, r.y, r.z || 0);
        }
        return this.setAttribute("position", new rr(e, 3)), this;
      },
      updateFromObject: function (t) {
        let e = t.geometry;
        if (t.isMesh) {
          let t = e.__directGeometry;
          if (
            (!0 === e.elementsNeedUpdate &&
              ((t = void 0), (e.elementsNeedUpdate = !1)),
            void 0 === t)
          )
            return this.fromGeometry(e);
          (t.verticesNeedUpdate = e.verticesNeedUpdate),
            (t.normalsNeedUpdate = e.normalsNeedUpdate),
            (t.colorsNeedUpdate = e.colorsNeedUpdate),
            (t.uvsNeedUpdate = e.uvsNeedUpdate),
            (t.groupsNeedUpdate = e.groupsNeedUpdate),
            (e.verticesNeedUpdate = !1),
            (e.normalsNeedUpdate = !1),
            (e.colorsNeedUpdate = !1),
            (e.uvsNeedUpdate = !1),
            (e.groupsNeedUpdate = !1),
            (e = t);
        }
        if (!0 === e.verticesNeedUpdate) {
          const t = this.attributes.position;
          void 0 !== t &&
            (t.copyVector3sArray(e.vertices), (t.needsUpdate = !0)),
            (e.verticesNeedUpdate = !1);
        }
        if (!0 === e.normalsNeedUpdate) {
          const t = this.attributes.normal;
          void 0 !== t &&
            (t.copyVector3sArray(e.normals), (t.needsUpdate = !0)),
            (e.normalsNeedUpdate = !1);
        }
        if (!0 === e.colorsNeedUpdate) {
          const t = this.attributes.color;
          void 0 !== t && (t.copyColorsArray(e.colors), (t.needsUpdate = !0)),
            (e.colorsNeedUpdate = !1);
        }
        if (e.uvsNeedUpdate) {
          const t = this.attributes.uv;
          void 0 !== t && (t.copyVector2sArray(e.uvs), (t.needsUpdate = !0)),
            (e.uvsNeedUpdate = !1);
        }
        if (e.lineDistancesNeedUpdate) {
          const t = this.attributes.lineDistance;
          void 0 !== t && (t.copyArray(e.lineDistances), (t.needsUpdate = !0)),
            (e.lineDistancesNeedUpdate = !1);
        }
        return (
          e.groupsNeedUpdate &&
            (e.computeGroups(t.geometry),
            (this.groups = e.groups),
            (e.groupsNeedUpdate = !1)),
          this
        );
      },
      fromGeometry: function (t) {
        return (
          (t.__directGeometry = new nr().fromGeometry(t)),
          this.fromDirectGeometry(t.__directGeometry)
        );
      },
      fromDirectGeometry: function (t) {
        const e = new Float32Array(3 * t.vertices.length);
        if (
          (this.setAttribute(
            "position",
            new Zi(e, 3).copyVector3sArray(t.vertices),
          ),
          t.normals.length > 0)
        ) {
          const e = new Float32Array(3 * t.normals.length);
          this.setAttribute(
            "normal",
            new Zi(e, 3).copyVector3sArray(t.normals),
          );
        }
        if (t.colors.length > 0) {
          const e = new Float32Array(3 * t.colors.length);
          this.setAttribute("color", new Zi(e, 3).copyColorsArray(t.colors));
        }
        if (t.uvs.length > 0) {
          const e = new Float32Array(2 * t.uvs.length);
          this.setAttribute("uv", new Zi(e, 2).copyVector2sArray(t.uvs));
        }
        if (t.uvs2.length > 0) {
          const e = new Float32Array(2 * t.uvs2.length);
          this.setAttribute("uv2", new Zi(e, 2).copyVector2sArray(t.uvs2));
        }
        this.groups = t.groups;
        for (const e in t.morphTargets) {
          const i = [],
            r = t.morphTargets[e];
          for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t],
              s = new rr(3 * e.data.length, 3);
            (s.name = e.name), i.push(s.copyVector3sArray(e.data));
          }
          this.morphAttributes[e] = i;
        }
        if (t.skinIndices.length > 0) {
          const e = new rr(4 * t.skinIndices.length, 4);
          this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices));
        }
        if (t.skinWeights.length > 0) {
          const e = new rr(4 * t.skinWeights.length, 4);
          this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights));
        }
        return (
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          this
        );
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new vi());
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this,
            ),
            void this.boundingBox.set(
              new h(-1 / 0, -1 / 0, -1 / 0),
              new h(1 / 0, 1 / 0, 1 / 0),
            )
          );
        if (void 0 !== t) {
          if ((this.boundingBox.setFromBufferAttribute(t), e))
            for (let t = 0, i = e.length; t < i; t++) {
              const i = e[t];
              cr.setFromBufferAttribute(i),
                this.morphTargetsRelative
                  ? (dr.addVectors(this.boundingBox.min, cr.min),
                    this.boundingBox.expandByPoint(dr),
                    dr.addVectors(this.boundingBox.max, cr.max),
                    this.boundingBox.expandByPoint(dr))
                  : (this.boundingBox.expandByPoint(cr.min),
                    this.boundingBox.expandByPoint(cr.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this,
          );
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new Ci());
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this,
            ),
            void this.boundingSphere.set(new h(), 1 / 0)
          );
        if (t) {
          const i = this.boundingSphere.center;
          if ((cr.setFromBufferAttribute(t), e))
            for (let t = 0, i = e.length; t < i; t++) {
              const i = e[t];
              pr.setFromBufferAttribute(i),
                this.morphTargetsRelative
                  ? (dr.addVectors(cr.min, pr.min),
                    cr.expandByPoint(dr),
                    dr.addVectors(cr.max, pr.max),
                    cr.expandByPoint(dr))
                  : (cr.expandByPoint(pr.min), cr.expandByPoint(pr.max));
            }
          cr.getCenter(i);
          let r = 0;
          for (let e = 0, s = t.count; e < s; e++)
            dr.fromBufferAttribute(t, e),
              (r = Math.max(r, i.distanceToSquared(dr)));
          if (e)
            for (let s = 0, n = e.length; s < n; s++) {
              const n = e[s],
                a = this.morphTargetsRelative;
              for (let e = 0, s = n.count; e < s; e++)
                dr.fromBufferAttribute(n, e),
                  a && (ur.fromBufferAttribute(t, e), dr.add(ur)),
                  (r = Math.max(r, i.distanceToSquared(dr)));
            }
          (this.boundingSphere.radius = Math.sqrt(r)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this,
              );
        }
      },
      computeFaceNormals: function () {},
      computeVertexNormals: function () {
        const t = this.index,
          e = this.getAttribute("position");
        if (void 0 !== e) {
          let i = this.getAttribute("normal");
          if (void 0 === i)
            (i = new Zi(new Float32Array(3 * e.count), 3)),
              this.setAttribute("normal", i);
          else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
          const r = new h(),
            s = new h(),
            n = new h(),
            a = new h(),
            o = new h(),
            l = new h(),
            u = new h(),
            c = new h();
          if (t)
            for (let h = 0, p = t.count; h < p; h += 3) {
              const p = t.getX(h + 0),
                d = t.getX(h + 1),
                m = t.getX(h + 2);
              r.fromBufferAttribute(e, p),
                s.fromBufferAttribute(e, d),
                n.fromBufferAttribute(e, m),
                u.subVectors(n, s),
                c.subVectors(r, s),
                u.cross(c),
                a.fromBufferAttribute(i, p),
                o.fromBufferAttribute(i, d),
                l.fromBufferAttribute(i, m),
                a.add(u),
                o.add(u),
                l.add(u),
                i.setXYZ(p, a.x, a.y, a.z),
                i.setXYZ(d, o.x, o.y, o.z),
                i.setXYZ(m, l.x, l.y, l.z);
            }
          else
            for (let t = 0, a = e.count; t < a; t += 3)
              r.fromBufferAttribute(e, t + 0),
                s.fromBufferAttribute(e, t + 1),
                n.fromBufferAttribute(e, t + 2),
                u.subVectors(n, s),
                c.subVectors(r, s),
                u.cross(c),
                i.setXYZ(t + 0, u.x, u.y, u.z),
                i.setXYZ(t + 1, u.x, u.y, u.z),
                i.setXYZ(t + 2, u.x, u.y, u.z);
          this.normalizeNormals(), (i.needsUpdate = !0);
        }
      },
      merge: function (t, e) {
        if (!t || !t.isBufferGeometry)
          return void console.error(
            "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
            t,
          );
        void 0 === e &&
          ((e = 0),
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.",
          ));
        const i = this.attributes;
        for (const r in i) {
          if (void 0 === t.attributes[r]) continue;
          const s = i[r].array,
            n = t.attributes[r],
            a = n.array,
            o = n.itemSize * e,
            h = Math.min(a.length, s.length - o);
          for (let t = 0, e = o; t < h; t++, e++) s[e] = a[t];
        }
        return this;
      },
      normalizeNormals: function () {
        const t = this.attributes.normal;
        for (let e = 0, i = t.count; e < i; e++)
          dr.fromBufferAttribute(t, e),
            dr.normalize(),
            t.setXYZ(e, dr.x, dr.y, dr.z);
      },
      toNonIndexed: function () {
        function t(t, e) {
          const i = t.array,
            r = t.itemSize,
            s = t.normalized,
            n = new i.constructor(e.length * r);
          let a = 0,
            o = 0;
          for (let t = 0, s = e.length; t < s; t++) {
            a = e[t] * r;
            for (let t = 0; t < r; t++) n[o++] = i[a++];
          }
          return new Zi(n, r, s);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.",
            ),
            this
          );
        const e = new mr(),
          i = this.index.array,
          r = this.attributes;
        for (const s in r) {
          const n = t(r[s], i);
          e.setAttribute(s, n);
        }
        const s = this.morphAttributes;
        for (const r in s) {
          const n = [],
            a = s[r];
          for (let e = 0, r = a.length; e < r; e++) {
            const r = t(a[e], i);
            n.push(r);
          }
          e.morphAttributes[r] = n;
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const n = this.groups;
        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t];
          e.addGroup(i.start, i.count, i.materialIndex);
        }
        return e;
      },
      toJSON: function () {
        const t = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          Object.keys(this.userData).length > 0 && (t.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          const e = this.parameters;
          for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
          return t;
        }
        t.data = { attributes: {} };
        const e = this.index;
        null !== e &&
          (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array),
          });
        const i = this.attributes;
        for (const e in i) {
          const r = i[e],
            s = r.toJSON(t.data);
          "" !== r.name && (s.name = r.name), (t.data.attributes[e] = s);
        }
        const r = {};
        let s = !1;
        for (const e in this.morphAttributes) {
          const i = this.morphAttributes[e],
            n = [];
          for (let e = 0, r = i.length; e < r; e++) {
            const r = i[e],
              s = r.toJSON(t.data);
            "" !== r.name && (s.name = r.name), n.push(s);
          }
          n.length > 0 && ((r[e] = n), (s = !0));
        }
        s &&
          ((t.data.morphAttributes = r),
          (t.data.morphTargetsRelative = this.morphTargetsRelative));
        const n = this.groups;
        n.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(n)));
        const a = this.boundingSphere;
        return (
          null !== a &&
            (t.data.boundingSphere = {
              center: a.center.toArray(),
              radius: a.radius,
            }),
          t
        );
      },
      clone: function () {
        return new mr().copy(this);
      },
      copy: function (t) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        const e = {};
        this.name = t.name;
        const i = t.index;
        null !== i && this.setIndex(i.clone(e));
        const r = t.attributes;
        for (const t in r) {
          const i = r[t];
          this.setAttribute(t, i.clone(e));
        }
        const s = t.morphAttributes;
        for (const t in s) {
          const i = [],
            r = s[t];
          for (let t = 0, s = r.length; t < s; t++) i.push(r[t].clone(e));
          this.morphAttributes[t] = i;
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const n = t.groups;
        for (let t = 0, e = n.length; t < e; t++) {
          const e = n[t];
          this.addGroup(e.start, e.count, e.materialIndex);
        }
        const a = t.boundingBox;
        null !== a && (this.boundingBox = a.clone());
        const o = t.boundingSphere;
        return (
          null !== o && (this.boundingSphere = o.clone()),
          (this.drawRange.start = t.drawRange.start),
          (this.drawRange.count = t.drawRange.count),
          (this.userData = t.userData),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    });
    class fr extends mr {
      constructor(t = 1, e = 1, i = 1, r = 1, s = 1, n = 1) {
        super(),
          (this.type = "BoxBufferGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: n,
          });
        const a = this;
        (r = Math.floor(r)), (s = Math.floor(s)), (n = Math.floor(n));
        const o = [],
          l = [],
          u = [],
          c = [];
        let p = 0,
          d = 0;
        function m(t, e, i, r, s, n, m, f, g, y, x) {
          const b = n / g,
            v = m / y,
            M = n / 2,
            w = m / 2,
            _ = f / 2,
            E = g + 1,
            T = y + 1;
          let S = 0,
            A = 0;
          const R = new h();
          for (let n = 0; n < T; n++) {
            const a = n * v - w;
            for (let o = 0; o < E; o++) {
              const h = o * b - M;
              (R[t] = h * r),
                (R[e] = a * s),
                (R[i] = _),
                l.push(R.x, R.y, R.z),
                (R[t] = 0),
                (R[e] = 0),
                (R[i] = f > 0 ? 1 : -1),
                u.push(R.x, R.y, R.z),
                c.push(o / g),
                c.push(1 - n / y),
                (S += 1);
            }
          }
          for (let t = 0; t < y; t++)
            for (let e = 0; e < g; e++) {
              const i = p + e + E * t,
                r = p + e + E * (t + 1),
                s = p + (e + 1) + E * (t + 1),
                n = p + (e + 1) + E * t;
              o.push(i, r, n), o.push(r, s, n), (A += 6);
            }
          a.addGroup(d, A, x), (d += A), (p += S);
        }
        m("z", "y", "x", -1, -1, i, e, t, n, s, 0),
          m("z", "y", "x", 1, -1, i, e, -t, n, s, 1),
          m("x", "z", "y", 1, 1, t, i, e, r, n, 2),
          m("x", "z", "y", 1, -1, t, i, -e, r, n, 3),
          m("x", "y", "z", 1, -1, t, e, i, r, s, 4),
          m("x", "y", "z", -1, -1, t, e, -i, r, s, 5),
          this.setIndex(o),
          this.setAttribute("position", new rr(l, 3)),
          this.setAttribute("normal", new rr(u, 3)),
          this.setAttribute("uv", new rr(c, 2));
      }
    }
    class gr extends mr {
      constructor(t, e, i, r) {
        super(),
          (this.type = "PlaneBufferGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: r,
          });
        const s = (t = t || 1) / 2,
          n = (e = e || 1) / 2,
          a = Math.floor(i) || 1,
          o = Math.floor(r) || 1,
          h = a + 1,
          l = o + 1,
          u = t / a,
          c = e / o,
          p = [],
          d = [],
          m = [],
          f = [];
        for (let t = 0; t < l; t++) {
          const e = t * c - n;
          for (let i = 0; i < h; i++) {
            const r = i * u - s;
            d.push(r, -e, 0), m.push(0, 0, 1), f.push(i / a), f.push(1 - t / o);
          }
        }
        for (let t = 0; t < o; t++)
          for (let e = 0; e < a; e++) {
            const i = e + h * t,
              r = e + h * (t + 1),
              s = e + 1 + h * (t + 1),
              n = e + 1 + h * t;
            p.push(i, r, n), p.push(r, s, n);
          }
        this.setIndex(p),
          this.setAttribute("position", new rr(d, 3)),
          this.setAttribute("normal", new rr(m, 3)),
          this.setAttribute("uv", new rr(f, 2));
      }
    }
    let yr = 0;
    function xr() {
      Object.defineProperty(this, "id", { value: yr++ }),
        (this.uuid = a.generateUUID()),
        (this.name = ""),
        (this.type = "Material"),
        (this.fog = !0),
        (this.blending = rt),
        (this.side = $),
        (this.flatShading = !1),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = yt),
        (this.blendDst = xt),
        (this.blendEquation = ht),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = At),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = pi),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = ci),
        (this.stencilZFail = ci),
        (this.stencilZPass = ci),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaTest = 0),
        (this.premultipliedAlpha = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0);
    }
    function br(t) {
      const e = {};
      for (const i in t) {
        e[i] = {};
        for (const r in t[i]) {
          const s = t[i][r];
          s &&
          (s.isColor ||
            s.isMatrix3 ||
            s.isMatrix4 ||
            s.isVector2 ||
            s.isVector3 ||
            s.isVector4 ||
            s.isTexture)
            ? (e[i][r] = s.clone())
            : Array.isArray(s)
            ? (e[i][r] = s.slice())
            : (e[i][r] = s);
        }
      }
      return e;
    }
    function vr(t) {
      const e = {};
      for (let i = 0; i < t.length; i++) {
        const r = br(t[i]);
        for (const t in r) e[t] = r[t];
      }
      return e;
    }
    (xr.prototype = Object.assign(Object.create(b.prototype), {
      constructor: xr,
      isMaterial: !0,
      onBeforeCompile: function () {},
      customProgramCacheKey: function () {
        return this.onBeforeCompile.toString();
      },
      setValues: function (t) {
        if (void 0 !== t)
          for (const e in t) {
            const i = t[e];
            if (void 0 === i) {
              console.warn(
                "THREE.Material: '" + e + "' parameter is undefined.",
              );
              continue;
            }
            if ("shading" === e) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead.",
              ),
                (this.flatShading = 1 === i);
              continue;
            }
            const r = this[e];
            void 0 !== r
              ? r && r.isColor
                ? r.set(i)
                : r && r.isVector3 && i && i.isVector3
                ? r.copy(i)
                : (this[e] = i)
              : console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    e +
                    "' is not a property of this material.",
                );
          }
      },
      toJSON: function (t) {
        const e = void 0 === t || "string" == typeof t;
        e && (t = { textures: {}, images: {} });
        const i = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        function r(t) {
          const e = [];
          for (const i in t) {
            const r = t[i];
            delete r.metadata, e.push(r);
          }
          return e;
        }
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          "" !== this.name && (i.name = this.name),
          this.color && this.color.isColor && (i.color = this.color.getHex()),
          void 0 !== this.roughness && (i.roughness = this.roughness),
          void 0 !== this.metalness && (i.metalness = this.metalness),
          this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()),
          this.emissive &&
            this.emissive.isColor &&
            (i.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (i.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (i.specular = this.specular.getHex()),
          void 0 !== this.shininess && (i.shininess = this.shininess),
          void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (i.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap &&
            this.clearcoatMap.isTexture &&
            (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (i.clearcoatRoughnessMap =
              this.clearcoatRoughnessMap.toJSON(t).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
            (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (i.matcap = this.matcap.toJSON(t).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (i.alphaMap = this.alphaMap.toJSON(t).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            (i.lightMap = this.lightMap.toJSON(t).uuid),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((i.aoMap = this.aoMap.toJSON(t).uuid),
            (i.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((i.bumpMap = this.bumpMap.toJSON(t).uuid),
            (i.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((i.normalMap = this.normalMap.toJSON(t).uuid),
            (i.normalMapType = this.normalMapType),
            (i.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
            (i.displacementScale = this.displacementScale),
            (i.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (i.specularMap = this.specularMap.toJSON(t).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((i.envMap = this.envMap.toJSON(t).uuid),
            (i.reflectivity = this.reflectivity),
            (i.refractionRatio = this.refractionRatio),
            void 0 !== this.combine && (i.combine = this.combine),
            void 0 !== this.envMapIntensity &&
              (i.envMapIntensity = this.envMapIntensity)),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (i.gradientMap = this.gradientMap.toJSON(t).uuid),
          void 0 !== this.size && (i.size = this.size),
          void 0 !== this.sizeAttenuation &&
            (i.sizeAttenuation = this.sizeAttenuation),
          this.blending !== rt && (i.blending = this.blending),
          !0 === this.flatShading && (i.flatShading = this.flatShading),
          this.side !== $ && (i.side = this.side),
          this.vertexColors && (i.vertexColors = !0),
          this.opacity < 1 && (i.opacity = this.opacity),
          !0 === this.transparent && (i.transparent = this.transparent),
          (i.depthFunc = this.depthFunc),
          (i.depthTest = this.depthTest),
          (i.depthWrite = this.depthWrite),
          (i.stencilWrite = this.stencilWrite),
          (i.stencilWriteMask = this.stencilWriteMask),
          (i.stencilFunc = this.stencilFunc),
          (i.stencilRef = this.stencilRef),
          (i.stencilFuncMask = this.stencilFuncMask),
          (i.stencilFail = this.stencilFail),
          (i.stencilZFail = this.stencilZFail),
          (i.stencilZPass = this.stencilZPass),
          this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
          !0 === this.polygonOffset && (i.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (i.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (i.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth &&
            1 !== this.linewidth &&
            (i.linewidth = this.linewidth),
          void 0 !== this.dashSize && (i.dashSize = this.dashSize),
          void 0 !== this.gapSize && (i.gapSize = this.gapSize),
          void 0 !== this.scale && (i.scale = this.scale),
          !0 === this.dithering && (i.dithering = !0),
          this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
          !0 === this.premultipliedAlpha &&
            (i.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (i.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (i.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (i.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (i.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.morphTargets && (i.morphTargets = !0),
          !0 === this.morphNormals && (i.morphNormals = !0),
          !0 === this.skinning && (i.skinning = !0),
          !1 === this.visible && (i.visible = !1),
          !1 === this.toneMapped && (i.toneMapped = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (i.userData = this.userData),
          e)
        ) {
          const e = r(t.textures),
            s = r(t.images);
          e.length > 0 && (i.textures = e), s.length > 0 && (i.images = s);
        }
        return i;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        (this.name = t.name),
          (this.fog = t.fog),
          (this.blending = t.blending),
          (this.side = t.side),
          (this.flatShading = t.flatShading),
          (this.vertexColors = t.vertexColors),
          (this.opacity = t.opacity),
          (this.transparent = t.transparent),
          (this.blendSrc = t.blendSrc),
          (this.blendDst = t.blendDst),
          (this.blendEquation = t.blendEquation),
          (this.blendSrcAlpha = t.blendSrcAlpha),
          (this.blendDstAlpha = t.blendDstAlpha),
          (this.blendEquationAlpha = t.blendEquationAlpha),
          (this.depthFunc = t.depthFunc),
          (this.depthTest = t.depthTest),
          (this.depthWrite = t.depthWrite),
          (this.stencilWriteMask = t.stencilWriteMask),
          (this.stencilFunc = t.stencilFunc),
          (this.stencilRef = t.stencilRef),
          (this.stencilFuncMask = t.stencilFuncMask),
          (this.stencilFail = t.stencilFail),
          (this.stencilZFail = t.stencilZFail),
          (this.stencilZPass = t.stencilZPass),
          (this.stencilWrite = t.stencilWrite);
        const e = t.clippingPlanes;
        let i = null;
        if (null !== e) {
          const t = e.length;
          i = new Array(t);
          for (let r = 0; r !== t; ++r) i[r] = e[r].clone();
        }
        return (
          (this.clippingPlanes = i),
          (this.clipIntersection = t.clipIntersection),
          (this.clipShadows = t.clipShadows),
          (this.shadowSide = t.shadowSide),
          (this.colorWrite = t.colorWrite),
          (this.precision = t.precision),
          (this.polygonOffset = t.polygonOffset),
          (this.polygonOffsetFactor = t.polygonOffsetFactor),
          (this.polygonOffsetUnits = t.polygonOffsetUnits),
          (this.dithering = t.dithering),
          (this.alphaTest = t.alphaTest),
          (this.premultipliedAlpha = t.premultipliedAlpha),
          (this.visible = t.visible),
          (this.toneMapped = t.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    })),
      Object.defineProperty(xr.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      });
    const Mr = { clone: br, merge: vr };
    function wr(t) {
      xr.call(this),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.vertexShader = null),
        (this.fragmentShader = null),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        (this.glslVersion = null),
        void 0 !== t &&
          (void 0 !== t.attributes &&
            console.error(
              "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.",
            ),
          this.setValues(t));
    }
    (wr.prototype = Object.create(xr.prototype)),
      (wr.prototype.constructor = wr),
      (wr.prototype.isShaderMaterial = !0),
      (wr.prototype.copy = function (t) {
        return (
          xr.prototype.copy.call(this, t),
          (this.fragmentShader = t.fragmentShader),
          (this.vertexShader = t.vertexShader),
          (this.uniforms = br(t.uniforms)),
          (this.defines = Object.assign({}, t.defines)),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.lights = t.lights),
          (this.clipping = t.clipping),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          (this.extensions = Object.assign({}, t.extensions)),
          (this.glslVersion = t.glslVersion),
          this
        );
      }),
      (wr.prototype.toJSON = function (t) {
        const e = xr.prototype.toJSON.call(this, t);
        (e.glslVersion = this.glslVersion), (e.uniforms = {});
        for (const i in this.uniforms) {
          const r = this.uniforms[i].value;
          r && r.isTexture
            ? (e.uniforms[i] = { type: "t", value: r.toJSON(t).uuid })
            : r && r.isColor
            ? (e.uniforms[i] = { type: "c", value: r.getHex() })
            : r && r.isVector2
            ? (e.uniforms[i] = { type: "v2", value: r.toArray() })
            : r && r.isVector3
            ? (e.uniforms[i] = { type: "v3", value: r.toArray() })
            : r && r.isVector4
            ? (e.uniforms[i] = { type: "v4", value: r.toArray() })
            : r && r.isMatrix3
            ? (e.uniforms[i] = { type: "m3", value: r.toArray() })
            : r && r.isMatrix4
            ? (e.uniforms[i] = { type: "m4", value: r.toArray() })
            : (e.uniforms[i] = { value: r });
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
          (e.vertexShader = this.vertexShader),
          (e.fragmentShader = this.fragmentShader);
        const i = {};
        for (const t in this.extensions)
          !0 === this.extensions[t] && (i[t] = !0);
        return Object.keys(i).length > 0 && (e.extensions = i), e;
      });
    const _r = new h(),
      Er = new h(),
      Tr = new h(),
      Sr = new h(),
      Ar = new h(),
      Rr = new h(),
      Lr = new h();
    const Fr = new h(),
      zr = new h(),
      Pr = new h(),
      Nr = new h(),
      Ur = new h(),
      Br = new h(),
      Cr = new h(),
      Or = new h(),
      Dr = new h(),
      Ir = new h();
    class kr {
      constructor(t, e, i) {
        (this.a = void 0 !== t ? t : new h()),
          (this.b = void 0 !== e ? e : new h()),
          (this.c = void 0 !== i ? i : new h());
      }
      static getNormal(t, e, i, r) {
        void 0 === r &&
          (console.warn("THREE.Triangle: .getNormal() target is now required"),
          (r = new h())),
          r.subVectors(i, e),
          Fr.subVectors(t, e),
          r.cross(Fr);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
      }
      static getBarycoord(t, e, i, r, s) {
        Fr.subVectors(r, e), zr.subVectors(i, e), Pr.subVectors(t, e);
        const n = Fr.dot(Fr),
          a = Fr.dot(zr),
          o = Fr.dot(Pr),
          l = zr.dot(zr),
          u = zr.dot(Pr),
          c = n * l - a * a;
        if (
          (void 0 === s &&
            (console.warn(
              "THREE.Triangle: .getBarycoord() target is now required",
            ),
            (s = new h())),
          0 === c)
        )
          return s.set(-2, -1, -1);
        const p = 1 / c,
          d = (l * o - a * u) * p,
          m = (n * u - a * o) * p;
        return s.set(1 - d - m, m, d);
      }
      static containsPoint(t, e, i, r) {
        return (
          this.getBarycoord(t, e, i, r, Nr),
          Nr.x >= 0 && Nr.y >= 0 && Nr.x + Nr.y <= 1
        );
      }
      static getUV(t, e, i, r, s, n, a, o) {
        return (
          this.getBarycoord(t, e, i, r, Nr),
          o.set(0, 0),
          o.addScaledVector(s, Nr.x),
          o.addScaledVector(n, Nr.y),
          o.addScaledVector(a, Nr.z),
          o
        );
      }
      static isFrontFacing(t, e, i, r) {
        return (
          Fr.subVectors(i, e), zr.subVectors(t, e), Fr.cross(zr).dot(r) < 0
        );
      }
      set(t, e, i) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
      }
      setFromPointsAndIndices(t, e, i, r) {
        return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[r]), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
      }
      getArea() {
        return (
          Fr.subVectors(this.c, this.b),
          zr.subVectors(this.a, this.b),
          0.5 * Fr.cross(zr).length()
        );
      }
      getMidpoint(t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Triangle: .getMidpoint() target is now required",
            ),
            (t = new h())),
          t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3)
        );
      }
      getNormal(t) {
        return kr.getNormal(this.a, this.b, this.c, t);
      }
      getPlane(t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Triangle: .getPlane() target is now required"),
            (t = new ki())),
          t.setFromCoplanarPoints(this.a, this.b, this.c)
        );
      }
      getBarycoord(t, e) {
        return kr.getBarycoord(t, this.a, this.b, this.c, e);
      }
      getUV(t, e, i, r, s) {
        return kr.getUV(t, this.a, this.b, this.c, e, i, r, s);
      }
      containsPoint(t) {
        return kr.containsPoint(t, this.a, this.b, this.c);
      }
      isFrontFacing(t) {
        return kr.isFrontFacing(this.a, this.b, this.c, t);
      }
      intersectsBox(t) {
        return t.intersectsTriangle(this);
      }
      closestPointToPoint(t, e) {
        void 0 === e &&
          (console.warn(
            "THREE.Triangle: .closestPointToPoint() target is now required",
          ),
          (e = new h()));
        const i = this.a,
          r = this.b,
          s = this.c;
        let n, a;
        Ur.subVectors(r, i), Br.subVectors(s, i), Or.subVectors(t, i);
        const o = Ur.dot(Or),
          l = Br.dot(Or);
        if (o <= 0 && l <= 0) return e.copy(i);
        Dr.subVectors(t, r);
        const u = Ur.dot(Dr),
          c = Br.dot(Dr);
        if (u >= 0 && c <= u) return e.copy(r);
        const p = o * c - u * l;
        if (p <= 0 && o >= 0 && u <= 0)
          return (n = o / (o - u)), e.copy(i).addScaledVector(Ur, n);
        Ir.subVectors(t, s);
        const d = Ur.dot(Ir),
          m = Br.dot(Ir);
        if (m >= 0 && d <= m) return e.copy(s);
        const f = d * l - o * m;
        if (f <= 0 && l >= 0 && m <= 0)
          return (a = l / (l - m)), e.copy(i).addScaledVector(Br, a);
        const g = u * m - d * c;
        if (g <= 0 && c - u >= 0 && d - m >= 0)
          return (
            Cr.subVectors(s, r),
            (a = (c - u) / (c - u + (d - m))),
            e.copy(r).addScaledVector(Cr, a)
          );
        const y = 1 / (g + f + p);
        return (
          (n = f * y),
          (a = p * y),
          e.copy(i).addScaledVector(Ur, n).addScaledVector(Br, a)
        );
      }
      equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
      }
    }
    class Gr {
      constructor(t, e, i, r, s, n) {
        (this.a = t),
          (this.b = e),
          (this.c = i),
          (this.normal = r && r.isVector3 ? r : new h()),
          (this.vertexNormals = Array.isArray(r) ? r : []),
          (this.color = s && s.isColor ? s : new q()),
          (this.vertexColors = Array.isArray(s) ? s : []),
          (this.materialIndex = void 0 !== n ? n : 0);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        (this.a = t.a),
          (this.b = t.b),
          (this.c = t.c),
          this.normal.copy(t.normal),
          this.color.copy(t.color),
          (this.materialIndex = t.materialIndex);
        for (let e = 0, i = t.vertexNormals.length; e < i; e++)
          this.vertexNormals[e] = t.vertexNormals[e].clone();
        for (let e = 0, i = t.vertexColors.length; e < i; e++)
          this.vertexColors[e] = t.vertexColors[e].clone();
        return this;
      }
    }
    function Wr(t) {
      xr.call(this),
        (this.type = "MeshBasicMaterial"),
        (this.color = new q(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = Pt),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        this.setValues(t);
    }
    (Wr.prototype = Object.create(xr.prototype)),
      (Wr.prototype.constructor = Wr),
      (Wr.prototype.isMeshBasicMaterial = !0),
      (Wr.prototype.copy = function (t) {
        return (
          xr.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          this
        );
      });
    const Vr = new c(),
      Hr = new (class {
        constructor(t, e) {
          (this.origin = void 0 !== t ? t : new h()),
            (this.direction = void 0 !== e ? e : new h(0, 0, -1));
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          );
        }
        at(t, e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Ray: .at() target is now required"),
              (e = new h())),
            e.copy(this.direction).multiplyScalar(t).add(this.origin)
          );
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, _r)), this;
        }
        closestPointToPoint(t, e) {
          void 0 === e &&
            (console.warn(
              "THREE.Ray: .closestPointToPoint() target is now required",
            ),
            (e = new h())),
            e.subVectors(t, this.origin);
          const i = e.dot(this.direction);
          return i < 0
            ? e.copy(this.origin)
            : e.copy(this.direction).multiplyScalar(i).add(this.origin);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const e = _r.subVectors(t, this.origin).dot(this.direction);
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (_r.copy(this.direction).multiplyScalar(e).add(this.origin),
              _r.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, i, r) {
          Er.copy(t).add(e).multiplyScalar(0.5),
            Tr.copy(e).sub(t).normalize(),
            Sr.copy(this.origin).sub(Er);
          const s = 0.5 * t.distanceTo(e),
            n = -this.direction.dot(Tr),
            a = Sr.dot(this.direction),
            o = -Sr.dot(Tr),
            h = Sr.lengthSq(),
            l = Math.abs(1 - n * n);
          let u, c, p, d;
          if (l > 0)
            if (((c = n * a - o), (d = s * l), (u = n * o - a) >= 0))
              if (c >= -d)
                if (c <= d) {
                  const t = 1 / l;
                  p =
                    (u *= t) * (u + n * (c *= t) + 2 * a) +
                    c * (n * u + c + 2 * o) +
                    h;
                } else
                  (c = s),
                    (p =
                      -(u = Math.max(0, -(n * c + a))) * u +
                      c * (c + 2 * o) +
                      h);
              else
                (c = -s),
                  (p =
                    -(u = Math.max(0, -(n * c + a))) * u + c * (c + 2 * o) + h);
            else
              c <= -d
                ? (p =
                    -(u = Math.max(0, -(-n * s + a))) * u +
                    (c = u > 0 ? -s : Math.min(Math.max(-s, -o), s)) *
                      (c + 2 * o) +
                    h)
                : c <= d
                ? ((u = 0),
                  (p = (c = Math.min(Math.max(-s, -o), s)) * (c + 2 * o) + h))
                : (p =
                    -(u = Math.max(0, -(n * s + a))) * u +
                    (c = u > 0 ? s : Math.min(Math.max(-s, -o), s)) *
                      (c + 2 * o) +
                    h);
          else
            (c = n > 0 ? -s : s),
              (p = -(u = Math.max(0, -(n * c + a))) * u + c * (c + 2 * o) + h);
          return (
            i && i.copy(this.direction).multiplyScalar(u).add(this.origin),
            r && r.copy(Tr).multiplyScalar(c).add(Er),
            p
          );
        }
        intersectSphere(t, e) {
          _r.subVectors(t.center, this.origin);
          const i = _r.dot(this.direction),
            r = _r.dot(_r) - i * i,
            s = t.radius * t.radius;
          if (r > s) return null;
          const n = Math.sqrt(s - r),
            a = i - n,
            o = i + n;
          return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction);
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
          const i = -(this.origin.dot(t.normal) + t.constant) / e;
          return i >= 0 ? i : null;
        }
        intersectPlane(t, e) {
          const i = this.distanceToPlane(t);
          return null === i ? null : this.at(i, e);
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin);
          return 0 === e || t.normal.dot(this.direction) * e < 0;
        }
        intersectBox(t, e) {
          let i, r, s, n, a, o;
          const h = 1 / this.direction.x,
            l = 1 / this.direction.y,
            u = 1 / this.direction.z,
            c = this.origin;
          return (
            h >= 0
              ? ((i = (t.min.x - c.x) * h), (r = (t.max.x - c.x) * h))
              : ((i = (t.max.x - c.x) * h), (r = (t.min.x - c.x) * h)),
            l >= 0
              ? ((s = (t.min.y - c.y) * l), (n = (t.max.y - c.y) * l))
              : ((s = (t.max.y - c.y) * l), (n = (t.min.y - c.y) * l)),
            i > n || s > r
              ? null
              : ((s > i || i != i) && (i = s),
                (n < r || r != r) && (r = n),
                u >= 0
                  ? ((a = (t.min.z - c.z) * u), (o = (t.max.z - c.z) * u))
                  : ((a = (t.max.z - c.z) * u), (o = (t.min.z - c.z) * u)),
                i > o || a > r
                  ? null
                  : ((a > i || i != i) && (i = a),
                    (o < r || r != r) && (r = o),
                    r < 0 ? null : this.at(i >= 0 ? i : r, e)))
          );
        }
        intersectsBox(t) {
          return null !== this.intersectBox(t, _r);
        }
        intersectTriangle(t, e, i, r, s) {
          Ar.subVectors(e, t), Rr.subVectors(i, t), Lr.crossVectors(Ar, Rr);
          let n,
            a = this.direction.dot(Lr);
          if (a > 0) {
            if (r) return null;
            n = 1;
          } else {
            if (!(a < 0)) return null;
            (n = -1), (a = -a);
          }
          Sr.subVectors(this.origin, t);
          const o = n * this.direction.dot(Rr.crossVectors(Sr, Rr));
          if (o < 0) return null;
          const h = n * this.direction.dot(Ar.cross(Sr));
          if (h < 0) return null;
          if (o + h > a) return null;
          const l = -n * Sr.dot(Lr);
          return l < 0 ? null : this.at(l / a, s);
        }
        applyMatrix4(t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          );
        }
        equals(t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          );
        }
      })(),
      Xr = new Ci(),
      jr = new h(),
      qr = new h(),
      Yr = new h(),
      Zr = new h(),
      Jr = new h(),
      Qr = new h(),
      Kr = new h(),
      $r = new h(),
      ts = new h(),
      es = new mi(),
      is = new mi(),
      rs = new mi(),
      ss = new h(),
      ns = new h();
    function as(t, e) {
      D.call(this),
        (this.type = "Mesh"),
        (this.geometry = void 0 !== t ? t : new mr()),
        (this.material = void 0 !== e ? e : new Wr()),
        this.updateMorphTargets();
    }
    function os(t, e, i, r, s, n, a, o) {
      let h;
      if (
        null ===
        (h =
          e.side === tt
            ? r.intersectTriangle(a, n, s, !0, o)
            : r.intersectTriangle(s, n, a, e.side !== et, o))
      )
        return null;
      ns.copy(o), ns.applyMatrix4(t.matrixWorld);
      const l = i.ray.origin.distanceTo(ns);
      return l < i.near || l > i.far
        ? null
        : { distance: l, point: ns.clone(), object: t };
    }
    function hs(t, e, i, r, s, n, a, o, h, l, u, c) {
      jr.fromBufferAttribute(s, l),
        qr.fromBufferAttribute(s, u),
        Yr.fromBufferAttribute(s, c);
      const p = t.morphTargetInfluences;
      if (e.morphTargets && n && p) {
        Kr.set(0, 0, 0), $r.set(0, 0, 0), ts.set(0, 0, 0);
        for (let t = 0, e = n.length; t < e; t++) {
          const e = p[t],
            i = n[t];
          0 !== e &&
            (Zr.fromBufferAttribute(i, l),
            Jr.fromBufferAttribute(i, u),
            Qr.fromBufferAttribute(i, c),
            a
              ? (Kr.addScaledVector(Zr, e),
                $r.addScaledVector(Jr, e),
                ts.addScaledVector(Qr, e))
              : (Kr.addScaledVector(Zr.sub(jr), e),
                $r.addScaledVector(Jr.sub(qr), e),
                ts.addScaledVector(Qr.sub(Yr), e)));
        }
        jr.add(Kr), qr.add($r), Yr.add(ts);
      }
      t.isSkinnedMesh &&
        (t.boneTransform(l, jr),
        t.boneTransform(u, qr),
        t.boneTransform(c, Yr));
      const d = os(t, e, i, r, jr, qr, Yr, ss);
      if (d) {
        o &&
          (es.fromBufferAttribute(o, l),
          is.fromBufferAttribute(o, u),
          rs.fromBufferAttribute(o, c),
          (d.uv = kr.getUV(ss, jr, qr, Yr, es, is, rs, new mi()))),
          h &&
            (es.fromBufferAttribute(h, l),
            is.fromBufferAttribute(h, u),
            rs.fromBufferAttribute(h, c),
            (d.uv2 = kr.getUV(ss, jr, qr, Yr, es, is, rs, new mi())));
        const t = new Gr(l, u, c);
        kr.getNormal(jr, qr, Yr, t.normal), (d.face = t);
      }
      return d;
    }
    as.prototype = Object.assign(Object.create(D.prototype), {
      constructor: as,
      isMesh: !0,
      copy: function (t) {
        return (
          D.prototype.copy.call(this, t),
          void 0 !== t.morphTargetInfluences &&
            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
          void 0 !== t.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              t.morphTargetDictionary,
            )),
          (this.material = t.material),
          (this.geometry = t.geometry),
          this
        );
      },
      updateMorphTargets: function () {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            i = Object.keys(e);
          if (i.length > 0) {
            const t = e[i[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[i] = e);
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e &&
            e.length > 0 &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.",
            );
        }
      },
      raycast: function (t, e) {
        const i = this.geometry,
          r = this.material,
          s = this.matrixWorld;
        if (void 0 === r) return;
        if (
          (null === i.boundingSphere && i.computeBoundingSphere(),
          Xr.copy(i.boundingSphere),
          Xr.applyMatrix4(s),
          !1 === t.ray.intersectsSphere(Xr))
        )
          return;
        if (
          (Vr.getInverse(s),
          Hr.copy(t.ray).applyMatrix4(Vr),
          null !== i.boundingBox && !1 === Hr.intersectsBox(i.boundingBox))
        )
          return;
        let n;
        if (i.isBufferGeometry) {
          const s = i.index,
            a = i.attributes.position,
            o = i.morphAttributes.position,
            h = i.morphTargetsRelative,
            l = i.attributes.uv,
            u = i.attributes.uv2,
            c = i.groups,
            p = i.drawRange;
          if (null !== s)
            if (Array.isArray(r))
              for (let i = 0, d = c.length; i < d; i++) {
                const d = c[i],
                  m = r[d.materialIndex];
                for (
                  let i = Math.max(d.start, p.start),
                    r = Math.min(d.start + d.count, p.start + p.count);
                  i < r;
                  i += 3
                ) {
                  const r = s.getX(i),
                    c = s.getX(i + 1),
                    p = s.getX(i + 2);
                  (n = hs(this, m, t, Hr, a, o, h, l, u, r, c, p)) &&
                    ((n.faceIndex = Math.floor(i / 3)),
                    (n.face.materialIndex = d.materialIndex),
                    e.push(n));
                }
              }
            else {
              for (
                let i = Math.max(0, p.start),
                  c = Math.min(s.count, p.start + p.count);
                i < c;
                i += 3
              ) {
                const c = s.getX(i),
                  p = s.getX(i + 1),
                  d = s.getX(i + 2);
                (n = hs(this, r, t, Hr, a, o, h, l, u, c, p, d)) &&
                  ((n.faceIndex = Math.floor(i / 3)), e.push(n));
              }
            }
          else if (void 0 !== a)
            if (Array.isArray(r))
              for (let i = 0, s = c.length; i < s; i++) {
                const s = c[i],
                  d = r[s.materialIndex];
                for (
                  let i = Math.max(s.start, p.start),
                    r = Math.min(s.start + s.count, p.start + p.count);
                  i < r;
                  i += 3
                ) {
                  (n = hs(this, d, t, Hr, a, o, h, l, u, i, i + 1, i + 2)) &&
                    ((n.faceIndex = Math.floor(i / 3)),
                    (n.face.materialIndex = s.materialIndex),
                    e.push(n));
                }
              }
            else {
              for (
                let i = Math.max(0, p.start),
                  s = Math.min(a.count, p.start + p.count);
                i < s;
                i += 3
              ) {
                (n = hs(this, r, t, Hr, a, o, h, l, u, i, i + 1, i + 2)) &&
                  ((n.faceIndex = Math.floor(i / 3)), e.push(n));
              }
            }
        } else if (i.isGeometry) {
          const s = Array.isArray(r),
            a = i.vertices,
            o = i.faces;
          let h;
          const l = i.faceVertexUvs[0];
          l.length > 0 && (h = l);
          for (let i = 0, l = o.length; i < l; i++) {
            const l = o[i],
              u = s ? r[l.materialIndex] : r;
            if (void 0 === u) continue;
            const c = a[l.a],
              p = a[l.b],
              d = a[l.c];
            if ((n = os(this, u, t, Hr, c, p, d, ss))) {
              if (h && h[i]) {
                const t = h[i];
                es.copy(t[0]),
                  is.copy(t[1]),
                  rs.copy(t[2]),
                  (n.uv = kr.getUV(ss, c, p, d, es, is, rs, new mi()));
              }
              (n.face = l), (n.faceIndex = i), e.push(n);
            }
          }
        }
      },
    });
    const ls = {
        common: {
          diffuse: { value: new q(15658734) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new E() },
          uv2Transform: { value: new E() },
          alphaMap: { value: null },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          refractionRatio: { value: 0.98 },
          maxMipLevel: { value: 0 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 },
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new mi(1, 1) },
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new q(16777215) },
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: {
            value: [],
            properties: { direction: {}, color: {} },
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
            },
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: {
            value: [],
            properties: { color: {}, position: {}, decay: {}, distance: {} },
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: {
            value: [],
            properties: { direction: {}, skyColor: {}, groundColor: {} },
          },
          rectAreaLights: {
            value: [],
            properties: { color: {}, position: {}, width: {}, height: {} },
          },
          ltc_1: { value: null },
          ltc_2: { value: null },
        },
        points: {
          diffuse: { value: new q(15658734) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new E() },
        },
        sprite: {
          diffuse: { value: new q(15658734) },
          opacity: { value: 1 },
          center: { value: new mi(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new E() },
        },
      },
      us = {},
      cs = {
        basic: {
          uniforms: vr([
            ls.common,
            ls.specularmap,
            ls.envmap,
            ls.aomap,
            ls.lightmap,
            ls.fog,
          ]),
          vertexShader: us.meshbasic_vert,
          fragmentShader: us.meshbasic_frag,
        },
        lambert: {
          uniforms: vr([
            ls.common,
            ls.specularmap,
            ls.envmap,
            ls.aomap,
            ls.lightmap,
            ls.emissivemap,
            ls.fog,
            ls.lights,
            { emissive: { value: new q(0) } },
          ]),
          vertexShader: us.meshlambert_vert,
          fragmentShader: us.meshlambert_frag,
        },
        phong: {
          uniforms: vr([
            ls.common,
            ls.specularmap,
            ls.envmap,
            ls.aomap,
            ls.lightmap,
            ls.emissivemap,
            ls.bumpmap,
            ls.normalmap,
            ls.displacementmap,
            ls.fog,
            ls.lights,
            {
              emissive: { value: new q(0) },
              specular: { value: new q(1118481) },
              shininess: { value: 30 },
            },
          ]),
          vertexShader: us.meshphong_vert,
          fragmentShader: us.meshphong_frag,
        },
        standard: {
          uniforms: vr([
            ls.common,
            ls.envmap,
            ls.aomap,
            ls.lightmap,
            ls.emissivemap,
            ls.bumpmap,
            ls.normalmap,
            ls.displacementmap,
            ls.roughnessmap,
            ls.metalnessmap,
            ls.fog,
            ls.lights,
            {
              emissive: { value: new q(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 },
            },
          ]),
          vertexShader: us.meshphysical_vert,
          fragmentShader: us.meshphysical_frag,
        },
        toon: {
          uniforms: vr([
            ls.common,
            ls.aomap,
            ls.lightmap,
            ls.emissivemap,
            ls.bumpmap,
            ls.normalmap,
            ls.displacementmap,
            ls.gradientmap,
            ls.fog,
            ls.lights,
            { emissive: { value: new q(0) } },
          ]),
          vertexShader: us.meshtoon_vert,
          fragmentShader: us.meshtoon_frag,
        },
        matcap: {
          uniforms: vr([
            ls.common,
            ls.bumpmap,
            ls.normalmap,
            ls.displacementmap,
            ls.fog,
            { matcap: { value: null } },
          ]),
          vertexShader: us.meshmatcap_vert,
          fragmentShader: us.meshmatcap_frag,
        },
        points: {
          uniforms: vr([ls.points, ls.fog]),
          vertexShader: us.points_vert,
          fragmentShader: us.points_frag,
        },
        dashed: {
          uniforms: vr([
            ls.common,
            ls.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 },
            },
          ]),
          vertexShader: us.linedashed_vert,
          fragmentShader: us.linedashed_frag,
        },
        depth: {
          uniforms: vr([ls.common, ls.displacementmap]),
          vertexShader: us.depth_vert,
          fragmentShader: us.depth_frag,
        },
        normal: {
          uniforms: vr([
            ls.common,
            ls.bumpmap,
            ls.normalmap,
            ls.displacementmap,
            { opacity: { value: 1 } },
          ]),
          vertexShader: us.normal_vert,
          fragmentShader: us.normal_frag,
        },
        sprite: {
          uniforms: vr([ls.sprite, ls.fog]),
          vertexShader: us.sprite_vert,
          fragmentShader: us.sprite_frag,
        },
        background: {
          uniforms: { uvTransform: { value: new E() }, t2D: { value: null } },
          vertexShader: us.background_vert,
          fragmentShader: us.background_frag,
        },
        cube: {
          uniforms: vr([ls.envmap, { opacity: { value: 1 } }]),
          vertexShader: us.cube_vert,
          fragmentShader: us.cube_frag,
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: us.equirect_vert,
          fragmentShader: us.equirect_frag,
        },
        distanceRGBA: {
          uniforms: vr([
            ls.common,
            ls.displacementmap,
            {
              referencePosition: { value: new h() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 },
            },
          ]),
          vertexShader: us.distanceRGBA_vert,
          fragmentShader: us.distanceRGBA_frag,
        },
        shadow: {
          uniforms: vr([
            ls.lights,
            ls.fog,
            { color: { value: new q(0) }, opacity: { value: 1 } },
          ]),
          vertexShader: us.shadow_vert,
          fragmentShader: us.shadow_frag,
        },
      };
    function ps(t, e, i, r, s) {
      const n = new q(0);
      let a,
        o,
        h = 0,
        l = null,
        u = 0,
        c = null;
      function p(t, e) {
        i.buffers.color.setClear(t.r, t.g, t.b, e, s);
      }
      return {
        getClearColor: function () {
          return n;
        },
        setClearColor: function (t, e) {
          n.set(t), p(n, (h = void 0 !== e ? e : 1));
        },
        getClearAlpha: function () {
          return h;
        },
        setClearAlpha: function (t) {
          p(n, (h = t));
        },
        render: function (i, s, d, m) {
          let f = !0 === s.isScene ? s.background : null;
          f && f.isTexture && (f = e.get(f));
          const g = t.xr,
            y = g.getSession && g.getSession();
          y && "additive" === y.environmentBlendMode && (f = null),
            null === f ? p(n, h) : f && f.isColor && (p(f, 1), (m = !0)),
            (t.autoClear || m) &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            f &&
            (f.isCubeTexture || f.isWebGLCubeRenderTarget || f.mapping === Dt)
              ? (void 0 === o &&
                  ((o = new as(
                    new fr(1, 1, 1),
                    new wr({
                      name: "BackgroundCubeMaterial",
                      uniforms: br(cs.cube.uniforms),
                      vertexShader: cs.cube.vertexShader,
                      fragmentShader: cs.cube.fragmentShader,
                      side: tt,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    }),
                  )).geometry.deleteAttribute("normal"),
                  o.geometry.deleteAttribute("uv"),
                  (o.onBeforeRender = function (t, e, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld);
                  }),
                  Object.defineProperty(o.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  r.update(o)),
                f.isWebGLCubeRenderTarget && (f = f.texture),
                (o.material.uniforms.envMap.value = f),
                (o.material.uniforms.flipEnvMap.value =
                  f.isCubeTexture && f._needsFlipEnvMap ? -1 : 1),
                (l === f && u === f.version && c === t.toneMapping) ||
                  ((o.material.needsUpdate = !0),
                  (l = f),
                  (u = f.version),
                  (c = t.toneMapping)),
                i.unshift(o, o.geometry, o.material, 0, 0, null))
              : f &&
                f.isTexture &&
                (void 0 === a &&
                  ((a = new as(
                    new gr(2, 2),
                    new wr({
                      name: "BackgroundMaterial",
                      uniforms: br(cs.background.uniforms),
                      vertexShader: cs.background.vertexShader,
                      fragmentShader: cs.background.fragmentShader,
                      side: $,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    }),
                  )).geometry.deleteAttribute("normal"),
                  Object.defineProperty(a.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  r.update(a)),
                (a.material.uniforms.t2D.value = f),
                !0 === f.matrixAutoUpdate && f.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(f.matrix),
                (l === f && u === f.version && c === t.toneMapping) ||
                  ((a.material.needsUpdate = !0),
                  (l = f),
                  (u = f.version),
                  (c = t.toneMapping)),
                i.unshift(a, a.geometry, a.material, 0, 0, null));
        },
      };
    }
    function ds(t, e, i, r) {
      const s = t.getParameter(t.MAX_VERTEX_ATTRIBS),
        n = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        a = r.isWebGL2 || null !== n,
        o = {},
        h = p(null);
      let l = h;
      function u(e) {
        return r.isWebGL2 ? t.bindVertexArray(e) : n.bindVertexArrayOES(e);
      }
      function c(e) {
        return r.isWebGL2 ? t.deleteVertexArray(e) : n.deleteVertexArrayOES(e);
      }
      function p(t) {
        const e = [],
          i = [],
          r = [];
        for (let t = 0; t < s; t++) (e[t] = 0), (i[t] = 0), (r[t] = 0);
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: e,
          enabledAttributes: i,
          attributeDivisors: r,
          object: t,
          attributes: {},
          index: null,
        };
      }
      function d() {
        const t = l.newAttributes;
        for (let e = 0, i = t.length; e < i; e++) t[e] = 0;
      }
      function m(t) {
        f(t, 0);
      }
      function f(i, s) {
        const n = l.newAttributes,
          a = l.enabledAttributes,
          o = l.attributeDivisors;
        if (
          ((n[i] = 1),
          0 === a[i] && (t.enableVertexAttribArray(i), (a[i] = 1)),
          o[i] !== s)
        ) {
          (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
            r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](i, s),
            (o[i] = s);
        }
      }
      function g() {
        const e = l.newAttributes,
          i = l.enabledAttributes;
        for (let r = 0, s = i.length; r < s; r++)
          i[r] !== e[r] && (t.disableVertexAttribArray(r), (i[r] = 0));
      }
      function y(e, i, s, n, a, o) {
        !0 !== r.isWebGL2 || (s !== t.INT && s !== t.UNSIGNED_INT)
          ? t.vertexAttribPointer(e, i, s, n, a, o)
          : t.vertexAttribIPointer(e, i, s, a, o);
      }
      function x() {
        b(), l !== h && u((l = h).object);
      }
      function b() {
        (h.geometry = null), (h.program = null), (h.wireframe = !1);
      }
      return {
        setup: function (s, h, c, x, b) {
          let v = !1;
          if (a) {
            const e = (function (e, i, s) {
              const a = !0 === s.wireframe;
              let h = o[e.id];
              void 0 === h && ((h = {}), (o[e.id] = h));
              let l = h[i.id];
              void 0 === l && ((l = {}), (h[i.id] = l));
              let u = l[a];
              return (
                void 0 === u &&
                  ((u = p(
                    r.isWebGL2
                      ? t.createVertexArray()
                      : n.createVertexArrayOES(),
                  )),
                  (l[a] = u)),
                u
              );
            })(x, c, h);
            l !== e && u((l = e).object),
              (v = (function (t, e) {
                const i = l.attributes,
                  r = t.attributes;
                if (Object.keys(i).length !== Object.keys(r).length) return !0;
                for (const t in r) {
                  const e = i[t],
                    s = r[t];
                  if (void 0 === e) return !0;
                  if (e.attribute !== s) return !0;
                  if (e.data !== s.data) return !0;
                }
                return l.index !== e;
              })(x, b)) &&
                (function (t, e) {
                  const i = {},
                    r = t.attributes;
                  for (const t in r) {
                    const e = r[t],
                      s = {};
                    (s.attribute = e), e.data && (s.data = e.data), (i[t] = s);
                  }
                  (l.attributes = i), (l.index = e);
                })(x, b);
          } else {
            const t = !0 === h.wireframe;
            (l.geometry === x.id && l.program === c.id && l.wireframe === t) ||
              ((l.geometry = x.id),
              (l.program = c.id),
              (l.wireframe = t),
              (v = !0));
          }
          !0 === s.isInstancedMesh && (v = !0),
            null !== b && i.update(b, t.ELEMENT_ARRAY_BUFFER),
            v &&
              ((function (s, n, a, o) {
                if (
                  !1 === r.isWebGL2 &&
                  (s.isInstancedMesh || o.isInstancedBufferGeometry) &&
                  null === e.get("ANGLE_instanced_arrays")
                )
                  return;
                d();
                const h = o.attributes,
                  l = a.getAttributes(),
                  u = n.defaultAttributeValues;
                for (const e in l) {
                  const r = l[e];
                  if (r >= 0) {
                    const n = h[e];
                    if (void 0 !== n) {
                      const e = n.normalized,
                        s = n.itemSize,
                        a = i.get(n);
                      if (void 0 === a) continue;
                      const h = a.buffer,
                        l = a.type,
                        u = a.bytesPerElement;
                      if (n.isInterleavedBufferAttribute) {
                        const i = n.data,
                          a = i.stride,
                          c = n.offset;
                        i && i.isInstancedInterleavedBuffer
                          ? (f(r, i.meshPerAttribute),
                            void 0 === o._maxInstanceCount &&
                              (o._maxInstanceCount =
                                i.meshPerAttribute * i.count))
                          : m(r),
                          t.bindBuffer(t.ARRAY_BUFFER, h),
                          y(r, s, l, e, a * u, c * u);
                      } else
                        n.isInstancedBufferAttribute
                          ? (f(r, n.meshPerAttribute),
                            void 0 === o._maxInstanceCount &&
                              (o._maxInstanceCount =
                                n.meshPerAttribute * n.count))
                          : m(r),
                          t.bindBuffer(t.ARRAY_BUFFER, h),
                          y(r, s, l, e, 0, 0);
                    } else if ("instanceMatrix" === e) {
                      const e = i.get(s.instanceMatrix);
                      if (void 0 === e) continue;
                      const n = e.buffer,
                        a = e.type;
                      f(r + 0, 1),
                        f(r + 1, 1),
                        f(r + 2, 1),
                        f(r + 3, 1),
                        t.bindBuffer(t.ARRAY_BUFFER, n),
                        t.vertexAttribPointer(r + 0, 4, a, !1, 64, 0),
                        t.vertexAttribPointer(r + 1, 4, a, !1, 64, 16),
                        t.vertexAttribPointer(r + 2, 4, a, !1, 64, 32),
                        t.vertexAttribPointer(r + 3, 4, a, !1, 64, 48);
                    } else if ("instanceColor" === e) {
                      const e = i.get(s.instanceColor);
                      if (void 0 === e) continue;
                      const n = e.buffer,
                        a = e.type;
                      f(r, 1),
                        t.bindBuffer(t.ARRAY_BUFFER, n),
                        t.vertexAttribPointer(r, 3, a, !1, 12, 0);
                    } else if (void 0 !== u) {
                      const i = u[e];
                      if (void 0 !== i)
                        switch (i.length) {
                          case 2:
                            t.vertexAttrib2fv(r, i);
                            break;
                          case 3:
                            t.vertexAttrib3fv(r, i);
                            break;
                          case 4:
                            t.vertexAttrib4fv(r, i);
                            break;
                          default:
                            t.vertexAttrib1fv(r, i);
                        }
                    }
                  }
                }
                g();
              })(s, h, c, x),
              null !== b &&
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, i.get(b).buffer));
        },
        reset: x,
        resetDefaultState: b,
        dispose: function () {
          x();
          for (const t in o) {
            const e = o[t];
            for (const t in e) {
              const i = e[t];
              for (const t in i) c(i[t].object), delete i[t];
              delete e[t];
            }
            delete o[t];
          }
        },
        releaseStatesOfGeometry: function (t) {
          if (void 0 === o[t.id]) return;
          const e = o[t.id];
          for (const t in e) {
            const i = e[t];
            for (const t in i) c(i[t].object), delete i[t];
            delete e[t];
          }
          delete o[t.id];
        },
        releaseStatesOfProgram: function (t) {
          for (const e in o) {
            const i = o[e];
            if (void 0 === i[t.id]) continue;
            const r = i[t.id];
            for (const t in r) c(r[t].object), delete r[t];
            delete i[t.id];
          }
        },
        initAttributes: d,
        enableAttribute: m,
        disableUnusedAttributes: g,
      };
    }
    function ms(t, e, i, r) {
      const s = r.isWebGL2;
      let n;
      (this.setMode = function (t) {
        n = t;
      }),
        (this.render = function (e, r) {
          t.drawArrays(n, e, r), i.update(r, n, 1);
        }),
        (this.renderInstances = function (r, a, o) {
          if (0 === o) return;
          let h, l;
          if (s) (h = t), (l = "drawArraysInstanced");
          else if (
            ((l = "drawArraysInstancedANGLE"),
            null === (h = e.get("ANGLE_instanced_arrays")))
          )
            return void console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
            );
          h[l](n, r, a, o), i.update(a, n, o);
        });
    }
    function fs(t, e, i) {
      let r;
      function s(e) {
        if ("highp" === e) {
          if (
            t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)
              .precision > 0 &&
            t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
              .precision > 0
          )
            return "highp";
          e = "mediump";
        }
        return "mediump" === e &&
          t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT)
            .precision > 0 &&
          t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
            .precision > 0
          ? "mediump"
          : "lowp";
      }
      const n =
        ("undefined" != typeof WebGL2RenderingContext &&
          t instanceof WebGL2RenderingContext) ||
        ("undefined" != typeof WebGL2ComputeRenderingContext &&
          t instanceof WebGL2ComputeRenderingContext);
      let a = void 0 !== i.precision ? i.precision : "highp";
      const o = s(a);
      o !== a &&
        (console.warn(
          "THREE.WebGLRenderer:",
          a,
          "not supported, using",
          o,
          "instead.",
        ),
        (a = o));
      const h = !0 === i.logarithmicDepthBuffer,
        l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
        u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        c = t.getParameter(t.MAX_TEXTURE_SIZE),
        p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
        d = t.getParameter(t.MAX_VERTEX_ATTRIBS),
        m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
        f = t.getParameter(t.MAX_VARYING_VECTORS),
        g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
        y = u > 0,
        x = n || !!e.get("OES_texture_float");
      return {
        isWebGL2: n,
        getMaxAnisotropy: function () {
          if (void 0 !== r) return r;
          const i = e.get("EXT_texture_filter_anisotropic");
          return (r =
            null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
        },
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: l,
        maxVertexTextures: u,
        maxTextureSize: c,
        maxCubemapSize: p,
        maxAttributes: d,
        maxVertexUniforms: m,
        maxVaryings: f,
        maxFragmentUniforms: g,
        vertexTextures: y,
        floatFragmentTextures: x,
        floatVertexTextures: y && x,
        maxSamples: n ? t.getParameter(t.MAX_SAMPLES) : 0,
      };
    }
    function gs(t) {
      const e = this;
      let i = null,
        r = 0,
        s = !1,
        n = !1;
      const a = new ki(),
        o = new E(),
        h = { value: null, needsUpdate: !1 };
      function l() {
        h.value !== i && ((h.value = i), (h.needsUpdate = r > 0)),
          (e.numPlanes = r),
          (e.numIntersection = 0);
      }
      function u(t, i, r, s) {
        const n = null !== t ? t.length : 0;
        let l = null;
        if (0 !== n) {
          if (((l = h.value), !0 !== s || null === l)) {
            const e = r + 4 * n,
              s = i.matrixWorldInverse;
            o.getNormalMatrix(s),
              (null === l || l.length < e) && (l = new Float32Array(e));
            for (let e = 0, i = r; e !== n; ++e, i += 4)
              a.copy(t[e]).applyMatrix4(s, o),
                a.normal.toArray(l, i),
                (l[i + 3] = a.constant);
          }
          (h.value = l), (h.needsUpdate = !0);
        }
        return (e.numPlanes = n), (e.numIntersection = 0), l;
      }
      (this.uniform = h),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (t, e, n) {
          const a = 0 !== t.length || e || 0 !== r || s;
          return (s = e), (i = u(t, n, 0)), (r = t.length), a;
        }),
        (this.beginShadows = function () {
          (n = !0), u(null);
        }),
        (this.endShadows = function () {
          (n = !1), l();
        }),
        (this.setState = function (e, a, o) {
          const c = e.clippingPlanes,
            p = e.clipIntersection,
            d = e.clipShadows,
            m = t.get(e);
          if (!s || null === c || 0 === c.length || (n && !d))
            n ? u(null) : l();
          else {
            const t = n ? 0 : r,
              e = 4 * t;
            let s = m.clippingState || null;
            (h.value = s), (s = u(c, a, e, o));
            for (let t = 0; t !== e; ++t) s[t] = i[t];
            (m.clippingState = s),
              (this.numIntersection = p ? this.numPlanes : 0),
              (this.numPlanes += t);
          }
        });
    }
    function ys(t, e, i) {
      (this.width = t),
        (this.height = e),
        (this.scissor = new Hi(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new Hi(0, 0, t, e)),
        (i = i || {}),
        (this.texture = new xi(
          void 0,
          i.mapping,
          i.wrapS,
          i.wrapT,
          i.magFilter,
          i.minFilter,
          i.format,
          i.type,
          i.anisotropy,
          i.encoding,
        )),
        (this.texture.image = {}),
        (this.texture.image.width = t),
        (this.texture.image.height = e),
        (this.texture.generateMipmaps =
          void 0 !== i.generateMipmaps && i.generateMipmaps),
        (this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : jt),
        (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
        (this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer),
        (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null);
    }
    (cs.physical = {
      uniforms: vr([
        cs.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new mi(1, 1) },
          clearcoatNormalMap: { value: null },
          sheen: { value: new q(0) },
          transmission: { value: 0 },
          transmissionMap: { value: null },
        },
      ]),
      vertexShader: us.meshphysical_vert,
      fragmentShader: us.meshphysical_frag,
    }),
      (ys.prototype = Object.assign(Object.create(b.prototype), {
        constructor: ys,
        isWebGLRenderTarget: !0,
        setSize: function (t, e) {
          (this.width === t && this.height === e) ||
            ((this.width = t),
            (this.height = e),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      }));
    const xs = 90,
      bs = 1;
    function vs(t, e, i) {
      if (
        (D.call(this),
        (this.type = "CubeCamera"),
        !0 !== i.isWebGLCubeRenderTarget)
      )
        return void console.error(
          "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.",
        );
      this.renderTarget = i;
      const r = new k(xs, bs, t, e);
      (r.layers = this.layers),
        r.up.set(0, -1, 0),
        r.lookAt(new h(1, 0, 0)),
        this.add(r);
      const s = new k(xs, bs, t, e);
      (s.layers = this.layers),
        s.up.set(0, -1, 0),
        s.lookAt(new h(-1, 0, 0)),
        this.add(s);
      const n = new k(xs, bs, t, e);
      (n.layers = this.layers),
        n.up.set(0, 0, 1),
        n.lookAt(new h(0, 1, 0)),
        this.add(n);
      const a = new k(xs, bs, t, e);
      (a.layers = this.layers),
        a.up.set(0, 0, -1),
        a.lookAt(new h(0, -1, 0)),
        this.add(a);
      const o = new k(xs, bs, t, e);
      (o.layers = this.layers),
        o.up.set(0, -1, 0),
        o.lookAt(new h(0, 0, 1)),
        this.add(o);
      const l = new k(xs, bs, t, e);
      (l.layers = this.layers),
        l.up.set(0, -1, 0),
        l.lookAt(new h(0, 0, -1)),
        this.add(l),
        (this.update = function (t, e) {
          null === this.parent && this.updateMatrixWorld();
          const h = t.xr.enabled,
            u = t.getRenderTarget();
          t.xr.enabled = !1;
          const c = i.texture.generateMipmaps;
          (i.texture.generateMipmaps = !1),
            t.setRenderTarget(i, 0),
            t.render(e, r),
            t.setRenderTarget(i, 1),
            t.render(e, s),
            t.setRenderTarget(i, 2),
            t.render(e, n),
            t.setRenderTarget(i, 3),
            t.render(e, a),
            t.setRenderTarget(i, 4),
            t.render(e, o),
            (i.texture.generateMipmaps = c),
            t.setRenderTarget(i, 5),
            t.render(e, l),
            t.setRenderTarget(u),
            (t.xr.enabled = h);
        }),
        (this.clear = function (t, e, r, s) {
          const n = t.getRenderTarget();
          for (let n = 0; n < 6; n++) t.setRenderTarget(i, n), t.clear(e, r, s);
          t.setRenderTarget(n);
        });
    }
    function Ms(t, e, i, r, s, n, a, o, h, l) {
      (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : Ut),
        (a = void 0 !== a ? a : he),
        xi.call(this, t, e, i, r, s, n, a, o, h, l),
        (this.flipY = !1),
        (this._needsFlipEnvMap = !0);
    }
    function ws(t, e, i) {
      Number.isInteger(e) &&
        (console.warn(
          "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )",
        ),
        (e = i)),
        ys.call(this, t, t, e),
        (e = e || {}),
        (this.texture = new Ms(
          void 0,
          e.mapping,
          e.wrapS,
          e.wrapT,
          e.magFilter,
          e.minFilter,
          e.format,
          e.type,
          e.anisotropy,
          e.encoding,
        )),
        (this.texture._needsFlipEnvMap = !1);
    }
    function _s(t) {
      let e = new WeakMap();
      function i(t, e) {
        return e === Ct ? (t.mapping = Ut) : e === Ot && (t.mapping = Bt), t;
      }
      function r(t) {
        const i = t.target;
        i.removeEventListener("dispose", r);
        const s = e.get(i);
        void 0 !== s && (e.delete(i), s.dispose());
      }
      return {
        get: function (s) {
          if (s && s.isTexture) {
            const n = s.mapping;
            if (n === Ct || n === Ot) {
              if (e.has(s)) return i(e.get(s).texture, s.mapping);
              {
                const n = s.image;
                if (n && n.height > 0) {
                  const a = t.getRenderList(),
                    o = t.getRenderTarget(),
                    h = t.getRenderState(),
                    l = new ws(n.height / 2);
                  return (
                    l.fromEquirectangularTexture(t, s),
                    e.set(s, l),
                    t.setRenderTarget(o),
                    t.setRenderList(a),
                    t.setRenderState(h),
                    s.addEventListener("dispose", r),
                    i(l.texture, s.mapping)
                  );
                }
                return null;
              }
            }
          }
          return s;
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }
    function Es(t) {
      const e = {};
      return {
        has: function (i) {
          if (void 0 !== e[i]) return null !== e[i];
          let r;
          switch (i) {
            case "WEBGL_depth_texture":
              r =
                t.getExtension("WEBGL_depth_texture") ||
                t.getExtension("MOZ_WEBGL_depth_texture") ||
                t.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              r =
                t.getExtension("EXT_texture_filter_anisotropic") ||
                t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              r =
                t.getExtension("WEBGL_compressed_texture_s3tc") ||
                t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              r =
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              r = t.getExtension(i);
          }
          return (e[i] = r), null !== r;
        },
        get: function (t) {
          return (
            this.has(t) ||
              console.warn(
                "THREE.WebGLRenderer: " + t + " extension not supported.",
              ),
            e[t]
          );
        },
      };
    }
    function Ts(t, e, i, r) {
      const s = new WeakMap(),
        n = new WeakMap();
      function a(t) {
        const o = t.target,
          h = s.get(o);
        null !== h.index && e.remove(h.index);
        for (const t in h.attributes) e.remove(h.attributes[t]);
        o.removeEventListener("dispose", a), s.delete(o);
        const l = n.get(h);
        l && (e.remove(l), n.delete(h)),
          r.releaseStatesOfGeometry(h),
          !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
          i.memory.geometries--;
      }
      function o(t) {
        const i = [],
          r = t.index,
          s = t.attributes.position;
        let a = 0;
        if (null !== r) {
          const t = r.array;
          a = r.version;
          for (let e = 0, r = t.length; e < r; e += 3) {
            const r = t[e + 0],
              s = t[e + 1],
              n = t[e + 2];
            i.push(r, s, s, n, n, r);
          }
        } else {
          const t = s.array;
          a = s.version;
          for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
            const t = e + 0,
              r = e + 1,
              s = e + 2;
            i.push(t, r, r, s, s, t);
          }
        }
        const o = new (ar(i) > 65535 ? ir : tr)(i, 1);
        o.version = a;
        const h = n.get(t);
        h && e.remove(h), n.set(t, o);
      }
      return {
        get: function (t, e) {
          let r = s.get(e);
          return (
            r ||
            (e.addEventListener("dispose", a),
            e.isBufferGeometry
              ? (r = e)
              : e.isGeometry &&
                (void 0 === e._bufferGeometry &&
                  (e._bufferGeometry = new mr().setFromObject(t)),
                (r = e._bufferGeometry)),
            s.set(e, r),
            i.memory.geometries++,
            r)
          );
        },
        update: function (i) {
          const r = i.attributes;
          for (const i in r) e.update(r[i], t.ARRAY_BUFFER);
          const s = i.morphAttributes;
          for (const i in s) {
            const r = s[i];
            for (let i = 0, s = r.length; i < s; i++)
              e.update(r[i], t.ARRAY_BUFFER);
          }
        },
        getWireframeAttribute: function (t) {
          const e = n.get(t);
          if (e) {
            const i = t.index;
            null !== i && e.version < i.version && o(t);
          } else o(t);
          return n.get(t);
        },
      };
    }
    function Ss(t, e, i, r) {
      const s = r.isWebGL2;
      let n, a, o;
      (this.setMode = function (t) {
        n = t;
      }),
        (this.setIndex = function (t) {
          (a = t.type), (o = t.bytesPerElement);
        }),
        (this.render = function (e, r) {
          t.drawElements(n, r, a, e * o), i.update(r, n, 1);
        }),
        (this.renderInstances = function (r, h, l) {
          if (0 === l) return;
          let u, c;
          if (s) (u = t), (c = "drawElementsInstanced");
          else if (
            ((c = "drawElementsInstancedANGLE"),
            null === (u = e.get("ANGLE_instanced_arrays")))
          )
            return void console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
            );
          u[c](n, h, a, r * o, l), i.update(h, n, l);
        });
    }
    function As(t) {
      const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
      return {
        memory: { geometries: 0, textures: 0 },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function () {
          e.frame++,
            (e.calls = 0),
            (e.triangles = 0),
            (e.points = 0),
            (e.lines = 0);
        },
        update: function (i, r, s) {
          switch ((e.calls++, r)) {
            case t.TRIANGLES:
              e.triangles += s * (i / 3);
              break;
            case t.LINES:
              e.lines += s * (i / 2);
              break;
            case t.LINE_STRIP:
              e.lines += s * (i - 1);
              break;
            case t.LINE_LOOP:
              e.lines += s * i;
              break;
            case t.POINTS:
              e.points += s * i;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", r);
          }
        },
      };
    }
    function Rs(t, e) {
      return t[0] - e[0];
    }
    function Ls(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1]);
    }
    function Fs(t) {
      const e = {},
        i = new Float32Array(8),
        r = [];
      for (let t = 0; t < 8; t++) r[t] = [t, 0];
      return {
        update: function (s, n, a, o) {
          const h = s.morphTargetInfluences,
            l = void 0 === h ? 0 : h.length;
          let u = e[n.id];
          if (void 0 === u) {
            u = [];
            for (let t = 0; t < l; t++) u[t] = [t, 0];
            e[n.id] = u;
          }
          for (let t = 0; t < l; t++) {
            const e = u[t];
            (e[0] = t), (e[1] = h[t]);
          }
          u.sort(Ls);
          for (let t = 0; t < 8; t++)
            t < l && u[t][1]
              ? ((r[t][0] = u[t][0]), (r[t][1] = u[t][1]))
              : ((r[t][0] = Number.MAX_SAFE_INTEGER), (r[t][1] = 0));
          r.sort(Rs);
          const c = a.morphTargets && n.morphAttributes.position,
            p = a.morphNormals && n.morphAttributes.normal;
          let d = 0;
          for (let t = 0; t < 8; t++) {
            const e = r[t],
              s = e[0],
              a = e[1];
            s !== Number.MAX_SAFE_INTEGER && a
              ? (c &&
                  n.getAttribute("morphTarget" + t) !== c[s] &&
                  n.setAttribute("morphTarget" + t, c[s]),
                p &&
                  n.getAttribute("morphNormal" + t) !== p[s] &&
                  n.setAttribute("morphNormal" + t, p[s]),
                (i[t] = a),
                (d += a))
              : (c &&
                  void 0 !== n.getAttribute("morphTarget" + t) &&
                  n.deleteAttribute("morphTarget" + t),
                p &&
                  void 0 !== n.getAttribute("morphNormal" + t) &&
                  n.deleteAttribute("morphNormal" + t),
                (i[t] = 0));
          }
          const m = n.morphTargetsRelative ? 1 : 1 - d;
          o.getUniforms().setValue(t, "morphTargetBaseInfluence", m),
            o.getUniforms().setValue(t, "morphTargetInfluences", i);
        },
      };
    }
    function zs(t, e, i, r) {
      let s = new WeakMap();
      return {
        update: function (n) {
          const a = r.render.frame,
            o = n.geometry,
            h = e.get(n, o);
          return (
            s.get(h) !== a &&
              (o.isGeometry && h.updateFromObject(n), e.update(h), s.set(h, a)),
            n.isInstancedMesh &&
              (i.update(n.instanceMatrix, t.ARRAY_BUFFER),
              null !== n.instanceColor &&
                i.update(n.instanceColor, t.ARRAY_BUFFER)),
            h
          );
        },
        dispose: function () {
          s = new WeakMap();
        },
      };
    }
    function Ps(t, e, i, r) {
      xi.call(this, null),
        (this.image = {
          data: t || null,
          width: e || 1,
          height: i || 1,
          depth: r || 1,
        }),
        (this.magFilter = Vt),
        (this.minFilter = Vt),
        (this.wrapR = Gt),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.needsUpdate = !0);
    }
    function Ns(t, e, i, r) {
      xi.call(this, null),
        (this.image = {
          data: t || null,
          width: e || 1,
          height: i || 1,
          depth: r || 1,
        }),
        (this.magFilter = Vt),
        (this.minFilter = Vt),
        (this.wrapR = Gt),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.needsUpdate = !0);
    }
    (vs.prototype = Object.create(D.prototype)),
      (vs.prototype.constructor = vs),
      (Ms.prototype = Object.create(xi.prototype)),
      (Ms.prototype.constructor = Ms),
      (Ms.prototype.isCubeTexture = !0),
      Object.defineProperty(Ms.prototype, "images", {
        get: function () {
          return this.image;
        },
        set: function (t) {
          this.image = t;
        },
      }),
      (ws.prototype = Object.create(ys.prototype)),
      (ws.prototype.constructor = ws),
      (ws.prototype.isWebGLCubeRenderTarget = !0),
      (ws.prototype.fromEquirectangularTexture = function (t, e) {
        (this.texture.type = e.type),
          (this.texture.format = le),
          (this.texture.encoding = e.encoding),
          (this.texture.generateMipmaps = e.generateMipmaps),
          (this.texture.minFilter = e.minFilter),
          (this.texture.magFilter = e.magFilter);
        const i = { tEquirect: { value: null } },
          r = null,
          s = null,
          n = new fr(5, 5, 5),
          a = new wr({
            name: "CubemapFromEquirect",
            uniforms: br(i),
            vertexShader: r,
            fragmentShader: s,
            side: tt,
            blending: it,
          });
        a.uniforms.tEquirect.value = e;
        const o = new as(n, a),
          h = e.minFilter;
        return (
          e.minFilter === Yt && (e.minFilter = jt),
          new vs(1, 10, this).update(t, o),
          (e.minFilter = h),
          o.geometry.dispose(),
          o.material.dispose(),
          this
        );
      }),
      (Ps.prototype = Object.create(xi.prototype)),
      (Ps.prototype.constructor = Ps),
      (Ps.prototype.isDataTexture2DArray = !0),
      (Ns.prototype = Object.create(xi.prototype)),
      (Ns.prototype.constructor = Ns),
      (Ns.prototype.isDataTexture3D = !0);
    const Us = new xi(),
      Bs = new Ps(),
      Cs = new Ns(),
      Os = new Ms(),
      Ds = [],
      Is = [],
      ks = new Float32Array(16),
      Gs = new Float32Array(9),
      Ws = new Float32Array(4);
    function Vs(t, e, i) {
      const r = t[0];
      if (r <= 0 || r > 0) return t;
      const s = e * i;
      let n = Ds[s];
      if ((void 0 === n && ((n = new Float32Array(s)), (Ds[s] = n)), 0 !== e)) {
        r.toArray(n, 0);
        for (let r = 1, s = 0; r !== e; ++r) (s += i), t[r].toArray(n, s);
      }
      return n;
    }
    function Hs(t, e) {
      if (t.length !== e.length) return !1;
      for (let i = 0, r = t.length; i < r; i++) if (t[i] !== e[i]) return !1;
      return !0;
    }
    function Xs(t, e) {
      for (let i = 0, r = e.length; i < r; i++) t[i] = e[i];
    }
    function js(t, e) {
      let i = Is[e];
      void 0 === i && ((i = new Int32Array(e)), (Is[e] = i));
      for (let r = 0; r !== e; ++r) i[r] = t.allocateTextureUnit();
      return i;
    }
    function qs(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1f(this.addr, e), (i[0] = e));
    }
    function Ys(t, e) {
      const i = this.cache;
      if (void 0 !== e.x)
        (i[0] === e.x && i[1] === e.y) ||
          (t.uniform2f(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y));
      else {
        if (Hs(i, e)) return;
        t.uniform2fv(this.addr, e), Xs(i, e);
      }
    }
    function Zs(t, e) {
      const i = this.cache;
      if (void 0 !== e.x)
        (i[0] === e.x && i[1] === e.y && i[2] === e.z) ||
          (t.uniform3f(this.addr, e.x, e.y, e.z),
          (i[0] = e.x),
          (i[1] = e.y),
          (i[2] = e.z));
      else if (void 0 !== e.r)
        (i[0] === e.r && i[1] === e.g && i[2] === e.b) ||
          (t.uniform3f(this.addr, e.r, e.g, e.b),
          (i[0] = e.r),
          (i[1] = e.g),
          (i[2] = e.b));
      else {
        if (Hs(i, e)) return;
        t.uniform3fv(this.addr, e), Xs(i, e);
      }
    }
    function Js(t, e) {
      const i = this.cache;
      if (void 0 !== e.x)
        (i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w) ||
          (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
          (i[0] = e.x),
          (i[1] = e.y),
          (i[2] = e.z),
          (i[3] = e.w));
      else {
        if (Hs(i, e)) return;
        t.uniform4fv(this.addr, e), Xs(i, e);
      }
    }
    function Qs(t, e) {
      const i = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (Hs(i, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), Xs(i, e);
      } else {
        if (Hs(i, r)) return;
        Ws.set(r), t.uniformMatrix2fv(this.addr, !1, Ws), Xs(i, r);
      }
    }
    function Ks(t, e) {
      const i = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (Hs(i, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), Xs(i, e);
      } else {
        if (Hs(i, r)) return;
        Gs.set(r), t.uniformMatrix3fv(this.addr, !1, Gs), Xs(i, r);
      }
    }
    function $s(t, e) {
      const i = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (Hs(i, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), Xs(i, e);
      } else {
        if (Hs(i, r)) return;
        ks.set(r), t.uniformMatrix4fv(this.addr, !1, ks), Xs(i, r);
      }
    }
    function tn(t, e, i) {
      const r = this.cache,
        s = i.allocateTextureUnit();
      r[0] !== s && (t.uniform1i(this.addr, s), (r[0] = s)),
        i.safeSetTexture2D(e || Us, s);
    }
    function en(t, e, i) {
      const r = this.cache,
        s = i.allocateTextureUnit();
      r[0] !== s && (t.uniform1i(this.addr, s), (r[0] = s)),
        i.setTexture2DArray(e || Bs, s);
    }
    function rn(t, e, i) {
      const r = this.cache,
        s = i.allocateTextureUnit();
      r[0] !== s && (t.uniform1i(this.addr, s), (r[0] = s)),
        i.setTexture3D(e || Cs, s);
    }
    function sn(t, e, i) {
      const r = this.cache,
        s = i.allocateTextureUnit();
      r[0] !== s && (t.uniform1i(this.addr, s), (r[0] = s)),
        i.safeSetTextureCube(e || Os, s);
    }
    function nn(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1i(this.addr, e), (i[0] = e));
    }
    function an(t, e) {
      const i = this.cache;
      Hs(i, e) || (t.uniform2iv(this.addr, e), Xs(i, e));
    }
    function on(t, e) {
      const i = this.cache;
      Hs(i, e) || (t.uniform3iv(this.addr, e), Xs(i, e));
    }
    function hn(t, e) {
      const i = this.cache;
      Hs(i, e) || (t.uniform4iv(this.addr, e), Xs(i, e));
    }
    function ln(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1ui(this.addr, e), (i[0] = e));
    }
    function un(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function cn(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function pn(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function dn(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function mn(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function fn(t, e) {
      const i = Vs(e, this.size, 2);
      t.uniform2fv(this.addr, i);
    }
    function gn(t, e) {
      const i = Vs(e, this.size, 3);
      t.uniform3fv(this.addr, i);
    }
    function yn(t, e) {
      const i = Vs(e, this.size, 4);
      t.uniform4fv(this.addr, i);
    }
    function xn(t, e) {
      const i = Vs(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, !1, i);
    }
    function bn(t, e) {
      const i = Vs(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, !1, i);
    }
    function vn(t, e) {
      const i = Vs(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, !1, i);
    }
    function Mn(t, e, i) {
      const r = e.length,
        s = js(i, r);
      t.uniform1iv(this.addr, s);
      for (let t = 0; t !== r; ++t) i.safeSetTexture2D(e[t] || Us, s[t]);
    }
    function wn(t, e, i) {
      const r = e.length,
        s = js(i, r);
      t.uniform1iv(this.addr, s);
      for (let t = 0; t !== r; ++t) i.safeSetTextureCube(e[t] || Os, s[t]);
    }
    function _n(t, e, i) {
      (this.id = t),
        (this.addr = i),
        (this.cache = []),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return qs;
            case 35664:
              return Ys;
            case 35665:
              return Zs;
            case 35666:
              return Js;
            case 35674:
              return Qs;
            case 35675:
              return Ks;
            case 35676:
              return $s;
            case 5124:
            case 35670:
              return nn;
            case 35667:
            case 35671:
              return an;
            case 35668:
            case 35672:
              return on;
            case 35669:
            case 35673:
              return hn;
            case 5125:
              return ln;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return tn;
            case 35679:
            case 36299:
            case 36307:
              return rn;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return sn;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return en;
          }
        })(e.type));
    }
    function En(t, e, i) {
      (this.id = t),
        (this.addr = i),
        (this.cache = []),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return un;
            case 35664:
              return fn;
            case 35665:
              return gn;
            case 35666:
              return yn;
            case 35674:
              return xn;
            case 35675:
              return bn;
            case 35676:
              return vn;
            case 5124:
            case 35670:
              return cn;
            case 35667:
            case 35671:
              return pn;
            case 35668:
            case 35672:
              return dn;
            case 35669:
            case 35673:
              return mn;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Mn;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return wn;
          }
        })(e.type));
    }
    function Tn(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    (En.prototype.updateCache = function (t) {
      const e = this.cache;
      t instanceof Float32Array &&
        e.length !== t.length &&
        (this.cache = new Float32Array(t.length)),
        Xs(e, t);
    }),
      (Tn.prototype.setValue = function (t, e, i) {
        const r = this.seq;
        for (let s = 0, n = r.length; s !== n; ++s) {
          const n = r[s];
          n.setValue(t, e[n.id], i);
        }
      });
    const Sn = /([\w\d_]+)(\])?(\[|\.)?/g;
    function An(t, e) {
      t.seq.push(e), (t.map[e.id] = e);
    }
    function Rn(t, e, i) {
      const r = t.name,
        s = r.length;
      for (Sn.lastIndex = 0; ; ) {
        const n = Sn.exec(r),
          a = Sn.lastIndex;
        let o = n[1];
        const h = "]" === n[2],
          l = n[3];
        if ((h && (o |= 0), void 0 === l || ("[" === l && a + 2 === s))) {
          An(i, void 0 === l ? new _n(o, t, e) : new En(o, t, e));
          break;
        }
        {
          let t = i.map[o];
          void 0 === t && An(i, (t = new Tn(o))), (i = t);
        }
      }
    }
    function Ln(t, e) {
      (this.seq = []), (this.map = {});
      const i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
      for (let r = 0; r < i; ++r) {
        const i = t.getActiveUniform(e, r);
        Rn(i, t.getUniformLocation(e, i.name), this);
      }
    }
    function Fn(t, e, i) {
      const r = t.createShader(e);
      return t.shaderSource(r, i), t.compileShader(r), r;
    }
    (Ln.prototype.setValue = function (t, e, i, r) {
      const s = this.map[e];
      void 0 !== s && s.setValue(t, i, r);
    }),
      (Ln.prototype.setOptional = function (t, e, i) {
        const r = e[i];
        void 0 !== r && this.setValue(t, i, r);
      }),
      (Ln.upload = function (t, e, i, r) {
        for (let s = 0, n = e.length; s !== n; ++s) {
          const n = e[s],
            a = i[n.id];
          !1 !== a.needsUpdate && n.setValue(t, a.value, r);
        }
      }),
      (Ln.seqWithValue = function (t, e) {
        const i = [];
        for (let r = 0, s = t.length; r !== s; ++r) {
          const s = t[r];
          s.id in e && i.push(s);
        }
        return i;
      });
    let zn = 0;
    function Pn(t, e, i) {
      const r = t.getShaderParameter(e, t.COMPILE_STATUS),
        s = t.getShaderInfoLog(e).trim();
      return r && "" === s
        ? ""
        : "THREE.WebGLShader: gl.getShaderInfoLog() " +
            i +
            "\n" +
            s +
            (function (t) {
              const e = t.split("\n");
              for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
              return e.join("\n");
            })(t.getShaderSource(e));
    }
    function Nn(t, e, i, r) {
      const s = t.getContext();
      i.vertexShader, i.fragmentShader;
      const n = s.createProgram(),
        a = i.vertexShader,
        o = i.fragmentShader,
        h = /(^|\n)\s*#version \d/;
      if (!h.test(a || "") || !h.test(o || ""))
        throw new Error(
          "Shaders should be pre-built in this fork and include GLSL version",
        );
      const l = Fn(s, s.VERTEX_SHADER, a),
        u = Fn(s, s.FRAGMENT_SHADER, o);
      if (
        (s.attachShader(n, l),
        s.attachShader(n, u),
        void 0 !== i.index0AttributeName
          ? s.bindAttribLocation(n, 0, i.index0AttributeName)
          : !0 === i.morphTargets && s.bindAttribLocation(n, 0, "position"),
        s.linkProgram(n),
        t.debug.checkShaderErrors)
      ) {
        const t = s.getProgramInfoLog(n).trim(),
          e = s.getShaderInfoLog(l).trim(),
          i = s.getShaderInfoLog(u).trim();
        let r = !0,
          a = !0;
        if (!1 === s.getProgramParameter(n, s.LINK_STATUS)) {
          r = !1;
          const e = Pn(s, l, "vertex"),
            i = Pn(s, u, "fragment");
          console.error(
            "THREE.WebGLProgram: shader error: ",
            s.getError(),
            "gl.VALIDATE_STATUS",
            s.getProgramParameter(n, s.VALIDATE_STATUS),
            "gl.getProgramInfoLog",
            t,
            e,
            i,
          );
        } else
          "" !== t
            ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t)
            : ("" !== e && "" !== i) || (a = !1);
        a &&
          (this.diagnostics = {
            runnable: r,
            programLog: t,
            vertexShader: { log: e },
            fragmentShader: { log: i },
          });
      }
      let c, p;
      return (
        s.deleteShader(l),
        s.deleteShader(u),
        (this.getUniforms = function () {
          return void 0 === c && (c = new Ln(s, n)), c;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === p &&
              (p = (function (t, e) {
                const i = {},
                  r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                for (let s = 0; s < r; s++) {
                  const r = t.getActiveAttrib(e, s).name;
                  i[r] = t.getAttribLocation(e, r);
                }
                return i;
              })(s, n)),
            p
          );
        }),
        (this.destroy = function () {
          r.releaseStatesOfProgram(this),
            s.deleteProgram(n),
            (this.program = void 0);
        }),
        (this.name = i.shaderName),
        (this.id = zn++),
        (this.cacheKey = e),
        (this.usedTimes = 1),
        (this.program = n),
        (this.vertexShader = l),
        (this.fragmentShader = u),
        this
      );
    }
    function Un(t, e, i, r, s, n) {
      const a = [],
        o = r.isWebGL2,
        h = r.logarithmicDepthBuffer,
        l = r.floatVertexTextures,
        u = r.maxVertexUniforms,
        c = r.vertexTextures;
      let p = r.precision;
      const d = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        },
        m = [
          "precision",
          "isWebGL2",
          "supportsVertexTextures",
          "outputEncoding",
          "instancing",
          "instancingColor",
          "map",
          "mapEncoding",
          "matcap",
          "matcapEncoding",
          "envMap",
          "envMapMode",
          "envMapEncoding",
          "envMapCubeUV",
          "lightMap",
          "lightMapEncoding",
          "aoMap",
          "emissiveMap",
          "emissiveMapEncoding",
          "bumpMap",
          "normalMap",
          "objectSpaceNormalMap",
          "tangentSpaceNormalMap",
          "clearcoatMap",
          "clearcoatRoughnessMap",
          "clearcoatNormalMap",
          "displacementMap",
          "specularMap",
          "roughnessMap",
          "metalnessMap",
          "gradientMap",
          "alphaMap",
          "combine",
          "vertexColors",
          "vertexTangents",
          "vertexUvs",
          "uvsVertexOnly",
          "fog",
          "useFog",
          "fogExp2",
          "flatShading",
          "sizeAttenuation",
          "logarithmicDepthBuffer",
          "skinning",
          "maxBones",
          "useVertexTexture",
          "morphTargets",
          "morphNormals",
          "maxMorphTargets",
          "maxMorphNormals",
          "premultipliedAlpha",
          "numDirLights",
          "numPointLights",
          "numSpotLights",
          "numHemiLights",
          "numRectAreaLights",
          "numDirLightShadows",
          "numPointLightShadows",
          "numSpotLightShadows",
          "shadowMapEnabled",
          "shadowMapType",
          "toneMapping",
          "physicallyCorrectLights",
          "alphaTest",
          "doubleSided",
          "flipSided",
          "numClippingPlanes",
          "numClipIntersection",
          "depthPacking",
          "dithering",
          "sheen",
          "transmissionMap",
        ];
      function f(t) {
        let e;
        return (
          t
            ? t.isTexture
              ? (e = t.encoding)
              : t.isWebGLRenderTarget &&
                (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.",
                ),
                (e = t.texture.encoding))
            : (e = ai),
          e
        );
      }
      return {
        getParameters: function (s, a, m, g, y) {
          const x = g.fog,
            b = s.isMeshStandardMaterial ? g.environment : null,
            v = e.get(s.envMap || b),
            M = d[s.type],
            w = y.isSkinnedMesh
              ? (function (t) {
                  const e = t.skeleton.bones;
                  if (l) return 1024;
                  {
                    const t = u,
                      i = Math.floor((t - 20) / 4),
                      r = Math.min(i, e.length);
                    return r < e.length
                      ? (console.warn(
                          "THREE.WebGLRenderer: Skeleton has " +
                            e.length +
                            " bones. This GPU supports " +
                            r +
                            ".",
                        ),
                        0)
                      : r;
                  }
                })(y)
              : 0;
          let _, E;
          if (
            (null !== s.precision &&
              (p = r.getMaxPrecision(s.precision)) !== s.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                s.precision,
                "not supported, using",
                p,
                "instead.",
              ),
            M)
          ) {
            const t = cs[M];
            (_ = t.vertexShader), (E = t.fragmentShader);
          } else (_ = s.vertexShader), (E = s.fragmentShader);
          const T = t.getRenderTarget();
          return {
            isWebGL2: o,
            shaderID: M,
            shaderName: s.type,
            vertexShader: _,
            fragmentShader: E,
            defines: s.defines,
            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
            glslVersion: s.glslVersion,
            precision: p,
            instancing: !0 === y.isInstancedMesh,
            instancingColor:
              !0 === y.isInstancedMesh && null !== y.instanceColor,
            supportsVertexTextures: c,
            outputEncoding: null !== T ? f(T.texture) : t.outputEncoding,
            map: !!s.map,
            mapEncoding: f(s.map),
            matcap: !!s.matcap,
            matcapEncoding: f(s.matcap),
            envMap: !!v,
            envMapMode: v && v.mapping,
            envMapEncoding: f(v),
            envMapCubeUV: !!v && (v.mapping === Dt || v.mapping === It),
            lightMap: !!s.lightMap,
            lightMapEncoding: f(s.lightMap),
            aoMap: !!s.aoMap,
            emissiveMap: !!s.emissiveMap,
            emissiveMapEncoding: f(s.emissiveMap),
            bumpMap: !!s.bumpMap,
            normalMap: !!s.normalMap,
            objectSpaceNormalMap: s.normalMapType === ui,
            tangentSpaceNormalMap: s.normalMapType === li,
            clearcoatMap: !!s.clearcoatMap,
            clearcoatRoughnessMap: !!s.clearcoatRoughnessMap,
            clearcoatNormalMap: !!s.clearcoatNormalMap,
            displacementMap: !!s.displacementMap,
            roughnessMap: !!s.roughnessMap,
            metalnessMap: !!s.metalnessMap,
            specularMap: !!s.specularMap,
            alphaMap: !!s.alphaMap,
            gradientMap: !!s.gradientMap,
            sheen: !!s.sheen,
            transmissionMap: !!s.transmissionMap,
            combine: s.combine,
            vertexTangents: s.normalMap && s.vertexTangents,
            vertexColors: s.vertexColors,
            vertexUvs: !!(
              s.map ||
              s.bumpMap ||
              s.normalMap ||
              s.specularMap ||
              s.alphaMap ||
              s.emissiveMap ||
              s.roughnessMap ||
              s.metalnessMap ||
              s.clearcoatMap ||
              s.clearcoatRoughnessMap ||
              s.clearcoatNormalMap ||
              s.displacementMap ||
              s.transmissionMap
            ),
            uvsVertexOnly: !(
              s.map ||
              s.bumpMap ||
              s.normalMap ||
              s.specularMap ||
              s.alphaMap ||
              s.emissiveMap ||
              s.roughnessMap ||
              s.metalnessMap ||
              s.clearcoatNormalMap ||
              s.transmissionMap ||
              !s.displacementMap
            ),
            fog: !!x,
            useFog: s.fog,
            fogExp2: x && x.isFogExp2,
            flatShading: s.flatShading,
            sizeAttenuation: s.sizeAttenuation,
            logarithmicDepthBuffer: h,
            skinning: s.skinning && w > 0,
            maxBones: w,
            useVertexTexture: l,
            morphTargets: s.morphTargets,
            morphNormals: s.morphNormals,
            maxMorphTargets: t.maxMorphTargets,
            maxMorphNormals: t.maxMorphNormals,
            numDirLights: a.directional.length,
            numPointLights: a.point.length,
            numSpotLights: a.spot.length,
            numRectAreaLights: a.rectArea.length,
            numHemiLights: a.hemi.length,
            numDirLightShadows: a.directionalShadowMap.length,
            numPointLightShadows: a.pointShadowMap.length,
            numSpotLightShadows: a.spotShadowMap.length,
            numClippingPlanes: n.numPlanes,
            numClipIntersection: n.numIntersection,
            dithering: s.dithering,
            shadowMapEnabled: t.shadowMap.enabled && m.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: s.toneMapped ? t.toneMapping : Nt,
            physicallyCorrectLights: t.physicallyCorrectLights,
            premultipliedAlpha: s.premultipliedAlpha,
            alphaTest: s.alphaTest,
            doubleSided: s.side === et,
            flipSided: s.side === tt,
            depthPacking: void 0 !== s.depthPacking && s.depthPacking,
            index0AttributeName: s.index0AttributeName,
            extensionDerivatives: s.extensions && s.extensions.derivatives,
            extensionFragDepth: s.extensions && s.extensions.fragDepth,
            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
            extensionShaderTextureLOD:
              s.extensions && s.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: o || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: o || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              o || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: s.customProgramCacheKey(),
          };
        },
        getProgramCacheKey: function (e) {
          const i = [];
          if (
            (e.shaderID
              ? i.push(e.shaderID)
              : (i.push(e.fragmentShader), i.push(e.vertexShader)),
            void 0 !== e.defines)
          )
            for (const t in e.defines) i.push(t), i.push(e.defines[t]);
          if (!1 === e.isRawShaderMaterial) {
            for (let t = 0; t < m.length; t++) i.push(e[m[t]]);
            i.push(t.outputEncoding), i.push(t.gammaFactor);
          }
          return i.push(e.customProgramCacheKey), i.join();
        },
        getUniforms: function (t) {
          const e = d[t.type];
          let i;
          if (e) {
            const t = cs[e];
            i = Mr.clone(t.uniforms);
          } else i = t.uniforms;
          return i;
        },
        acquireProgram: function (e, i) {
          let r;
          for (let t = 0, e = a.length; t < e; t++) {
            const e = a[t];
            if (e.cacheKey === i) {
              ++(r = e).usedTimes;
              break;
            }
          }
          return void 0 === r && ((r = new Nn(t, i, e, s)), a.push(r)), r;
        },
        releaseProgram: function (t) {
          if (0 == --t.usedTimes) {
            const e = a.indexOf(t);
            (a[e] = a[a.length - 1]), a.pop(), t.destroy();
          }
        },
        programs: a,
      };
    }
    function Bn() {
      let t = new WeakMap();
      return {
        get: function (e) {
          let i = t.get(e);
          return void 0 === i && ((i = {}), t.set(e, i)), i;
        },
        remove: function (e) {
          t.delete(e);
        },
        update: function (e, i, r) {
          t.get(e)[i] = r;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Cn(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.program !== e.program
        ? t.program.id - e.program.id
        : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
        ? t.z - e.z
        : t.id - e.id;
    }
    function On(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id;
    }
    function Dn(t) {
      const e = [];
      let i = 0;
      const r = [],
        s = [],
        n = { id: -1 };
      function a(r, s, a, o, h, l) {
        let u = e[i];
        const c = t.get(a);
        return (
          void 0 === u
            ? ((u = {
                id: r.id,
                object: r,
                geometry: s,
                material: a,
                program: c.program || n,
                groupOrder: o,
                renderOrder: r.renderOrder,
                z: h,
                group: l,
              }),
              (e[i] = u))
            : ((u.id = r.id),
              (u.object = r),
              (u.geometry = s),
              (u.material = a),
              (u.program = c.program || n),
              (u.groupOrder = o),
              (u.renderOrder = r.renderOrder),
              (u.z = h),
              (u.group = l)),
          i++,
          u
        );
      }
      return {
        opaque: r,
        transparent: s,
        init: function () {
          (i = 0), (r.length = 0), (s.length = 0);
        },
        push: function (t, e, i, n, o, h) {
          const l = a(t, e, i, n, o, h);
          (!0 === i.transparent ? s : r).push(l);
        },
        unshift: function (t, e, i, n, o, h) {
          const l = a(t, e, i, n, o, h);
          (!0 === i.transparent ? s : r).unshift(l);
        },
        finish: function () {
          for (let t = i, r = e.length; t < r; t++) {
            const i = e[t];
            if (null === i.id) break;
            (i.id = null),
              (i.object = null),
              (i.geometry = null),
              (i.material = null),
              (i.program = null),
              (i.group = null);
          }
        },
        sort: function (t, e) {
          r.length > 1 && r.sort(t || Cn), s.length > 1 && s.sort(e || On);
        },
      };
    }
    function In(t) {
      let e = new WeakMap();
      return {
        get: function (i, r) {
          const s = e.get(i);
          let n;
          return (
            void 0 === s
              ? ((n = new Dn(t)), e.set(i, new WeakMap()), e.get(i).set(r, n))
              : void 0 === (n = s.get(r)) && ((n = new Dn(t)), s.set(r, n)),
            n
          );
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }
    function kn() {
      const t = {};
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let i;
          switch (e.type) {
            case "DirectionalLight":
              i = { direction: new h(), color: new q() };
              break;
            case "SpotLight":
              i = {
                position: new h(),
                direction: new h(),
                color: new q(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
              };
              break;
            case "PointLight":
              i = { position: new h(), color: new q(), distance: 0, decay: 0 };
              break;
            case "HemisphereLight":
              i = {
                direction: new h(),
                skyColor: new q(),
                groundColor: new q(),
              };
              break;
            case "RectAreaLight":
              i = {
                color: new q(),
                position: new h(),
                halfWidth: new h(),
                halfHeight: new h(),
              };
          }
          return (t[e.id] = i), i;
        },
      };
    }
    let Gn = 0;
    function Wn(t, e) {
      return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
    }
    function Vn() {
      const t = new kn(),
        e = (function () {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let i;
              switch (e.type) {
                case "DirectionalLight":
                case "SpotLight":
                  i = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new mi(),
                  };
                  break;
                case "PointLight":
                  i = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new mi(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (t[e.id] = i), i;
            },
          };
        })(),
        i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
        };
      for (let t = 0; t < 9; t++) i.probe.push(new h());
      const r = new h(),
        s = new c(),
        n = new c();
      return {
        setup: function (a, o, h) {
          let l = 0,
            u = 0,
            c = 0;
          for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
          let p = 0,
            d = 0,
            m = 0,
            f = 0,
            g = 0,
            y = 0,
            x = 0,
            b = 0;
          const v = h.matrixWorldInverse;
          a.sort(Wn);
          for (let o = 0, h = a.length; o < h; o++) {
            const h = a[o],
              M = h.color,
              w = h.intensity,
              _ = h.distance,
              E = h.shadow && h.shadow.map ? h.shadow.map.texture : null;
            if (h.isAmbientLight)
              (l += M.r * w), (u += M.g * w), (c += M.b * w);
            else if (h.isLightProbe)
              for (let t = 0; t < 9; t++)
                i.probe[t].addScaledVector(h.sh.coefficients[t], w);
            else if (h.isDirectionalLight) {
              const s = t.get(h);
              if (
                (s.color.copy(h.color).multiplyScalar(h.intensity),
                s.direction.setFromMatrixPosition(h.matrixWorld),
                r.setFromMatrixPosition(h.target.matrixWorld),
                s.direction.sub(r),
                s.direction.transformDirection(v),
                h.castShadow)
              ) {
                const t = h.shadow,
                  r = e.get(h);
                (r.shadowBias = t.bias),
                  (r.shadowNormalBias = t.normalBias),
                  (r.shadowRadius = t.radius),
                  (r.shadowMapSize = t.mapSize),
                  (i.directionalShadow[p] = r),
                  (i.directionalShadowMap[p] = E),
                  (i.directionalShadowMatrix[p] = h.shadow.matrix),
                  y++;
              }
              (i.directional[p] = s), p++;
            } else if (h.isSpotLight) {
              const s = t.get(h);
              if (
                (s.position.setFromMatrixPosition(h.matrixWorld),
                s.position.applyMatrix4(v),
                s.color.copy(M).multiplyScalar(w),
                (s.distance = _),
                s.direction.setFromMatrixPosition(h.matrixWorld),
                r.setFromMatrixPosition(h.target.matrixWorld),
                s.direction.sub(r),
                s.direction.transformDirection(v),
                (s.coneCos = Math.cos(h.angle)),
                (s.penumbraCos = Math.cos(h.angle * (1 - h.penumbra))),
                (s.decay = h.decay),
                h.castShadow)
              ) {
                const t = h.shadow,
                  r = e.get(h);
                (r.shadowBias = t.bias),
                  (r.shadowNormalBias = t.normalBias),
                  (r.shadowRadius = t.radius),
                  (r.shadowMapSize = t.mapSize),
                  (i.spotShadow[m] = r),
                  (i.spotShadowMap[m] = E),
                  (i.spotShadowMatrix[m] = h.shadow.matrix),
                  b++;
              }
              (i.spot[m] = s), m++;
            } else if (h.isRectAreaLight) {
              const e = t.get(h);
              e.color.copy(M).multiplyScalar(w),
                e.position.setFromMatrixPosition(h.matrixWorld),
                e.position.applyMatrix4(v),
                n.identity(),
                s.copy(h.matrixWorld),
                s.premultiply(v),
                n.extractRotation(s),
                e.halfWidth.set(0.5 * h.width, 0, 0),
                e.halfHeight.set(0, 0.5 * h.height, 0),
                e.halfWidth.applyMatrix4(n),
                e.halfHeight.applyMatrix4(n),
                (i.rectArea[f] = e),
                f++;
            } else if (h.isPointLight) {
              const r = t.get(h);
              if (
                (r.position.setFromMatrixPosition(h.matrixWorld),
                r.position.applyMatrix4(v),
                r.color.copy(h.color).multiplyScalar(h.intensity),
                (r.distance = h.distance),
                (r.decay = h.decay),
                h.castShadow)
              ) {
                const t = h.shadow,
                  r = e.get(h);
                (r.shadowBias = t.bias),
                  (r.shadowNormalBias = t.normalBias),
                  (r.shadowRadius = t.radius),
                  (r.shadowMapSize = t.mapSize),
                  (r.shadowCameraNear = t.camera.near),
                  (r.shadowCameraFar = t.camera.far),
                  (i.pointShadow[d] = r),
                  (i.pointShadowMap[d] = E),
                  (i.pointShadowMatrix[d] = h.shadow.matrix),
                  x++;
              }
              (i.point[d] = r), d++;
            } else if (h.isHemisphereLight) {
              const e = t.get(h);
              e.direction.setFromMatrixPosition(h.matrixWorld),
                e.direction.transformDirection(v),
                e.direction.normalize(),
                e.skyColor.copy(h.color).multiplyScalar(w),
                e.groundColor.copy(h.groundColor).multiplyScalar(w),
                (i.hemi[g] = e),
                g++;
            }
          }
          f > 0 && ((i.rectAreaLTC1 = ls.LTC_1), (i.rectAreaLTC2 = ls.LTC_2)),
            (i.ambient[0] = l),
            (i.ambient[1] = u),
            (i.ambient[2] = c);
          const M = i.hash;
          (M.directionalLength === p &&
            M.pointLength === d &&
            M.spotLength === m &&
            M.rectAreaLength === f &&
            M.hemiLength === g &&
            M.numDirectionalShadows === y &&
            M.numPointShadows === x &&
            M.numSpotShadows === b) ||
            ((i.directional.length = p),
            (i.spot.length = m),
            (i.rectArea.length = f),
            (i.point.length = d),
            (i.hemi.length = g),
            (i.directionalShadow.length = y),
            (i.directionalShadowMap.length = y),
            (i.pointShadow.length = x),
            (i.pointShadowMap.length = x),
            (i.spotShadow.length = b),
            (i.spotShadowMap.length = b),
            (i.directionalShadowMatrix.length = y),
            (i.pointShadowMatrix.length = x),
            (i.spotShadowMatrix.length = b),
            (M.directionalLength = p),
            (M.pointLength = d),
            (M.spotLength = m),
            (M.rectAreaLength = f),
            (M.hemiLength = g),
            (M.numDirectionalShadows = y),
            (M.numPointShadows = x),
            (M.numSpotShadows = b),
            (i.version = Gn++));
        },
        state: i,
      };
    }
    function Hn() {
      const t = new Vn(),
        e = [],
        i = [];
      return {
        init: function () {
          (e.length = 0), (i.length = 0);
        },
        state: { lightsArray: e, shadowsArray: i, lights: t },
        setupLights: function (r) {
          t.setup(e, i, r);
        },
        pushLight: function (t) {
          e.push(t);
        },
        pushShadow: function (t) {
          i.push(t);
        },
      };
    }
    function Xn() {
      let t = new WeakMap();
      return {
        get: function (e, i) {
          let r;
          return (
            !1 === t.has(e)
              ? ((r = new Hn()), t.set(e, new WeakMap()), t.get(e).set(i, r))
              : !1 === t.get(e).has(i)
              ? ((r = new Hn()), t.get(e).set(i, r))
              : (r = t.get(e).get(i)),
            r
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function jn(t) {
      xr.call(this),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = oi),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        this.setValues(t);
    }
    function qn(t) {
      xr.call(this),
        (this.type = "MeshDistanceMaterial"),
        (this.referencePosition = new h()),
        (this.nearDistance = 1),
        (this.farDistance = 1e3),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.fog = !1),
        this.setValues(t);
    }
    function Yn(t, e, i) {
      let r = new Vi();
      const s = new mi(),
        n = new mi(),
        a = new Hi(),
        o = [],
        h = [],
        l = {},
        u = { 0: tt, 1: $, 2: et },
        c = new wr({
          defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 1 / 8 },
          uniforms: {
            shadow_pass: { value: null },
            resolution: { value: new mi() },
            radius: { value: 4 },
          },
          vertexShader: null,
          fragmentShader: null,
        }),
        p = c.clone();
      p.defines.HORIZONAL_PASS = 1;
      const d = new mr();
      d.setAttribute(
        "position",
        new Zi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
      );
      const m = new as(d, c),
        f = this;
      function g(i, r) {
        const s = e.update(m);
        (c.uniforms.shadow_pass.value = i.map.texture),
          (c.uniforms.resolution.value = i.mapSize),
          (c.uniforms.radius.value = i.radius),
          t.setRenderTarget(i.mapPass),
          t.clear(),
          t.renderBufferDirect(r, null, s, c, m, null),
          (p.uniforms.shadow_pass.value = i.mapPass.texture),
          (p.uniforms.resolution.value = i.mapSize),
          (p.uniforms.radius.value = i.radius),
          t.setRenderTarget(i.map),
          t.clear(),
          t.renderBufferDirect(r, null, s, p, m, null);
      }
      function y(t, e, i) {
        const r = (t << 0) | (e << 1) | (i << 2);
        let s = o[r];
        return (
          void 0 === s &&
            ((s = new jn({ depthPacking: hi, morphTargets: t, skinning: e })),
            (o[r] = s)),
          s
        );
      }
      function x(t, e, i) {
        const r = (t << 0) | (e << 1) | (i << 2);
        let s = h[r];
        return (
          void 0 === s &&
            ((s = new qn({ morphTargets: t, skinning: e })), (h[r] = s)),
          s
        );
      }
      function b(e, i, r, s, n, a, o) {
        let h = null,
          c = y,
          p = e.customDepthMaterial;
        if (
          (!0 === s.isPointLight && ((c = x), (p = e.customDistanceMaterial)),
          void 0 === p)
        ) {
          let t = !1;
          !0 === r.morphTargets &&
            (t =
              i.morphAttributes &&
              i.morphAttributes.position &&
              i.morphAttributes.position.length > 0);
          let s = !1;
          !0 === e.isSkinnedMesh &&
            (!0 === r.skinning
              ? (s = !0)
              : console.warn(
                  "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                  e,
                )),
            (h = c(t, s, !0 === e.isInstancedMesh));
        } else h = p;
        if (
          t.localClippingEnabled &&
          !0 === r.clipShadows &&
          0 !== r.clippingPlanes.length
        ) {
          const t = h.uuid,
            e = r.uuid;
          let i = l[t];
          void 0 === i && ((i = {}), (l[t] = i));
          let s = i[e];
          void 0 === s && ((s = h.clone()), (i[e] = s)), (h = s);
        }
        return (
          (h.visible = r.visible),
          (h.wireframe = r.wireframe),
          (h.side =
            o === K
              ? null !== r.shadowSide
                ? r.shadowSide
                : r.side
              : null !== r.shadowSide
              ? r.shadowSide
              : u[r.side]),
          (h.clipShadows = r.clipShadows),
          (h.clippingPlanes = r.clippingPlanes),
          (h.clipIntersection = r.clipIntersection),
          (h.wireframeLinewidth = r.wireframeLinewidth),
          (h.linewidth = r.linewidth),
          !0 === s.isPointLight &&
            !0 === h.isMeshDistanceMaterial &&
            (h.referencePosition.setFromMatrixPosition(s.matrixWorld),
            (h.nearDistance = n),
            (h.farDistance = a)),
          h
        );
      }
      function v(i, s, n, a, o) {
        if (!1 === i.visible) return;
        if (
          i.layers.test(s.layers) &&
          (i.isMesh || i.isLine || i.isPoints) &&
          (i.castShadow || (i.receiveShadow && o === K)) &&
          (!i.frustumCulled || r.intersectsObject(i))
        ) {
          i.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            i.matrixWorld,
          );
          const r = e.update(i),
            s = i.material;
          if (Array.isArray(s)) {
            const e = r.groups;
            for (let h = 0, l = e.length; h < l; h++) {
              const l = e[h],
                u = s[l.materialIndex];
              if (u && u.visible) {
                const e = b(i, r, u, a, n.near, n.far, o);
                t.renderBufferDirect(n, null, r, e, i, l);
              }
            }
          } else if (s.visible) {
            const e = b(i, r, s, a, n.near, n.far, o);
            t.renderBufferDirect(n, null, r, e, i, null);
          }
        }
        const h = i.children;
        for (let t = 0, e = h.length; t < e; t++) v(h[t], s, n, a, o);
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = Q),
        (this.render = function (e, o, h) {
          if (!1 === f.enabled) return;
          if (!1 === f.autoUpdate && !1 === f.needsUpdate) return;
          if (0 === e.length) return;
          const l = t.getRenderTarget(),
            u = t.getActiveCubeFace(),
            c = t.getActiveMipmapLevel(),
            p = t.state;
          p.setBlending(it),
            p.buffers.color.setClear(1, 1, 1, 1),
            p.buffers.depth.setTest(!0),
            p.setScissorTest(!1);
          for (let l = 0, u = e.length; l < u; l++) {
            const u = e[l],
              c = u.shadow;
            if (void 0 === c) {
              console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
              continue;
            }
            if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
            s.copy(c.mapSize);
            const d = c.getFrameExtents();
            if (
              (s.multiply(d),
              n.copy(c.mapSize),
              (s.x > i || s.y > i) &&
                (s.x > i &&
                  ((n.x = Math.floor(i / d.x)),
                  (s.x = n.x * d.x),
                  (c.mapSize.x = n.x)),
                s.y > i &&
                  ((n.y = Math.floor(i / d.y)),
                  (s.y = n.y * d.y),
                  (c.mapSize.y = n.y))),
              null === c.map && !c.isPointLightShadow && this.type === K)
            ) {
              const t = { minFilter: jt, magFilter: jt, format: le };
              (c.map = new ys(s.x, s.y, t)),
                (c.map.texture.name = u.name + ".shadowMap"),
                (c.mapPass = new ys(s.x, s.y, t)),
                c.camera.updateProjectionMatrix();
            }
            if (null === c.map) {
              const t = { minFilter: Vt, magFilter: Vt, format: le };
              (c.map = new ys(s.x, s.y, t)),
                (c.map.texture.name = u.name + ".shadowMap"),
                c.camera.updateProjectionMatrix();
            }
            t.setRenderTarget(c.map), t.clear();
            const m = c.getViewportCount();
            for (let t = 0; t < m; t++) {
              const e = c.getViewport(t);
              a.set(n.x * e.x, n.y * e.y, n.x * e.z, n.y * e.w),
                p.viewport(a),
                c.updateMatrices(u, t),
                (r = c.getFrustum()),
                v(o, h, c.camera, u, this.type);
            }
            c.isPointLightShadow || this.type !== K || g(c, h),
              (c.needsUpdate = !1);
          }
          (f.needsUpdate = !1), t.setRenderTarget(l, u, c);
        });
    }
    function Zn(t, e, i) {
      const r = i.isWebGL2;
      const s = new (function () {
          let e = !1;
          const i = new Hi();
          let r = null;
          const s = new Hi(0, 0, 0, 0);
          return {
            setMask: function (i) {
              r === i || e || (t.colorMask(i, i, i, i), (r = i));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e, r, n, a, o) {
              !0 === o && ((e *= a), (r *= a), (n *= a)),
                i.set(e, r, n, a),
                !1 === s.equals(i) && (t.clearColor(e, r, n, a), s.copy(i));
            },
            reset: function () {
              (e = !1), (r = null), s.set(-1, 0, 0, 0);
            },
          };
        })(),
        n = new (function () {
          let e = !1,
            i = null,
            r = null,
            s = null;
          return {
            setTest: function (e) {
              e ? N(t.DEPTH_TEST) : U(t.DEPTH_TEST);
            },
            setMask: function (r) {
              i === r || e || (t.depthMask(r), (i = r));
            },
            setFunc: function (e) {
              if (r !== e) {
                if (e)
                  switch (e) {
                    case Et:
                      t.depthFunc(t.NEVER);
                      break;
                    case Tt:
                      t.depthFunc(t.ALWAYS);
                      break;
                    case St:
                      t.depthFunc(t.LESS);
                      break;
                    case At:
                      t.depthFunc(t.LEQUAL);
                      break;
                    case Rt:
                      t.depthFunc(t.EQUAL);
                      break;
                    case Lt:
                      t.depthFunc(t.GEQUAL);
                      break;
                    case Ft:
                      t.depthFunc(t.GREATER);
                      break;
                    case zt:
                      t.depthFunc(t.NOTEQUAL);
                      break;
                    default:
                      t.depthFunc(t.LEQUAL);
                  }
                else t.depthFunc(t.LEQUAL);
                r = e;
              }
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              s !== e && (t.clearDepth(e), (s = e));
            },
            reset: function () {
              (e = !1), (i = null), (r = null), (s = null);
            },
          };
        })(),
        a = new (function () {
          let e = !1,
            i = null,
            r = null,
            s = null,
            n = null,
            a = null,
            o = null,
            h = null,
            l = null;
          return {
            setTest: function (i) {
              e || (i ? N(t.STENCIL_TEST) : U(t.STENCIL_TEST));
            },
            setMask: function (r) {
              i === r || e || (t.stencilMask(r), (i = r));
            },
            setFunc: function (e, i, a) {
              (r === e && s === i && n === a) ||
                (t.stencilFunc(e, i, a), (r = e), (s = i), (n = a));
            },
            setOp: function (e, i, r) {
              (a === e && o === i && h === r) ||
                (t.stencilOp(e, i, r), (a = e), (o = i), (h = r));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              l !== e && (t.clearStencil(e), (l = e));
            },
            reset: function () {
              (e = !1),
                (i = null),
                (r = null),
                (s = null),
                (n = null),
                (a = null),
                (o = null),
                (h = null),
                (l = null);
            },
          };
        })();
      let o = {},
        h = null,
        l = null,
        u = null,
        c = null,
        p = null,
        d = null,
        m = null,
        f = null,
        g = null,
        y = !1,
        x = null,
        b = null,
        v = null,
        M = null,
        w = null;
      const _ = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      let E = !1,
        T = 0;
      const S = t.getParameter(t.VERSION);
      -1 !== S.indexOf("WebGL")
        ? ((T = parseFloat(/^WebGL\ ([0-9])/.exec(S)[1])), (E = T >= 1))
        : -1 !== S.indexOf("OpenGL ES") &&
          ((T = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(S)[1])), (E = T >= 2));
      let A = null,
        R = {};
      const L = new Hi(),
        F = new Hi();
      function z(e, i, r) {
        const s = new Uint8Array(4),
          n = t.createTexture();
        t.bindTexture(e, n),
          t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
          t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
        for (let e = 0; e < r; e++)
          t.texImage2D(i + e, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, s);
        return n;
      }
      const P = {};
      function N(e) {
        !0 !== o[e] && (t.enable(e), (o[e] = !0));
      }
      function U(e) {
        !1 !== o[e] && (t.disable(e), (o[e] = !1));
      }
      (P[t.TEXTURE_2D] = z(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
        (P[t.TEXTURE_CUBE_MAP] = z(
          t.TEXTURE_CUBE_MAP,
          t.TEXTURE_CUBE_MAP_POSITIVE_X,
          6,
        )),
        s.setClear(0, 0, 0, 1),
        n.setClear(1),
        a.setClear(0),
        N(t.DEPTH_TEST),
        n.setFunc(At),
        D(!1),
        I(Z),
        N(t.CULL_FACE),
        O(it);
      const B = {
        [ht]: t.FUNC_ADD,
        [lt]: t.FUNC_SUBTRACT,
        [ut]: t.FUNC_REVERSE_SUBTRACT,
      };
      if (r) (B[ct] = t.MIN), (B[pt] = t.MAX);
      else {
        const t = e.get("EXT_blend_minmax");
        null !== t && ((B[ct] = t.MIN_EXT), (B[pt] = t.MAX_EXT));
      }
      const C = {
        [dt]: t.ZERO,
        [mt]: t.ONE,
        [ft]: t.SRC_COLOR,
        [yt]: t.SRC_ALPHA,
        [_t]: t.SRC_ALPHA_SATURATE,
        [Mt]: t.DST_COLOR,
        [bt]: t.DST_ALPHA,
        [gt]: t.ONE_MINUS_SRC_COLOR,
        [xt]: t.ONE_MINUS_SRC_ALPHA,
        [wt]: t.ONE_MINUS_DST_COLOR,
        [vt]: t.ONE_MINUS_DST_ALPHA,
      };
      function O(e, i, r, s, n, a, o, h) {
        if (e !== it) {
          if ((l || (N(t.BLEND), (l = !0)), e === ot))
            (n = n || i),
              (a = a || r),
              (o = o || s),
              (i === c && n === m) ||
                (t.blendEquationSeparate(B[i], B[n]), (c = i), (m = n)),
              (r === p && s === d && a === f && o === g) ||
                (t.blendFuncSeparate(C[r], C[s], C[a], C[o]),
                (p = r),
                (d = s),
                (f = a),
                (g = o)),
              (u = e),
              (y = null);
          else if (e !== u || h !== y) {
            if (
              ((c === ht && m === ht) ||
                (t.blendEquation(t.FUNC_ADD), (c = ht), (m = ht)),
              h)
            )
              switch (e) {
                case rt:
                  t.blendFuncSeparate(
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA,
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA,
                  );
                  break;
                case st:
                  t.blendFunc(t.ONE, t.ONE);
                  break;
                case nt:
                  t.blendFuncSeparate(
                    t.ZERO,
                    t.ZERO,
                    t.ONE_MINUS_SRC_COLOR,
                    t.ONE_MINUS_SRC_ALPHA,
                  );
                  break;
                case at:
                  t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            else
              switch (e) {
                case rt:
                  t.blendFuncSeparate(
                    t.SRC_ALPHA,
                    t.ONE_MINUS_SRC_ALPHA,
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA,
                  );
                  break;
                case st:
                  t.blendFunc(t.SRC_ALPHA, t.ONE);
                  break;
                case nt:
                  t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR);
                  break;
                case at:
                  t.blendFunc(t.ZERO, t.SRC_COLOR);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            (p = null), (d = null), (f = null), (g = null), (u = e), (y = h);
          }
        } else l && (U(t.BLEND), (l = !1));
      }
      function D(e) {
        x !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (x = e));
      }
      function I(e) {
        e !== Y
          ? (N(t.CULL_FACE),
            e !== b &&
              (e === Z
                ? t.cullFace(t.BACK)
                : e === J
                ? t.cullFace(t.FRONT)
                : t.cullFace(t.FRONT_AND_BACK)))
          : U(t.CULL_FACE),
          (b = e);
      }
      function k(e, i, r) {
        e
          ? (N(t.POLYGON_OFFSET_FILL),
            (M === i && w === r) || (t.polygonOffset(i, r), (M = i), (w = r)))
          : U(t.POLYGON_OFFSET_FILL);
      }
      function G(e) {
        void 0 === e && (e = t.TEXTURE0 + _ - 1),
          A !== e && (t.activeTexture(e), (A = e));
      }
      return {
        buffers: { color: s, depth: n, stencil: a },
        enable: N,
        disable: U,
        useProgram: function (e) {
          return h !== e && (t.useProgram(e), (h = e), !0);
        },
        setBlending: O,
        setMaterial: function (e, i) {
          e.side === et ? U(t.CULL_FACE) : N(t.CULL_FACE);
          let r = e.side === tt;
          i && (r = !r),
            D(r),
            e.blending === rt && !1 === e.transparent
              ? O(it)
              : O(
                  e.blending,
                  e.blendEquation,
                  e.blendSrc,
                  e.blendDst,
                  e.blendEquationAlpha,
                  e.blendSrcAlpha,
                  e.blendDstAlpha,
                  e.premultipliedAlpha,
                ),
            n.setFunc(e.depthFunc),
            n.setTest(e.depthTest),
            n.setMask(e.depthWrite),
            s.setMask(e.colorWrite);
          const o = e.stencilWrite;
          a.setTest(o),
            o &&
              (a.setMask(e.stencilWriteMask),
              a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
              a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            k(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
        },
        setFlipSided: D,
        setCullFace: I,
        setLineWidth: function (e) {
          e !== v && (E && t.lineWidth(e), (v = e));
        },
        setPolygonOffset: k,
        setScissorTest: function (e) {
          e ? N(t.SCISSOR_TEST) : U(t.SCISSOR_TEST);
        },
        activeTexture: G,
        bindTexture: function (e, i) {
          null === A && G();
          let r = R[A];
          void 0 === r && ((r = { type: void 0, texture: void 0 }), (R[A] = r)),
            (r.type === e && r.texture === i) ||
              (t.bindTexture(e, i || P[e]), (r.type = e), (r.texture = i));
        },
        unbindTexture: function () {
          const e = R[A];
          void 0 !== e &&
            void 0 !== e.type &&
            (t.bindTexture(e.type, null),
            (e.type = void 0),
            (e.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            t.compressedTexImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage2D: function () {
          try {
            t.texImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage3D: function () {
          try {
            t.texImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        scissor: function (e) {
          !1 === L.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), L.copy(e));
        },
        viewport: function (e) {
          !1 === F.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), F.copy(e));
        },
        reset: function () {
          (o = {}),
            (A = null),
            (R = {}),
            (h = null),
            (u = null),
            (x = null),
            (b = null),
            s.reset(),
            n.reset(),
            a.reset();
        },
      };
    }
    function Jn(t, e, i, r, s, n, o) {
      const h = s.isWebGL2,
        l = s.maxTextures,
        u = s.maxCubemapSize,
        c = s.maxTextureSize,
        p = s.maxSamples,
        d = new WeakMap();
      let m,
        f = !1;
      try {
        f =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (t) {}
      function g(t, e) {
        return f
          ? new OffscreenCanvas(t, e)
          : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function y(t, e, i, r) {
        let s = 1;
        if (
          ((t.width > r || t.height > r) &&
            (s = r / Math.max(t.width, t.height)),
          s < 1 || !0 === e)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            const r = e ? a.floorPowerOfTwo : Math.floor,
              n = r(s * t.width),
              o = r(s * t.height);
            void 0 === m && (m = g(n, o));
            const h = i ? g(n, o) : m;
            return (
              (h.width = n),
              (h.height = o),
              h.getContext("2d").drawImage(t, 0, 0, n, o),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  t.width +
                  "x" +
                  t.height +
                  ") to (" +
                  n +
                  "x" +
                  o +
                  ").",
              ),
              h
            );
          }
          return (
            "data" in t &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  ").",
              ),
            t
          );
        }
        return t;
      }
      function x(t) {
        return a.isPowerOfTwo(t.width) && a.isPowerOfTwo(t.height);
      }
      function b(t, e) {
        return (
          t.generateMipmaps && e && t.minFilter !== Vt && t.minFilter !== jt
        );
      }
      function v(e, i, s, n) {
        t.generateMipmap(e),
          (r.get(i).__maxMipLevel = Math.log(Math.max(s, n)) * Math.LOG2E);
      }
      function M(i, r, s) {
        if (!1 === h) return r;
        if (null !== i) {
          if (void 0 !== t[i]) return t[i];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              i +
              "'",
          );
        }
        let n = r;
        return (
          r === t.RED &&
            (s === t.FLOAT && (n = t.R32F),
            s === t.HALF_FLOAT && (n = t.R16F),
            s === t.UNSIGNED_BYTE && (n = t.R8)),
          r === t.RGB &&
            (s === t.FLOAT && (n = t.RGB32F),
            s === t.HALF_FLOAT && (n = t.RGB16F),
            s === t.UNSIGNED_BYTE && (n = t.RGB8)),
          r === t.RGBA &&
            (s === t.FLOAT && (n = t.RGBA32F),
            s === t.HALF_FLOAT && (n = t.RGBA16F),
            s === t.UNSIGNED_BYTE && (n = t.RGBA8)),
          (n !== t.R16F &&
            n !== t.R32F &&
            n !== t.RGBA16F &&
            n !== t.RGBA32F) ||
            e.get("EXT_color_buffer_float"),
          n
        );
      }
      function w(e) {
        return e === Vt || e === Ht || e === Xt ? t.NEAREST : t.LINEAR;
      }
      function _(e) {
        const i = e.target;
        i.removeEventListener("dispose", _),
          (function (e) {
            const i = r.get(e);
            if (void 0 === i.__webglInit) return;
            t.deleteTexture(i.__webglTexture), r.remove(e);
          })(i),
          i.isVideoTexture && d.delete(i),
          o.memory.textures--;
      }
      function E(e) {
        const i = e.target;
        i.removeEventListener("dispose", E),
          (function (e) {
            const i = r.get(e),
              s = r.get(e.texture);
            if (!e) return;
            void 0 !== s.__webglTexture && t.deleteTexture(s.__webglTexture);
            e.depthTexture && e.depthTexture.dispose();
            if (e.isWebGLCubeRenderTarget)
              for (let e = 0; e < 6; e++)
                t.deleteFramebuffer(i.__webglFramebuffer[e]),
                  i.__webglDepthbuffer &&
                    t.deleteRenderbuffer(i.__webglDepthbuffer[e]);
            else
              t.deleteFramebuffer(i.__webglFramebuffer),
                i.__webglDepthbuffer &&
                  t.deleteRenderbuffer(i.__webglDepthbuffer),
                i.__webglMultisampledFramebuffer &&
                  t.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                i.__webglColorRenderbuffer &&
                  t.deleteRenderbuffer(i.__webglColorRenderbuffer),
                i.__webglDepthRenderbuffer &&
                  t.deleteRenderbuffer(i.__webglDepthRenderbuffer);
            r.remove(e.texture), r.remove(e);
          })(i),
          o.memory.textures--;
      }
      let T = 0;
      function S(e, s) {
        const n = r.get(e);
        if (
          (e.isVideoTexture &&
            (function (t) {
              const e = o.render.frame;
              d.get(t) !== e && (d.set(t, e), t.update());
            })(e),
          e.version > 0 && n.__version !== e.version)
        ) {
          const t = e.image;
          if (void 0 === t)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined",
            );
          else {
            if (!1 !== t.complete) return void P(n, e, s);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
            );
          }
        }
        i.activeTexture(t.TEXTURE0 + s),
          i.bindTexture(t.TEXTURE_2D, n.__webglTexture);
      }
      function A(e, s) {
        const a = r.get(e);
        e.version > 0 && a.__version !== e.version
          ? (function (e, r, s) {
              if (6 !== r.image.length) return;
              z(e, r),
                i.activeTexture(t.TEXTURE0 + s),
                i.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture),
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY);
              const a =
                  r &&
                  (r.isCompressedTexture || r.image[0].isCompressedTexture),
                o = r.image[0] && r.image[0].isDataTexture,
                l = [];
              for (let t = 0; t < 6; t++)
                l[t] =
                  a || o
                    ? o
                      ? r.image[t].image
                      : r.image[t]
                    : y(r.image[t], !1, !0, u);
              const c = l[0],
                p = x(c) || h,
                d = n.convert(r.format),
                m = n.convert(r.type),
                f = M(r.internalFormat, d, m);
              let g;
              if ((F(t.TEXTURE_CUBE_MAP, r, p), a)) {
                for (let e = 0; e < 6; e++) {
                  g = l[e].mipmaps;
                  for (let s = 0; s < g.length; s++) {
                    const n = g[s];
                    r.format !== le && r.format !== he
                      ? null !== d
                        ? i.compressedTexImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            s,
                            f,
                            n.width,
                            n.height,
                            0,
                            n.data,
                          )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                          )
                      : i.texImage2D(
                          t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                          s,
                          f,
                          n.width,
                          n.height,
                          0,
                          d,
                          m,
                          n.data,
                        );
                  }
                }
                e.__maxMipLevel = g.length - 1;
              } else {
                g = r.mipmaps;
                for (let e = 0; e < 6; e++)
                  if (o) {
                    i.texImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                      0,
                      f,
                      l[e].width,
                      l[e].height,
                      0,
                      d,
                      m,
                      l[e].data,
                    );
                    for (let r = 0; r < g.length; r++) {
                      const s = g[r],
                        n = s.image[e].image;
                      i.texImage2D(
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                        r + 1,
                        f,
                        n.width,
                        n.height,
                        0,
                        d,
                        m,
                        n.data,
                      );
                    }
                  } else {
                    i.texImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                      0,
                      f,
                      d,
                      m,
                      l[e],
                    );
                    for (let r = 0; r < g.length; r++) {
                      const s = g[r];
                      i.texImage2D(
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                        r + 1,
                        f,
                        d,
                        m,
                        s.image[e],
                      );
                    }
                  }
                e.__maxMipLevel = g.length;
              }
              b(r, p) && v(t.TEXTURE_CUBE_MAP, r, c.width, c.height);
              (e.__version = r.version), r.onUpdate && r.onUpdate(r);
            })(a, e, s)
          : (i.activeTexture(t.TEXTURE0 + s),
            i.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture));
      }
      const R = {
          [kt]: t.REPEAT,
          [Gt]: t.CLAMP_TO_EDGE,
          [Wt]: t.MIRRORED_REPEAT,
        },
        L = {
          [Vt]: t.NEAREST,
          [Ht]: t.NEAREST_MIPMAP_NEAREST,
          [Xt]: t.NEAREST_MIPMAP_LINEAR,
          [jt]: t.LINEAR,
          [qt]: t.LINEAR_MIPMAP_NEAREST,
          [Yt]: t.LINEAR_MIPMAP_LINEAR,
        };
      function F(i, n, a) {
        a
          ? (t.texParameteri(i, t.TEXTURE_WRAP_S, R[n.wrapS]),
            t.texParameteri(i, t.TEXTURE_WRAP_T, R[n.wrapT]),
            (i !== t.TEXTURE_3D && i !== t.TEXTURE_2D_ARRAY) ||
              t.texParameteri(i, t.TEXTURE_WRAP_R, R[n.wrapR]),
            t.texParameteri(i, t.TEXTURE_MAG_FILTER, L[n.magFilter]),
            t.texParameteri(i, t.TEXTURE_MIN_FILTER, L[n.minFilter]))
          : (t.texParameteri(i, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
            t.texParameteri(i, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
            (i !== t.TEXTURE_3D && i !== t.TEXTURE_2D_ARRAY) ||
              t.texParameteri(i, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
            (n.wrapS === Gt && n.wrapT === Gt) ||
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
              ),
            t.texParameteri(i, t.TEXTURE_MAG_FILTER, w(n.magFilter)),
            t.texParameteri(i, t.TEXTURE_MIN_FILTER, w(n.minFilter)),
            n.minFilter !== Vt &&
              n.minFilter !== jt &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
              ));
        const o = e.get("EXT_texture_filter_anisotropic");
        if (o) {
          if (n.type === ee && null === e.get("OES_texture_float_linear"))
            return;
          if (
            n.type === ie &&
            null === (h || e.get("OES_texture_half_float_linear"))
          )
            return;
          (n.anisotropy > 1 || r.get(n).__currentAnisotropy) &&
            (t.texParameterf(
              i,
              o.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(n.anisotropy, s.getMaxAnisotropy()),
            ),
            (r.get(n).__currentAnisotropy = n.anisotropy));
        }
      }
      function z(e, i) {
        void 0 === e.__webglInit &&
          ((e.__webglInit = !0),
          i.addEventListener("dispose", _),
          (e.__webglTexture = t.createTexture()),
          o.memory.textures++);
      }
      function P(e, r, s) {
        let a = t.TEXTURE_2D;
        r.isDataTexture2DArray && (a = t.TEXTURE_2D_ARRAY),
          r.isDataTexture3D && (a = t.TEXTURE_3D),
          z(e, r),
          i.activeTexture(t.TEXTURE0 + s),
          i.bindTexture(a, e.__webglTexture),
          t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
          t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
          t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment);
        const o =
            (function (t) {
              return (
                !h &&
                (t.wrapS !== Gt ||
                  t.wrapT !== Gt ||
                  (t.minFilter !== Vt && t.minFilter !== jt))
              );
            })(r) && !1 === x(r.image),
          l = y(r.image, o, !1, c),
          u = x(l) || h,
          p = n.convert(r.format);
        let d,
          m = n.convert(r.type),
          f = M(r.internalFormat, p, m);
        F(a, r, u);
        const g = r.mipmaps;
        if (r.isDepthTexture)
          (f = t.DEPTH_COMPONENT),
            h
              ? (f =
                  r.type === ee
                    ? t.DEPTH_COMPONENT32F
                    : r.type === te
                    ? t.DEPTH_COMPONENT24
                    : r.type === ae
                    ? t.DEPTH24_STENCIL8
                    : t.DEPTH_COMPONENT16)
              : r.type === ee &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2.",
                ),
            r.format === pe &&
              f === t.DEPTH_COMPONENT &&
              r.type !== Kt &&
              r.type !== te &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
              ),
              (r.type = Kt),
              (m = n.convert(r.type))),
            r.format === de &&
              f === t.DEPTH_COMPONENT &&
              ((f = t.DEPTH_STENCIL),
              r.type !== ae &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
                ),
                (r.type = ae),
                (m = n.convert(r.type)))),
            i.texImage2D(t.TEXTURE_2D, 0, f, l.width, l.height, 0, p, m, null);
        else if (r.isDataTexture)
          if (g.length > 0 && u) {
            for (let e = 0, r = g.length; e < r; e++)
              (d = g[e]),
                i.texImage2D(
                  t.TEXTURE_2D,
                  e,
                  f,
                  d.width,
                  d.height,
                  0,
                  p,
                  m,
                  d.data,
                );
            (r.generateMipmaps = !1), (e.__maxMipLevel = g.length - 1);
          } else
            i.texImage2D(
              t.TEXTURE_2D,
              0,
              f,
              l.width,
              l.height,
              0,
              p,
              m,
              l.data,
            ),
              (e.__maxMipLevel = 0);
        else if (r.isCompressedTexture) {
          for (let e = 0, s = g.length; e < s; e++)
            (d = g[e]),
              r.format !== le && r.format !== he
                ? null !== p
                  ? i.compressedTexImage2D(
                      t.TEXTURE_2D,
                      e,
                      f,
                      d.width,
                      d.height,
                      0,
                      d.data,
                    )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                    )
                : i.texImage2D(
                    t.TEXTURE_2D,
                    e,
                    f,
                    d.width,
                    d.height,
                    0,
                    p,
                    m,
                    d.data,
                  );
          e.__maxMipLevel = g.length - 1;
        } else if (r.isDataTexture2DArray)
          i.texImage3D(
            t.TEXTURE_2D_ARRAY,
            0,
            f,
            l.width,
            l.height,
            l.depth,
            0,
            p,
            m,
            l.data,
          ),
            (e.__maxMipLevel = 0);
        else if (r.isDataTexture3D)
          i.texImage3D(
            t.TEXTURE_3D,
            0,
            f,
            l.width,
            l.height,
            l.depth,
            0,
            p,
            m,
            l.data,
          ),
            (e.__maxMipLevel = 0);
        else if (g.length > 0 && u) {
          for (let e = 0, r = g.length; e < r; e++)
            (d = g[e]), i.texImage2D(t.TEXTURE_2D, e, f, p, m, d);
          (r.generateMipmaps = !1), (e.__maxMipLevel = g.length - 1);
        } else i.texImage2D(t.TEXTURE_2D, 0, f, p, m, l), (e.__maxMipLevel = 0);
        b(r, u) && v(a, r, l.width, l.height),
          (e.__version = r.version),
          r.onUpdate && r.onUpdate(r);
      }
      function N(e, s, a, o) {
        const h = n.convert(s.texture.format),
          l = n.convert(s.texture.type),
          u = M(s.texture.internalFormat, h, l);
        i.texImage2D(o, 0, u, s.width, s.height, 0, h, l, null),
          t.bindFramebuffer(t.FRAMEBUFFER, e),
          t.framebufferTexture2D(
            t.FRAMEBUFFER,
            a,
            o,
            r.get(s.texture).__webglTexture,
            0,
          ),
          t.bindFramebuffer(t.FRAMEBUFFER, null);
      }
      function U(e, i, r) {
        if (
          (t.bindRenderbuffer(t.RENDERBUFFER, e),
          i.depthBuffer && !i.stencilBuffer)
        ) {
          let s = t.DEPTH_COMPONENT16;
          if (r) {
            const e = i.depthTexture;
            e &&
              e.isDepthTexture &&
              (e.type === ee
                ? (s = t.DEPTH_COMPONENT32F)
                : e.type === te && (s = t.DEPTH_COMPONENT24));
            const r = C(i);
            t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              r,
              s,
              i.width,
              i.height,
            );
          } else t.renderbufferStorage(t.RENDERBUFFER, s, i.width, i.height);
          t.framebufferRenderbuffer(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.RENDERBUFFER,
            e,
          );
        } else if (i.depthBuffer && i.stencilBuffer) {
          if (r) {
            const e = C(i);
            t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              e,
              t.DEPTH24_STENCIL8,
              i.width,
              i.height,
            );
          } else
            t.renderbufferStorage(
              t.RENDERBUFFER,
              t.DEPTH_STENCIL,
              i.width,
              i.height,
            );
          t.framebufferRenderbuffer(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.RENDERBUFFER,
            e,
          );
        } else {
          const e = n.convert(i.texture.format),
            s = n.convert(i.texture.type),
            a = M(i.texture.internalFormat, e, s);
          if (r) {
            const e = C(i);
            t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              e,
              a,
              i.width,
              i.height,
            );
          } else t.renderbufferStorage(t.RENDERBUFFER, a, i.width, i.height);
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null);
      }
      function B(e) {
        const i = r.get(e),
          s = !0 === e.isWebGLCubeRenderTarget;
        if (e.depthTexture) {
          if (s)
            throw new Error(
              "target.depthTexture not supported in Cube render targets",
            );
          !(function (e, i) {
            if (i && i.isWebGLCubeRenderTarget)
              throw new Error(
                "Depth Texture with cube render targets is not supported",
              );
            if (
              (t.bindFramebuffer(t.FRAMEBUFFER, e),
              !i.depthTexture || !i.depthTexture.isDepthTexture)
            )
              throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
              );
            (r.get(i.depthTexture).__webglTexture &&
              i.depthTexture.image.width === i.width &&
              i.depthTexture.image.height === i.height) ||
              ((i.depthTexture.image.width = i.width),
              (i.depthTexture.image.height = i.height),
              (i.depthTexture.needsUpdate = !0)),
              S(i.depthTexture, 0);
            const s = r.get(i.depthTexture).__webglTexture;
            if (i.depthTexture.format === pe)
              t.framebufferTexture2D(
                t.FRAMEBUFFER,
                t.DEPTH_ATTACHMENT,
                t.TEXTURE_2D,
                s,
                0,
              );
            else {
              if (i.depthTexture.format !== de)
                throw new Error("Unknown depthTexture format");
              t.framebufferTexture2D(
                t.FRAMEBUFFER,
                t.DEPTH_STENCIL_ATTACHMENT,
                t.TEXTURE_2D,
                s,
                0,
              );
            }
          })(i.__webglFramebuffer, e);
        } else if (s) {
          i.__webglDepthbuffer = [];
          for (let r = 0; r < 6; r++)
            t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[r]),
              (i.__webglDepthbuffer[r] = t.createRenderbuffer()),
              U(i.__webglDepthbuffer[r], e, !1);
        } else
          t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer),
            (i.__webglDepthbuffer = t.createRenderbuffer()),
            U(i.__webglDepthbuffer, e, !1);
        t.bindFramebuffer(t.FRAMEBUFFER, null);
      }
      function C(t) {
        return h && t.isWebGLMultisampleRenderTarget
          ? Math.min(p, t.samples)
          : 0;
      }
      let O = !1,
        D = !1;
      (this.allocateTextureUnit = function () {
        const t = T;
        return (
          t >= l &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                t +
                " texture units while this GPU supports only " +
                l,
            ),
          (T += 1),
          t
        );
      }),
        (this.resetTextureUnits = function () {
          T = 0;
        }),
        (this.setTexture2D = S),
        (this.setTexture2DArray = function (e, s) {
          const n = r.get(e);
          e.version > 0 && n.__version !== e.version
            ? P(n, e, s)
            : (i.activeTexture(t.TEXTURE0 + s),
              i.bindTexture(t.TEXTURE_2D_ARRAY, n.__webglTexture));
        }),
        (this.setTexture3D = function (e, s) {
          const n = r.get(e);
          e.version > 0 && n.__version !== e.version
            ? P(n, e, s)
            : (i.activeTexture(t.TEXTURE0 + s),
              i.bindTexture(t.TEXTURE_3D, n.__webglTexture));
        }),
        (this.setTextureCube = A),
        (this.setupRenderTarget = function (e) {
          const s = r.get(e),
            a = r.get(e.texture);
          e.addEventListener("dispose", E),
            (a.__webglTexture = t.createTexture()),
            o.memory.textures++;
          const l = !0 === e.isWebGLCubeRenderTarget,
            u = !0 === e.isWebGLMultisampleRenderTarget,
            c = x(e) || h;
          if (
            (!h ||
              e.texture.format !== he ||
              (e.texture.type !== ee && e.texture.type !== ie) ||
              ((e.texture.format = le),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.",
              )),
            l)
          ) {
            s.__webglFramebuffer = [];
            for (let e = 0; e < 6; e++)
              s.__webglFramebuffer[e] = t.createFramebuffer();
          } else if (((s.__webglFramebuffer = t.createFramebuffer()), u))
            if (h) {
              (s.__webglMultisampledFramebuffer = t.createFramebuffer()),
                (s.__webglColorRenderbuffer = t.createRenderbuffer()),
                t.bindRenderbuffer(t.RENDERBUFFER, s.__webglColorRenderbuffer);
              const i = n.convert(e.texture.format),
                r = n.convert(e.texture.type),
                a = M(e.texture.internalFormat, i, r),
                o = C(e);
              t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                o,
                a,
                e.width,
                e.height,
              ),
                t.bindFramebuffer(
                  t.FRAMEBUFFER,
                  s.__webglMultisampledFramebuffer,
                ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.RENDERBUFFER,
                  s.__webglColorRenderbuffer,
                ),
                t.bindRenderbuffer(t.RENDERBUFFER, null),
                e.depthBuffer &&
                  ((s.__webglDepthRenderbuffer = t.createRenderbuffer()),
                  U(s.__webglDepthRenderbuffer, e, !0)),
                t.bindFramebuffer(t.FRAMEBUFFER, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.",
              );
          if (l) {
            i.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture),
              F(t.TEXTURE_CUBE_MAP, e.texture, c);
            for (let i = 0; i < 6; i++)
              N(
                s.__webglFramebuffer[i],
                e,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_CUBE_MAP_POSITIVE_X + i,
              );
            b(e.texture, c) &&
              v(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height),
              i.bindTexture(t.TEXTURE_CUBE_MAP, null);
          } else
            i.bindTexture(t.TEXTURE_2D, a.__webglTexture),
              F(t.TEXTURE_2D, e.texture, c),
              N(s.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
              b(e.texture, c) && v(t.TEXTURE_2D, e.texture, e.width, e.height),
              i.bindTexture(t.TEXTURE_2D, null);
          e.depthBuffer && B(e);
        }),
        (this.updateRenderTargetMipmap = function (e) {
          const s = e.texture;
          if (b(s, x(e) || h)) {
            const n = e.isWebGLCubeRenderTarget
                ? t.TEXTURE_CUBE_MAP
                : t.TEXTURE_2D,
              a = r.get(s).__webglTexture;
            i.bindTexture(n, a),
              v(n, s, e.width, e.height),
              i.bindTexture(n, null);
          }
        }),
        (this.updateMultisampleRenderTarget = function (e) {
          if (e.isWebGLMultisampleRenderTarget)
            if (h) {
              const i = r.get(e);
              t.bindFramebuffer(
                t.READ_FRAMEBUFFER,
                i.__webglMultisampledFramebuffer,
              ),
                t.bindFramebuffer(t.DRAW_FRAMEBUFFER, i.__webglFramebuffer);
              const s = e.width,
                n = e.height;
              let a = t.COLOR_BUFFER_BIT;
              e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT),
                e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT),
                t.blitFramebuffer(0, 0, s, n, 0, 0, s, n, a, t.NEAREST),
                t.bindFramebuffer(
                  t.FRAMEBUFFER,
                  i.__webglMultisampledFramebuffer,
                );
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.",
              );
        }),
        (this.safeSetTexture2D = function (t, e) {
          t &&
            t.isWebGLRenderTarget &&
            (!1 === O &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.",
              ),
              (O = !0)),
            (t = t.texture)),
            S(t, e);
        }),
        (this.safeSetTextureCube = function (t, e) {
          t &&
            t.isWebGLCubeRenderTarget &&
            (!1 === D &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.",
              ),
              (D = !0)),
            (t = t.texture)),
            A(t, e);
        });
    }
    function Qn(t, e, i) {
      const r = i.isWebGL2;
      return {
        convert: function (i) {
          let s;
          if (i === Zt) return t.UNSIGNED_BYTE;
          if (i === re) return t.UNSIGNED_SHORT_4_4_4_4;
          if (i === se) return t.UNSIGNED_SHORT_5_5_5_1;
          if (i === ne) return t.UNSIGNED_SHORT_5_6_5;
          if (i === Jt) return t.BYTE;
          if (i === Qt) return t.SHORT;
          if (i === Kt) return t.UNSIGNED_SHORT;
          if (i === $t) return t.INT;
          if (i === te) return t.UNSIGNED_INT;
          if (i === ee) return t.FLOAT;
          if (i === ie)
            return r
              ? t.HALF_FLOAT
              : null !== (s = e.get("OES_texture_half_float"))
              ? s.HALF_FLOAT_OES
              : null;
          if (i === oe) return t.ALPHA;
          if (i === he) return t.RGB;
          if (i === le) return t.RGBA;
          if (i === ue) return t.LUMINANCE;
          if (i === ce) return t.LUMINANCE_ALPHA;
          if (i === pe) return t.DEPTH_COMPONENT;
          if (i === de) return t.DEPTH_STENCIL;
          if (i === me) return t.RED;
          if (i === fe) return t.RED_INTEGER;
          if (i === ge) return t.RG;
          if (i === ye) return t.RG_INTEGER;
          if (i === xe) return t.RGB_INTEGER;
          if (i === be) return t.RGBA_INTEGER;
          if (i === ve || i === Me || i === we || i === _e) {
            if (null === (s = e.get("WEBGL_compressed_texture_s3tc")))
              return null;
            if (i === ve) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (i === Me) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (i === we) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (i === _e) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (i === Ee || i === Te || i === Se || i === Ae) {
            if (null === (s = e.get("WEBGL_compressed_texture_pvrtc")))
              return null;
            if (i === Ee) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (i === Te) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (i === Se) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (i === Ae) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (i === Re)
            return null !== (s = e.get("WEBGL_compressed_texture_etc1"))
              ? s.COMPRESSED_RGB_ETC1_WEBGL
              : null;
          if (
            (i === Le || i === Fe) &&
            null !== (s = e.get("WEBGL_compressed_texture_etc"))
          ) {
            if (i === Le) return s.COMPRESSED_RGB8_ETC2;
            if (i === Fe) return s.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return i === ze ||
            i === Pe ||
            i === Ne ||
            i === Ue ||
            i === Be ||
            i === Ce ||
            i === Oe ||
            i === De ||
            i === Ie ||
            i === ke ||
            i === Ge ||
            i === We ||
            i === Ve ||
            i === He ||
            i === je ||
            i === qe ||
            i === Ye ||
            i === Ze ||
            i === Je ||
            i === Qe ||
            i === Ke ||
            i === $e ||
            i === ti ||
            i === ei ||
            i === ii ||
            i === ri ||
            i === si ||
            i === ni
            ? null !== (s = e.get("WEBGL_compressed_texture_astc"))
              ? i
              : null
            : i === Xe
            ? null !== (s = e.get("EXT_texture_compression_bptc"))
              ? i
              : null
            : i === ae
            ? r
              ? t.UNSIGNED_INT_24_8
              : null !== (s = e.get("WEBGL_depth_texture"))
              ? s.UNSIGNED_INT_24_8_WEBGL
              : null
            : void 0;
        },
      };
    }
    function Kn(t) {
      function e(e, i) {
        (e.opacity.value = i.opacity),
          i.color && e.diffuse.value.copy(i.color),
          i.emissive &&
            e.emissive.value
              .copy(i.emissive)
              .multiplyScalar(i.emissiveIntensity),
          i.map && (e.map.value = i.map),
          i.alphaMap && (e.alphaMap.value = i.alphaMap),
          i.specularMap && (e.specularMap.value = i.specularMap);
        const r = t.get(i).envMap;
        if (r) {
          (e.envMap.value = r),
            (e.flipEnvMap.value =
              r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1),
            (e.reflectivity.value = i.reflectivity),
            (e.refractionRatio.value = i.refractionRatio);
          const s = t.get(r).__maxMipLevel;
          void 0 !== s && (e.maxMipLevel.value = s);
        }
        let s, n;
        i.lightMap &&
          ((e.lightMap.value = i.lightMap),
          (e.lightMapIntensity.value = i.lightMapIntensity)),
          i.aoMap &&
            ((e.aoMap.value = i.aoMap),
            (e.aoMapIntensity.value = i.aoMapIntensity)),
          i.map
            ? (s = i.map)
            : i.specularMap
            ? (s = i.specularMap)
            : i.displacementMap
            ? (s = i.displacementMap)
            : i.normalMap
            ? (s = i.normalMap)
            : i.bumpMap
            ? (s = i.bumpMap)
            : i.roughnessMap
            ? (s = i.roughnessMap)
            : i.metalnessMap
            ? (s = i.metalnessMap)
            : i.alphaMap
            ? (s = i.alphaMap)
            : i.emissiveMap
            ? (s = i.emissiveMap)
            : i.clearcoatMap
            ? (s = i.clearcoatMap)
            : i.clearcoatNormalMap
            ? (s = i.clearcoatNormalMap)
            : i.clearcoatRoughnessMap && (s = i.clearcoatRoughnessMap),
          void 0 !== s &&
            (s.isWebGLRenderTarget && (s = s.texture),
            !0 === s.matrixAutoUpdate && s.updateMatrix(),
            e.uvTransform.value.copy(s.matrix)),
          i.aoMap ? (n = i.aoMap) : i.lightMap && (n = i.lightMap),
          void 0 !== n &&
            (n.isWebGLRenderTarget && (n = n.texture),
            !0 === n.matrixAutoUpdate && n.updateMatrix(),
            e.uv2Transform.value.copy(n.matrix));
      }
      function i(e, i) {
        (e.roughness.value = i.roughness),
          (e.metalness.value = i.metalness),
          i.roughnessMap && (e.roughnessMap.value = i.roughnessMap),
          i.metalnessMap && (e.metalnessMap.value = i.metalnessMap),
          i.emissiveMap && (e.emissiveMap.value = i.emissiveMap),
          i.bumpMap &&
            ((e.bumpMap.value = i.bumpMap),
            (e.bumpScale.value = i.bumpScale),
            i.side === tt && (e.bumpScale.value *= -1)),
          i.normalMap &&
            ((e.normalMap.value = i.normalMap),
            e.normalScale.value.copy(i.normalScale),
            i.side === tt && e.normalScale.value.negate()),
          i.displacementMap &&
            ((e.displacementMap.value = i.displacementMap),
            (e.displacementScale.value = i.displacementScale),
            (e.displacementBias.value = i.displacementBias)),
          t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity);
      }
      return {
        refreshFogUniforms: function (t, e) {
          t.fogColor.value.copy(e.color),
            e.isFog
              ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
              : e.isFogExp2 && (t.fogDensity.value = e.density);
        },
        refreshMaterialUniforms: function (t, r, s, n) {
          r.isMeshBasicMaterial
            ? e(t, r)
            : r.isMeshLambertMaterial
            ? (e(t, r),
              (function (t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
              })(t, r))
            : r.isMeshToonMaterial
            ? (e(t, r),
              (function (t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap),
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    e.side === tt && (t.bumpScale.value *= -1)),
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === tt && t.normalScale.value.negate()),
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
              })(t, r))
            : r.isMeshPhongMaterial
            ? (e(t, r),
              (function (t, e) {
                t.specular.value.copy(e.specular),
                  (t.shininess.value = Math.max(e.shininess, 1e-4)),
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    e.side === tt && (t.bumpScale.value *= -1)),
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === tt && t.normalScale.value.negate()),
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
              })(t, r))
            : r.isMeshStandardMaterial
            ? (e(t, r),
              r.isMeshPhysicalMaterial
                ? (function (t, e) {
                    i(t, e),
                      (t.reflectivity.value = e.reflectivity),
                      (t.clearcoat.value = e.clearcoat),
                      (t.clearcoatRoughness.value = e.clearcoatRoughness),
                      e.sheen && t.sheen.value.copy(e.sheen),
                      e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                      e.clearcoatRoughnessMap &&
                        (t.clearcoatRoughnessMap.value =
                          e.clearcoatRoughnessMap),
                      e.clearcoatNormalMap &&
                        (t.clearcoatNormalScale.value.copy(
                          e.clearcoatNormalScale,
                        ),
                        (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                        e.side === tt && t.clearcoatNormalScale.value.negate()),
                      (t.transmission.value = e.transmission),
                      e.transmissionMap &&
                        (t.transmissionMap.value = e.transmissionMap);
                  })(t, r)
                : i(t, r))
            : r.isMeshMatcapMaterial
            ? (e(t, r),
              (function (t, e) {
                e.matcap && (t.matcap.value = e.matcap),
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    e.side === tt && (t.bumpScale.value *= -1)),
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === tt && t.normalScale.value.negate()),
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
              })(t, r))
            : r.isMeshDepthMaterial
            ? (e(t, r),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, r))
            : r.isMeshDistanceMaterial
            ? (e(t, r),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias)),
                  t.referencePosition.value.copy(e.referencePosition),
                  (t.nearDistance.value = e.nearDistance),
                  (t.farDistance.value = e.farDistance);
              })(t, r))
            : r.isMeshNormalMaterial
            ? (e(t, r),
              (function (t, e) {
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  e.side === tt && (t.bumpScale.value *= -1)),
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === tt && t.normalScale.value.negate()),
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
              })(t, r))
            : r.isLineBasicMaterial
            ? ((function (t, e) {
                t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
              })(t, r),
              r.isLineDashedMaterial &&
                (function (t, e) {
                  (t.dashSize.value = e.dashSize),
                    (t.totalSize.value = e.dashSize + e.gapSize),
                    (t.scale.value = e.scale);
                })(t, r))
            : r.isPointsMaterial
            ? (function (t, e, i, r) {
                let s;
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.size.value = e.size * i),
                  (t.scale.value = 0.5 * r),
                  e.map && (t.map.value = e.map),
                  e.alphaMap && (t.alphaMap.value = e.alphaMap),
                  e.map ? (s = e.map) : e.alphaMap && (s = e.alphaMap),
                  void 0 !== s &&
                    (!0 === s.matrixAutoUpdate && s.updateMatrix(),
                    t.uvTransform.value.copy(s.matrix));
              })(t, r, s, n)
            : r.isSpriteMaterial
            ? (function (t, e) {
                let i;
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.rotation.value = e.rotation),
                  e.map && (t.map.value = e.map),
                  e.alphaMap && (t.alphaMap.value = e.alphaMap),
                  e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap),
                  void 0 !== i &&
                    (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                    t.uvTransform.value.copy(i.matrix));
              })(t, r)
            : r.isShadowMaterial
            ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
            : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
        },
      };
    }
    function $n(t) {
      const e =
          void 0 !== (t = t || {}).canvas
            ? t.canvas
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas",
              ),
        i = void 0 !== t.context ? t.context : null,
        r = void 0 !== t.alpha && t.alpha,
        s = void 0 === t.depth || t.depth,
        n = void 0 === t.stencil || t.stencil,
        o = void 0 !== t.antialias && t.antialias,
        l = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        u = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        p = void 0 !== t.powerPreference ? t.powerPreference : "default",
        d =
          void 0 !== t.failIfMajorPerformanceCaveat &&
          t.failIfMajorPerformanceCaveat;
      let m = null,
        f = null;
      (this.domElement = e),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.gammaFactor = 2),
        (this.outputEncoding = ai),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = Nt),
        (this.toneMappingExposure = 1),
        (this.maxMorphTargets = 8),
        (this.maxMorphNormals = 4);
      const g = this;
      let y = !1,
        x = null,
        b = 0,
        v = 0,
        M = null,
        w = null,
        _ = -1,
        E = null,
        T = null;
      const S = new Hi(),
        A = new Hi();
      let R = null,
        L = e.width,
        F = e.height,
        z = 1,
        P = null,
        N = null;
      const U = new Hi(0, 0, L, F),
        B = new Hi(0, 0, L, F);
      let C = !1;
      const O = new Vi();
      let D = !1,
        I = !1;
      const k = new c(),
        G = new h(),
        W = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function V() {
        return null === M ? z : 1;
      }
      let H,
        X,
        j,
        q,
        Y,
        Z,
        J,
        Q,
        K,
        $,
        tt,
        et,
        it,
        rt,
        st,
        nt,
        at,
        ot,
        ht,
        lt,
        ut,
        ct = i;
      function pt(t, i) {
        for (let r = 0; r < t.length; r++) {
          const s = t[r],
            n = e.getContext(s, i);
          if (null !== n) return n;
        }
        return null;
      }
      try {
        const t = {
          alpha: r,
          depth: s,
          stencil: n,
          antialias: o,
          premultipliedAlpha: l,
          preserveDrawingBuffer: u,
          powerPreference: p,
          failIfMajorPerformanceCaveat: d,
        };
        if (
          (e.addEventListener("webglcontextlost", gt, !1),
          e.addEventListener("webglcontextrestored", yt, !1),
          null === ct)
        ) {
          const e = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === g.isWebGL1Renderer && e.shift(), null === (ct = pt(e, t)))
          )
            throw pt(e)
              ? new Error(
                  "Error creating WebGL context with your selected attributes.",
                )
              : new Error("Error creating WebGL context.");
        }
        void 0 === ct.getShaderPrecisionFormat &&
          (ct.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
      } catch (t) {
        throw (console.error("THREE.WebGLRenderer: " + t.message), t);
      }
      function dt() {
        (H = new Es(ct)),
          !1 === (X = new fs(ct, H, t)).isWebGL2 &&
            (H.get("WEBGL_depth_texture"),
            H.get("OES_texture_float"),
            H.get("OES_texture_half_float"),
            H.get("OES_texture_half_float_linear"),
            H.get("OES_standard_derivatives"),
            H.get("OES_element_index_uint"),
            H.get("OES_vertex_array_object"),
            H.get("ANGLE_instanced_arrays")),
          H.get("OES_texture_float_linear"),
          (lt = new Qn(ct, H, X)),
          (j = new Zn(ct, H, X)).scissor(A.copy(B).multiplyScalar(z).floor()),
          j.viewport(S.copy(U).multiplyScalar(z).floor()),
          (q = new As(ct)),
          (Y = new Bn()),
          (Z = new Jn(ct, H, j, Y, X, lt, q)),
          (J = new _s(g)),
          (Q = new ji(ct, X)),
          (ut = new ds(ct, H, Q, X)),
          (K = new Ts(ct, Q, q, ut)),
          ($ = new zs(ct, K, Q, q)),
          (at = new Fs(ct)),
          (st = new gs(Y)),
          (tt = new Un(g, J, H, X, ut, st)),
          (et = new Kn(Y)),
          (it = new In(Y)),
          (rt = new Xn()),
          (nt = new ps(g, J, j, $, l)),
          (ot = new ms(ct, H, q, X)),
          (ht = new Ss(ct, H, q, X)),
          (q.programs = tt.programs),
          (g.capabilities = X),
          (g.extensions = H),
          (g.properties = Y),
          (g.renderLists = it),
          (g.state = j),
          (g.info = q);
      }
      dt();
      const mt = { dispose: () => {}, setAnimationLoop: () => {} };
      this.xr = mt;
      const ft = new Yn(g, $, X.maxTextureSize);
      function gt(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (y = !0);
      }
      function yt() {
        console.log("THREE.WebGLRenderer: Context Restored."), (y = !1), dt();
      }
      function xt(t) {
        const e = t.target;
        e.removeEventListener("dispose", xt),
          (function (t) {
            bt(t), Y.remove(t);
          })(e);
      }
      function bt(t) {
        const e = Y.get(t).program;
        void 0 !== e && tt.releaseProgram(e);
      }
      (this.shadowMap = ft),
        (this.getContext = function () {
          return ct;
        }),
        (this.getContextAttributes = function () {
          return ct.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const t = H.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          const t = H.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return z;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((z = t), this.setSize(L, F, !1));
        }),
        (this.getSize = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getsize() now requires a Vector2 as an argument",
              ),
              (t = new mi())),
            t.set(L, F)
          );
        }),
        (this.setSize = function (t, i, r) {
          mt.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
              )
            : ((L = t),
              (F = i),
              (e.width = Math.floor(t * z)),
              (e.height = Math.floor(i * z)),
              !1 !== r &&
                ((e.style.width = t + "px"), (e.style.height = i + "px")),
              this.setViewport(0, 0, t, i));
        }),
        (this.getDrawingBufferSize = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument",
              ),
              (t = new mi())),
            t.set(L * z, F * z).floor()
          );
        }),
        (this.setDrawingBufferSize = function (t, i, r) {
          (L = t),
            (F = i),
            (z = r),
            (e.width = Math.floor(t * r)),
            (e.height = Math.floor(i * r)),
            this.setViewport(0, 0, t, i);
        }),
        (this.getCurrentViewport = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument",
              ),
              (t = new Hi())),
            t.copy(S)
          );
        }),
        (this.getViewport = function (t) {
          return t.copy(U);
        }),
        (this.setViewport = function (t, e, i, r) {
          t.isVector4 ? U.set(t.x, t.y, t.z, t.w) : U.set(t, e, i, r),
            j.viewport(S.copy(U).multiplyScalar(z).floor());
        }),
        (this.getScissor = function (t) {
          return t.copy(B);
        }),
        (this.setScissor = function (t, e, i, r) {
          t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, i, r),
            j.scissor(A.copy(B).multiplyScalar(z).floor());
        }),
        (this.getScissorTest = function () {
          return C;
        }),
        (this.setScissorTest = function (t) {
          j.setScissorTest((C = t));
        }),
        (this.setOpaqueSort = function (t) {
          P = t;
        }),
        (this.setTransparentSort = function (t) {
          N = t;
        }),
        (this.getClearColor = function () {
          return nt.getClearColor();
        }),
        (this.setClearColor = function () {
          nt.setClearColor.apply(nt, arguments);
        }),
        (this.getClearAlpha = function () {
          return nt.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          nt.setClearAlpha.apply(nt, arguments);
        }),
        (this.clear = function (t, e, i) {
          let r = 0;
          (void 0 === t || t) && (r |= ct.COLOR_BUFFER_BIT),
            (void 0 === e || e) && (r |= ct.DEPTH_BUFFER_BIT),
            (void 0 === i || i) && (r |= ct.STENCIL_BUFFER_BIT),
            ct.clear(r);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          e.removeEventListener("webglcontextlost", gt, !1),
            e.removeEventListener("webglcontextrestored", yt, !1),
            it.dispose(),
            rt.dispose(),
            Y.dispose(),
            J.dispose(),
            $.dispose(),
            ut.dispose(),
            mt.dispose(),
            Mt.stop();
        }),
        (this.renderBufferImmediate = function (t, e) {
          ut.initAttributes();
          const i = Y.get(t);
          t.hasPositions && !i.position && (i.position = ct.createBuffer()),
            t.hasNormals && !i.normal && (i.normal = ct.createBuffer()),
            t.hasUvs && !i.uv && (i.uv = ct.createBuffer()),
            t.hasColors && !i.color && (i.color = ct.createBuffer());
          const r = e.getAttributes();
          t.hasPositions &&
            (ct.bindBuffer(ct.ARRAY_BUFFER, i.position),
            ct.bufferData(ct.ARRAY_BUFFER, t.positionArray, ct.DYNAMIC_DRAW),
            ut.enableAttribute(r.position),
            ct.vertexAttribPointer(r.position, 3, ct.FLOAT, !1, 0, 0)),
            t.hasNormals &&
              (ct.bindBuffer(ct.ARRAY_BUFFER, i.normal),
              ct.bufferData(ct.ARRAY_BUFFER, t.normalArray, ct.DYNAMIC_DRAW),
              ut.enableAttribute(r.normal),
              ct.vertexAttribPointer(r.normal, 3, ct.FLOAT, !1, 0, 0)),
            t.hasUvs &&
              (ct.bindBuffer(ct.ARRAY_BUFFER, i.uv),
              ct.bufferData(ct.ARRAY_BUFFER, t.uvArray, ct.DYNAMIC_DRAW),
              ut.enableAttribute(r.uv),
              ct.vertexAttribPointer(r.uv, 2, ct.FLOAT, !1, 0, 0)),
            t.hasColors &&
              (ct.bindBuffer(ct.ARRAY_BUFFER, i.color),
              ct.bufferData(ct.ARRAY_BUFFER, t.colorArray, ct.DYNAMIC_DRAW),
              ut.enableAttribute(r.color),
              ct.vertexAttribPointer(r.color, 3, ct.FLOAT, !1, 0, 0)),
            ut.disableUnusedAttributes(),
            ct.drawArrays(ct.TRIANGLES, 0, t.count),
            (t.count = 0);
        }),
        (this.renderBufferDirect = function (t, e, i, r, s, n) {
          null === e && (e = W);
          const a = s.isMesh && s.matrixWorld.determinant() < 0,
            o = Tt(t, e, r, s);
          j.setMaterial(r, a);
          let h = i.index;
          const l = i.attributes.position;
          if (null === h) {
            if (void 0 === l || 0 === l.count) return;
          } else if (0 === h.count) return;
          let u,
            c = 1;
          !0 === r.wireframe && ((h = K.getWireframeAttribute(i)), (c = 2)),
            (r.morphTargets || r.morphNormals) && at.update(s, i, r, o),
            ut.setup(s, r, o, i, h);
          let p = ot;
          null !== h && ((u = Q.get(h)), (p = ht).setIndex(u));
          const d = null !== h ? h.count : l.count,
            m = i.drawRange.start * c,
            f = i.drawRange.count * c,
            g = null !== n ? n.start * c : 0,
            y = null !== n ? n.count * c : 1 / 0,
            x = Math.max(m, g),
            b = Math.min(d, m + f, g + y) - 1,
            v = Math.max(0, b - x + 1);
          if (0 !== v) {
            if (s.isMesh)
              !0 === r.wireframe
                ? (j.setLineWidth(r.wireframeLinewidth * V()),
                  p.setMode(ct.LINES))
                : p.setMode(ct.TRIANGLES);
            else if (s.isLine) {
              let t = r.linewidth;
              void 0 === t && (t = 1),
                j.setLineWidth(t * V()),
                s.isLineSegments
                  ? p.setMode(ct.LINES)
                  : s.isLineLoop
                  ? p.setMode(ct.LINE_LOOP)
                  : p.setMode(ct.LINE_STRIP);
            } else
              s.isPoints
                ? p.setMode(ct.POINTS)
                : s.isSprite && p.setMode(ct.TRIANGLES);
            if (s.isInstancedMesh) p.renderInstances(x, v, s.count);
            else if (i.isInstancedBufferGeometry) {
              const t = Math.min(i.instanceCount, i._maxInstanceCount);
              p.renderInstances(x, v, t);
            } else p.render(x, v);
          }
        }),
        (this.compile = function (t, e) {
          (f = rt.get(t, e)).init(),
            t.traverseVisible(function (t) {
              t.isLight &&
                t.layers.test(e.layers) &&
                (f.pushLight(t), t.castShadow && f.pushShadow(t));
            }),
            f.setupLights(e);
          const i = new WeakMap();
          t.traverse(function (e) {
            const r = e.material;
            if (r)
              if (Array.isArray(r))
                for (let s = 0; s < r.length; s++) {
                  const n = r[s];
                  !1 === i.has(n) && (Et(n, t, e), i.set(n));
                }
              else !1 === i.has(r) && (Et(r, t, e), i.set(r));
          });
        });
      let vt = null;
      const Mt = new Xi();
      function wt(t, e, i) {
        const r = !0 === e.isScene ? e.overrideMaterial : null;
        for (let s = 0, n = t.length; s < n; s++) {
          const n = t[s],
            a = n.object,
            o = n.geometry,
            h = null === r ? n.material : r,
            l = n.group;
          if (i.isArrayCamera) {
            T = i;
            const t = i.cameras;
            for (let i = 0, r = t.length; i < r; i++) {
              const r = t[i];
              a.layers.test(r.layers) &&
                (j.viewport(S.copy(r.viewport)),
                f.setupLights(r),
                _t(a, e, r, o, h, l));
            }
          } else (T = null), _t(a, e, i, o, h, l);
        }
      }
      function _t(t, e, i, r, s, n) {
        if (
          (t.onBeforeRender(g, e, i, r, s, n),
          (f = rt.get(e, T || i)),
          t.modelViewMatrix.multiplyMatrices(
            i.matrixWorldInverse,
            t.matrixWorld,
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          t.isImmediateRenderObject)
        ) {
          const r = Tt(i, e, s, t);
          j.setMaterial(s),
            ut.reset(),
            (function (t, e) {
              t.render(function (t) {
                g.renderBufferImmediate(t, e);
              });
            })(t, r);
        } else g.renderBufferDirect(i, e, r, s, t, n);
        t.onAfterRender(g, e, i, r, s, n), (f = rt.get(e, T || i));
      }
      function Et(t, e, i) {
        !0 !== e.isScene && (e = W);
        const r = Y.get(t),
          s = f.state.lights,
          n = f.state.shadowsArray,
          a = s.state.version,
          o = tt.getParameters(t, s.state, n, e, i),
          h = tt.getProgramCacheKey(o);
        let l = r.program,
          u = !0;
        if (void 0 === l) t.addEventListener("dispose", xt);
        else if (l.cacheKey !== h) bt(t);
        else if (r.lightsStateVersion !== a) u = !1;
        else {
          if (void 0 !== o.shaderID) {
            const i = t.isMeshStandardMaterial ? e.environment : null;
            return void (r.envMap = J.get(t.envMap || i));
          }
          u = !1;
        }
        u &&
          ((o.uniforms = tt.getUniforms(t)),
          t.onBeforeCompile(o, g),
          (l = tt.acquireProgram(o, h)),
          (r.program = l),
          (r.uniforms = o.uniforms),
          (r.outputEncoding = o.outputEncoding));
        const c = r.uniforms;
        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
          ((r.numClippingPlanes = st.numPlanes),
          (r.numIntersection = st.numIntersection),
          (c.clippingPlanes = st.uniform)),
          (r.environment = t.isMeshStandardMaterial ? e.environment : null),
          (r.fog = e.fog),
          (r.envMap = J.get(t.envMap || r.environment)),
          (r.needsLights = (function (t) {
            return (
              t.isMeshLambertMaterial ||
              t.isMeshToonMaterial ||
              t.isMeshPhongMaterial ||
              t.isMeshStandardMaterial ||
              t.isShadowMaterial ||
              (t.isShaderMaterial && !0 === t.lights)
            );
          })(t)),
          (r.lightsStateVersion = a),
          r.needsLights &&
            ((c.ambientLightColor.value = s.state.ambient),
            (c.lightProbe.value = s.state.probe),
            (c.directionalLights.value = s.state.directional),
            (c.directionalLightShadows.value = s.state.directionalShadow),
            (c.spotLights.value = s.state.spot),
            (c.spotLightShadows.value = s.state.spotShadow),
            (c.rectAreaLights.value = s.state.rectArea),
            (c.ltc_1.value = s.state.rectAreaLTC1),
            (c.ltc_2.value = s.state.rectAreaLTC2),
            (c.pointLights.value = s.state.point),
            (c.pointLightShadows.value = s.state.pointShadow),
            (c.hemisphereLights.value = s.state.hemi),
            (c.directionalShadowMap.value = s.state.directionalShadowMap),
            (c.directionalShadowMatrix.value = s.state.directionalShadowMatrix),
            (c.spotShadowMap.value = s.state.spotShadowMap),
            (c.spotShadowMatrix.value = s.state.spotShadowMatrix),
            (c.pointShadowMap.value = s.state.pointShadowMap),
            (c.pointShadowMatrix.value = s.state.pointShadowMatrix));
        const p = r.program.getUniforms(),
          d = Ln.seqWithValue(p.seq, c);
        r.uniformsList = d;
      }
      function Tt(t, e, i, r) {
        !0 !== e.isScene && (e = W), Z.resetTextureUnits();
        const s = e.fog,
          n = i.isMeshStandardMaterial ? e.environment : null,
          o = null === M ? g.outputEncoding : M.texture.encoding,
          h = J.get(i.envMap || n),
          l = Y.get(i),
          u = f.state.lights;
        if (!0 === D && (!0 === I || t !== E)) {
          const e = t === E && i.id === _;
          st.setState(i, t, e);
        }
        i.version === l.__version
          ? i.fog && l.fog !== s
            ? Et(i, e, r)
            : l.environment !== n
            ? Et(i, e, r)
            : l.needsLights && l.lightsStateVersion !== u.state.version
            ? Et(i, e, r)
            : void 0 === l.numClippingPlanes ||
              (l.numClippingPlanes === st.numPlanes &&
                l.numIntersection === st.numIntersection)
            ? l.outputEncoding !== o
              ? Et(i, e, r)
              : l.envMap !== h && Et(i, e, r)
            : Et(i, e, r)
          : (Et(i, e, r), (l.__version = i.version));
        let c = !1,
          p = !1,
          d = !1;
        const m = l.program,
          y = m.getUniforms(),
          x = l.uniforms;
        if (
          (j.useProgram(m.program) && ((c = !0), (p = !0), (d = !0)),
          i.id !== _ && ((_ = i.id), (p = !0)),
          c || E !== t)
        ) {
          if (
            (y.setValue(ct, "projectionMatrix", t.projectionMatrix),
            X.logarithmicDepthBuffer &&
              y.setValue(
                ct,
                "logDepthBufFC",
                2 / (Math.log(t.far + 1) / Math.LN2),
              ),
            E !== t && ((E = t), (p = !0), (d = !0)),
            i.isShaderMaterial ||
              i.isMeshPhongMaterial ||
              i.isMeshToonMaterial ||
              i.isMeshStandardMaterial ||
              i.envMap)
          ) {
            const e = y.map.cameraPosition;
            void 0 !== e &&
              e.setValue(ct, G.setFromMatrixPosition(t.matrixWorld));
          }
          (i.isMeshPhongMaterial ||
            i.isMeshToonMaterial ||
            i.isMeshLambertMaterial ||
            i.isMeshBasicMaterial ||
            i.isMeshStandardMaterial ||
            i.isShaderMaterial) &&
            y.setValue(ct, "isOrthographic", !0 === t.isOrthographicCamera),
            (i.isMeshPhongMaterial ||
              i.isMeshToonMaterial ||
              i.isMeshLambertMaterial ||
              i.isMeshBasicMaterial ||
              i.isMeshStandardMaterial ||
              i.isShaderMaterial ||
              i.isShadowMaterial ||
              i.skinning) &&
              y.setValue(ct, "viewMatrix", t.matrixWorldInverse);
        }
        if (i.skinning) {
          y.setOptional(ct, r, "bindMatrix"),
            y.setOptional(ct, r, "bindMatrixInverse");
          const t = r.skeleton;
          if (t) {
            const e = t.bones;
            if (X.floatVertexTextures) {
              if (void 0 === t.boneTexture) {
                let i = Math.sqrt(4 * e.length);
                (i = a.ceilPowerOfTwo(i)), (i = Math.max(i, 4));
                const r = new Float32Array(i * i * 4);
                r.set(t.boneMatrices);
                const s = new bi(r, i, i, le, ee);
                (t.boneMatrices = r),
                  (t.boneTexture = s),
                  (t.boneTextureSize = i);
              }
              y.setValue(ct, "boneTexture", t.boneTexture, Z),
                y.setValue(ct, "boneTextureSize", t.boneTextureSize);
            } else y.setOptional(ct, t, "boneMatrices");
          }
        }
        var b, v;
        return (
          (p || l.receiveShadow !== r.receiveShadow) &&
            ((l.receiveShadow = r.receiveShadow),
            y.setValue(ct, "receiveShadow", r.receiveShadow)),
          p &&
            (y.setValue(ct, "toneMappingExposure", g.toneMappingExposure),
            l.needsLights &&
              ((v = d),
              ((b = x).ambientLightColor.needsUpdate = v),
              (b.lightProbe.needsUpdate = v),
              (b.directionalLights.needsUpdate = v),
              (b.directionalLightShadows.needsUpdate = v),
              (b.pointLights.needsUpdate = v),
              (b.pointLightShadows.needsUpdate = v),
              (b.spotLights.needsUpdate = v),
              (b.spotLightShadows.needsUpdate = v),
              (b.rectAreaLights.needsUpdate = v),
              (b.hemisphereLights.needsUpdate = v)),
            s && i.fog && et.refreshFogUniforms(x, s),
            et.refreshMaterialUniforms(x, i, z, F),
            Ln.upload(ct, l.uniformsList, x, Z)),
          i.isShaderMaterial &&
            !0 === i.uniformsNeedUpdate &&
            (Ln.upload(ct, l.uniformsList, x, Z), (i.uniformsNeedUpdate = !1)),
          i.isSpriteMaterial && y.setValue(ct, "center", r.center),
          y.setValue(ct, "modelViewMatrix", r.modelViewMatrix),
          y.setValue(ct, "normalMatrix", r.normalMatrix),
          y.setValue(ct, "modelMatrix", r.matrixWorld),
          m
        );
      }
      Mt.setAnimationLoop(function (t) {
        mt.isPresenting || (vt && vt(t));
      }),
        (this.setAnimationLoop = function (t) {
          (vt = t), mt.setAnimationLoop(t), null === t ? Mt.stop() : Mt.start();
        }),
        (this.render = function (t, e) {
          let i, r;
          if (
            (void 0 !== arguments[2] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.",
              ),
              (i = arguments[2])),
            void 0 !== arguments[3] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.",
              ),
              (r = arguments[3])),
            void 0 !== e && !0 !== e.isCamera)
          )
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
            );
          if (!0 === y) return;
          ut.resetDefaultState(),
            (_ = -1),
            (E = null),
            !0 === t.autoUpdate && t.updateMatrixWorld(),
            null === e.parent && e.updateMatrixWorld(),
            !0 === mt.enabled &&
              !0 === mt.isPresenting &&
              (e = mt.getCamera(e)),
            !0 === t.isScene && t.onBeforeRender(g, t, e, i || M),
            (f = rt.get(t, e)).init(),
            k.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            O.setFromProjectionMatrix(k),
            (I = this.localClippingEnabled),
            (D = st.init(this.clippingPlanes, I, e)),
            (m = it.get(t, e)).init(),
            (function t(e, i, r, s) {
              if (!1 === e.visible) return;
              const n = e.layers.test(i.layers);
              if (n)
                if (e.isGroup) r = e.renderOrder;
                else if (e.isLOD) !0 === e.autoUpdate && e.update(i);
                else if (e.isLight)
                  f.pushLight(e), e.castShadow && f.pushShadow(e);
                else if (e.isSprite) {
                  if (!e.frustumCulled || O.intersectsSprite(e)) {
                    s && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k);
                    const t = $.update(e),
                      i = e.material;
                    i.visible && m.push(e, t, i, r, G.z, null);
                  }
                } else if (e.isImmediateRenderObject)
                  s && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k),
                    m.push(e, null, e.material, r, G.z, null);
                else if (
                  (e.isMesh || e.isLine || e.isPoints) &&
                  (e.isSkinnedMesh &&
                    e.skeleton.frame !== q.render.frame &&
                    (e.skeleton.update(), (e.skeleton.frame = q.render.frame)),
                  !e.frustumCulled || O.intersectsObject(e))
                ) {
                  s && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k);
                  const t = $.update(e),
                    i = e.material;
                  if (Array.isArray(i)) {
                    const s = t.groups;
                    for (let n = 0, a = s.length; n < a; n++) {
                      const a = s[n],
                        o = i[a.materialIndex];
                      o && o.visible && m.push(e, t, o, r, G.z, a);
                    }
                  } else i.visible && m.push(e, t, i, r, G.z, null);
                }
              const a = e.children;
              for (let e = 0, n = a.length; e < n; e++) t(a[e], i, r, s);
            })(t, e, 0, g.sortObjects),
            m.finish(),
            !0 === g.sortObjects && m.sort(P, N),
            !0 === D && st.beginShadows();
          const s = f.state.shadowsArray;
          ft.render(s, t, e),
            f.setupLights(e),
            !0 === D && st.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            void 0 !== i && this.setRenderTarget(i),
            nt.render(m, t, e, r);
          const n = m.opaque,
            a = m.transparent;
          n.length > 0 && wt(n, t, e),
            a.length > 0 && wt(a, t, e),
            !0 === t.isScene && t.onAfterRender(g, t, e),
            null !== M &&
              (Z.updateRenderTargetMipmap(M),
              Z.updateMultisampleRenderTarget(M)),
            j.buffers.depth.setTest(!0),
            j.buffers.depth.setMask(!0),
            j.buffers.color.setMask(!0),
            j.setPolygonOffset(!1),
            (m = null),
            (f = null);
        }),
        (this.setFramebuffer = function (t) {
          x !== t && null === M && ct.bindFramebuffer(ct.FRAMEBUFFER, t),
            (x = t);
        }),
        (this.getActiveCubeFace = function () {
          return b;
        }),
        (this.getActiveMipmapLevel = function () {
          return v;
        }),
        (this.getRenderList = function () {
          return m;
        }),
        (this.setRenderList = function (t) {
          m = t;
        }),
        (this.getRenderState = function () {
          return f;
        }),
        (this.setRenderState = function (t) {
          f = t;
        }),
        (this.getRenderTarget = function () {
          return M;
        }),
        (this.setRenderTarget = function (t, e = 0, i = 0) {
          (M = t),
            (b = e),
            (v = i),
            t &&
              void 0 === Y.get(t).__webglFramebuffer &&
              Z.setupRenderTarget(t);
          let r = x,
            s = !1;
          if (t) {
            const i = Y.get(t).__webglFramebuffer;
            t.isWebGLCubeRenderTarget
              ? ((r = i[e]), (s = !0))
              : (r = t.isWebGLMultisampleRenderTarget
                  ? Y.get(t).__webglMultisampledFramebuffer
                  : i),
              S.copy(t.viewport),
              A.copy(t.scissor),
              (R = t.scissorTest);
          } else
            S.copy(U).multiplyScalar(z).floor(),
              A.copy(B).multiplyScalar(z).floor(),
              (R = C);
          if (
            (w !== r && (ct.bindFramebuffer(ct.FRAMEBUFFER, r), (w = r)),
            j.viewport(S),
            j.scissor(A),
            j.setScissorTest(R),
            s)
          ) {
            const r = Y.get(t.texture);
            ct.framebufferTexture2D(
              ct.FRAMEBUFFER,
              ct.COLOR_ATTACHMENT0,
              ct.TEXTURE_CUBE_MAP_POSITIVE_X + e,
              r.__webglTexture,
              i,
            );
          }
        }),
        (this.readRenderTargetPixels = function (t, e, i, r, s, n, a) {
          if (!t || !t.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
            );
          let o = Y.get(t).__webglFramebuffer;
          if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
            let a = !1;
            o !== w && (ct.bindFramebuffer(ct.FRAMEBUFFER, o), (a = !0));
            try {
              const o = t.texture,
                h = o.format,
                l = o.type;
              if (
                h !== le &&
                lt.convert(h) !==
                  ct.getParameter(ct.IMPLEMENTATION_COLOR_READ_FORMAT)
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
                );
              if (
                !(
                  l === Zt ||
                  lt.convert(l) ===
                    ct.getParameter(ct.IMPLEMENTATION_COLOR_READ_TYPE) ||
                  (l === ee &&
                    (X.isWebGL2 ||
                      H.get("OES_texture_float") ||
                      H.get("WEBGL_color_buffer_float"))) ||
                  (l === ie &&
                    (X.isWebGL2
                      ? H.get("EXT_color_buffer_float")
                      : H.get("EXT_color_buffer_half_float")))
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
                );
              ct.checkFramebufferStatus(ct.FRAMEBUFFER) ===
              ct.FRAMEBUFFER_COMPLETE
                ? e >= 0 &&
                  e <= t.width - r &&
                  i >= 0 &&
                  i <= t.height - s &&
                  ct.readPixels(e, i, r, s, lt.convert(h), lt.convert(l), n)
                : console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.",
                  );
            } finally {
              a && ct.bindFramebuffer(ct.FRAMEBUFFER, w);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (t, e, i) {
          void 0 === i && (i = 0);
          const r = Math.pow(2, -i),
            s = Math.floor(e.image.width * r),
            n = Math.floor(e.image.height * r),
            a = lt.convert(e.format);
          Z.setTexture2D(e, 0),
            ct.copyTexImage2D(ct.TEXTURE_2D, i, a, t.x, t.y, s, n, 0),
            j.unbindTexture();
        }),
        (this.copyTextureToTexture = function (t, e, i, r) {
          void 0 === r && (r = 0);
          const s = e.image.width,
            n = e.image.height,
            a = lt.convert(i.format),
            o = lt.convert(i.type);
          Z.setTexture2D(i, 0),
            ct.pixelStorei(ct.UNPACK_FLIP_Y_WEBGL, i.flipY),
            ct.pixelStorei(
              ct.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              i.premultiplyAlpha,
            ),
            ct.pixelStorei(ct.UNPACK_ALIGNMENT, i.unpackAlignment),
            e.isDataTexture
              ? ct.texSubImage2D(
                  ct.TEXTURE_2D,
                  r,
                  t.x,
                  t.y,
                  s,
                  n,
                  a,
                  o,
                  e.image.data,
                )
              : e.isCompressedTexture
              ? ct.compressedTexSubImage2D(
                  ct.TEXTURE_2D,
                  r,
                  t.x,
                  t.y,
                  e.mipmaps[0].width,
                  e.mipmaps[0].height,
                  a,
                  e.mipmaps[0].data,
                )
              : ct.texSubImage2D(ct.TEXTURE_2D, r, t.x, t.y, a, o, e.image),
            0 === r && i.generateMipmaps && ct.generateMipmap(ct.TEXTURE_2D),
            j.unbindTexture();
        }),
        (this.initTexture = function (t) {
          Z.setTexture2D(t, 0), j.unbindTexture();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this }),
          );
    }
    (jn.prototype = Object.create(xr.prototype)),
      (jn.prototype.constructor = jn),
      (jn.prototype.isMeshDepthMaterial = !0),
      (jn.prototype.copy = function (t) {
        return (
          xr.prototype.copy.call(this, t),
          (this.depthPacking = t.depthPacking),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          this
        );
      }),
      (qn.prototype = Object.create(xr.prototype)),
      (qn.prototype.constructor = qn),
      (qn.prototype.isMeshDistanceMaterial = !0),
      (qn.prototype.copy = function (t) {
        return (
          xr.prototype.copy.call(this, t),
          this.referencePosition.copy(t.referencePosition),
          (this.nearDistance = t.nearDistance),
          (this.farDistance = t.farDistance),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          this
        );
      });
    class ta extends D {
      constructor() {
        super(),
          Object.defineProperty(this, "isScene", { value: !0 }),
          (this.type = "Scene"),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this }),
            );
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          null !== t.background && (this.background = t.background.clone()),
          null !== t.environment && (this.environment = t.environment.clone()),
          null !== t.fog && (this.fog = t.fog.clone()),
          null !== t.overrideMaterial &&
            (this.overrideMaterial = t.overrideMaterial.clone()),
          (this.autoUpdate = t.autoUpdate),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this
        );
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          null !== this.background &&
            (e.object.background = this.background.toJSON(t)),
          null !== this.environment &&
            (e.object.environment = this.environment.toJSON(t)),
          null !== this.fog && (e.object.fog = this.fog.toJSON()),
          e
        );
      }
    }
    class ea {
      constructor({
        width: t,
        height: e,
        backgroundColor: i,
        z: r,
        pixelRatio: s,
        canvas: n,
      }) {
        (this.width = t),
          (this.height = e),
          (this.meshCount = 0),
          (this.meshListeners = []),
          (this.devicePixelRatio = s ? Math.min(1.6, s) : 1),
          (this.renderer = new $n({
            antialias: !0,
            alpha: !0,
            canvas: n,
            failIfMajorPerformanceCaveat: !0,
          })),
          this.renderer.setPixelRatio(this.devicePixelRatio),
          void 0 !== i && this.renderer.setClearColor(new q(i)),
          (this.scene = new ta()),
          (this.camera = new k(50, this.width / this.height, 1, 20)),
          this.camera.position.set(0, 0, r),
          (this.update = this.update.bind(this)),
          (this.resize = this.resize.bind(this)),
          this.resize(t, e);
      }
      add(t) {
        this.scene.add(t),
          t.update && (this.meshListeners.push(t.update), this.meshCount++);
      }
      remove(t) {
        if ((this.scene.remove(t), !t.update)) return;
        const e = this.meshListeners.indexOf(t.update);
        e > -1 && this.meshListeners.splice(e, 1), this.meshCount--;
      }
      start() {
        this.update();
      }
      update() {
        let t = this.meshCount;
        for (; --t >= 0; ) this.meshListeners[t].apply(this, null);
        this.render(),
          (this.animationFrame = requestAnimationFrame(this.update));
      }
      render() {
        this.renderer.render(this.scene, this.camera);
      }
      resize(t, e) {
        (this.width = t),
          (this.height = e),
          (this.camera.aspect = this.width / this.height),
          this.camera.updateProjectionMatrix(),
          this.resizeRender();
      }
      resizeRender() {
        this.renderer.setSize(this.width, this.height, !1);
      }
      pause() {
        this.animationFrame && cancelAnimationFrame(this.animationFrame);
      }
      destroy() {
        this.pause(),
          (this.scene = null),
          (this.renderer = null),
          (this.meshListeners = []);
      }
    }
    class ia extends ea {}
    let ra = 0;
    const sa = new c(),
      na = new D(),
      aa = new h();
    function oa() {
      Object.defineProperty(this, "id", { value: (ra += 2) }),
        (this.uuid = a.generateUUID()),
        (this.name = ""),
        (this.type = "Geometry"),
        (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.elementsNeedUpdate = !1),
        (this.verticesNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.lineDistancesNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    function ha() {
      mr.call(this),
        (this.type = "MeshLine"),
        (this.positions = []),
        (this.previous = []),
        (this.next = []),
        (this.side = []),
        (this.width = []),
        (this.indices_array = []),
        (this.uvs = []),
        (this.counters = []),
        (this._points = []),
        (this._geom = null),
        (this.widthCallback = null),
        Object.defineProperties(this, {
          geometry: {
            enumerable: !0,
            get: function () {
              return this;
            },
          },
          geom: {
            enumerable: !0,
            get: function () {
              return this._geom;
            },
            set: function (t) {
              this.setGeometry(t, this.widthCallback);
            },
          },
          points: {
            enumerable: !0,
            get: function () {
              return this._points;
            },
            set: function (t) {
              this.setPoints(t, this.widthCallback);
            },
          },
        });
    }
    function la(t, e, i, r, s) {
      let n;
      if (
        ((t = t.subarray || t.slice ? t : t.buffer),
        (i = i.subarray || i.slice ? i : i.buffer),
        (t = e
          ? t.subarray
            ? t.subarray(e, s && e + s)
            : t.slice(e, s && e + s)
          : t),
        i.set)
      )
        i.set(t, r);
      else for (n = 0; n < t.length; n++) i[n + r] = t[n];
      return i;
    }
    (oa.prototype = Object.assign(Object.create(b.prototype), {
      constructor: oa,
      isGeometry: !0,
      applyMatrix4: function (t) {
        const e = new E().getNormalMatrix(t);
        for (let e = 0, i = this.vertices.length; e < i; e++) {
          this.vertices[e].applyMatrix4(t);
        }
        for (let t = 0, i = this.faces.length; t < i; t++) {
          const i = this.faces[t];
          i.normal.applyMatrix3(e).normalize();
          for (let t = 0, r = i.vertexNormals.length; t < r; t++)
            i.vertexNormals[t].applyMatrix3(e).normalize();
        }
        return (
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          (this.verticesNeedUpdate = !0),
          (this.normalsNeedUpdate = !0),
          this
        );
      },
      rotateX: function (t) {
        return sa.makeRotationX(t), this.applyMatrix4(sa), this;
      },
      rotateY: function (t) {
        return sa.makeRotationY(t), this.applyMatrix4(sa), this;
      },
      rotateZ: function (t) {
        return sa.makeRotationZ(t), this.applyMatrix4(sa), this;
      },
      translate: function (t, e, i) {
        return sa.makeTranslation(t, e, i), this.applyMatrix4(sa), this;
      },
      scale: function (t, e, i) {
        return sa.makeScale(t, e, i), this.applyMatrix4(sa), this;
      },
      lookAt: function (t) {
        return (
          na.lookAt(t), na.updateMatrix(), this.applyMatrix4(na.matrix), this
        );
      },
      fromBufferGeometry: function (t) {
        const e = this,
          i = null !== t.index ? t.index : void 0,
          r = t.attributes;
        if (void 0 === r.position)
          return (
            console.error(
              "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.",
            ),
            this
          );
        const s = r.position,
          n = r.normal,
          a = r.color,
          o = r.uv,
          l = r.uv2;
        void 0 !== l && (this.faceVertexUvs[1] = []);
        for (let t = 0; t < s.count; t++)
          e.vertices.push(new h().fromBufferAttribute(s, t)),
            void 0 !== a && e.colors.push(new q().fromBufferAttribute(a, t));
        function u(t, i, r, s) {
          const u =
              void 0 === a
                ? []
                : [
                    e.colors[t].clone(),
                    e.colors[i].clone(),
                    e.colors[r].clone(),
                  ],
            c =
              void 0 === n
                ? []
                : [
                    new h().fromBufferAttribute(n, t),
                    new h().fromBufferAttribute(n, i),
                    new h().fromBufferAttribute(n, r),
                  ],
            p = new Gr(t, i, r, c, u, s);
          e.faces.push(p),
            void 0 !== o &&
              e.faceVertexUvs[0].push([
                new mi().fromBufferAttribute(o, t),
                new mi().fromBufferAttribute(o, i),
                new mi().fromBufferAttribute(o, r),
              ]),
            void 0 !== l &&
              e.faceVertexUvs[1].push([
                new mi().fromBufferAttribute(l, t),
                new mi().fromBufferAttribute(l, i),
                new mi().fromBufferAttribute(l, r),
              ]);
        }
        const c = t.groups;
        if (c.length > 0)
          for (let t = 0; t < c.length; t++) {
            const e = c[t],
              r = e.start;
            for (let t = r, s = r + e.count; t < s; t += 3)
              void 0 !== i
                ? u(i.getX(t), i.getX(t + 1), i.getX(t + 2), e.materialIndex)
                : u(t, t + 1, t + 2, e.materialIndex);
          }
        else if (void 0 !== i)
          for (let t = 0; t < i.count; t += 3)
            u(i.getX(t), i.getX(t + 1), i.getX(t + 2));
        else for (let t = 0; t < s.count; t += 3) u(t, t + 1, t + 2);
        return (
          this.computeFaceNormals(),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          this
        );
      },
      center: function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(aa).negate(),
          this.translate(aa.x, aa.y, aa.z),
          this
        );
      },
      normalize: function () {
        this.computeBoundingSphere();
        const t = this.boundingSphere.center,
          e = this.boundingSphere.radius,
          i = 0 === e ? 1 : 1 / e,
          r = new c();
        return (
          r.set(
            i,
            0,
            0,
            -i * t.x,
            0,
            i,
            0,
            -i * t.y,
            0,
            0,
            i,
            -i * t.z,
            0,
            0,
            0,
            1,
          ),
          this.applyMatrix4(r),
          this
        );
      },
      computeFaceNormals: function () {
        const t = new h(),
          e = new h();
        for (let i = 0, r = this.faces.length; i < r; i++) {
          const r = this.faces[i],
            s = this.vertices[r.a],
            n = this.vertices[r.b],
            a = this.vertices[r.c];
          t.subVectors(a, n),
            e.subVectors(s, n),
            t.cross(e),
            t.normalize(),
            r.normal.copy(t);
        }
      },
      computeVertexNormals: function (t) {
        void 0 === t && (t = !0);
        const e = new Array(this.vertices.length);
        for (let t = 0, i = this.vertices.length; t < i; t++) e[t] = new h();
        if (t) {
          const t = new h(),
            i = new h();
          for (let r = 0, s = this.faces.length; r < s; r++) {
            const s = this.faces[r],
              n = this.vertices[s.a],
              a = this.vertices[s.b],
              o = this.vertices[s.c];
            t.subVectors(o, a),
              i.subVectors(n, a),
              t.cross(i),
              e[s.a].add(t),
              e[s.b].add(t),
              e[s.c].add(t);
          }
        } else {
          this.computeFaceNormals();
          for (let t = 0, i = this.faces.length; t < i; t++) {
            const i = this.faces[t];
            e[i.a].add(i.normal), e[i.b].add(i.normal), e[i.c].add(i.normal);
          }
        }
        for (let t = 0, i = this.vertices.length; t < i; t++) e[t].normalize();
        for (let t = 0, i = this.faces.length; t < i; t++) {
          const i = this.faces[t],
            r = i.vertexNormals;
          3 === r.length
            ? (r[0].copy(e[i.a]), r[1].copy(e[i.b]), r[2].copy(e[i.c]))
            : ((r[0] = e[i.a].clone()),
              (r[1] = e[i.b].clone()),
              (r[2] = e[i.c].clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeFlatVertexNormals: function () {
        this.computeFaceNormals();
        for (let t = 0, e = this.faces.length; t < e; t++) {
          const e = this.faces[t],
            i = e.vertexNormals;
          3 === i.length
            ? (i[0].copy(e.normal), i[1].copy(e.normal), i[2].copy(e.normal))
            : ((i[0] = e.normal.clone()),
              (i[1] = e.normal.clone()),
              (i[2] = e.normal.clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeMorphNormals: function () {
        for (let t = 0, e = this.faces.length; t < e; t++) {
          const e = this.faces[t];
          e.__originalFaceNormal
            ? e.__originalFaceNormal.copy(e.normal)
            : (e.__originalFaceNormal = e.normal.clone()),
            e.__originalVertexNormals || (e.__originalVertexNormals = []);
          for (let t = 0, i = e.vertexNormals.length; t < i; t++)
            e.__originalVertexNormals[t]
              ? e.__originalVertexNormals[t].copy(e.vertexNormals[t])
              : (e.__originalVertexNormals[t] = e.vertexNormals[t].clone());
        }
        const t = new oa();
        t.faces = this.faces;
        for (let e = 0, i = this.morphTargets.length; e < i; e++) {
          if (!this.morphNormals[e]) {
            (this.morphNormals[e] = {}),
              (this.morphNormals[e].faceNormals = []),
              (this.morphNormals[e].vertexNormals = []);
            const t = this.morphNormals[e].faceNormals,
              i = this.morphNormals[e].vertexNormals;
            for (let e = 0, r = this.faces.length; e < r; e++) {
              const e = new h(),
                r = { a: new h(), b: new h(), c: new h() };
              t.push(e), i.push(r);
            }
          }
          const i = this.morphNormals[e];
          (t.vertices = this.morphTargets[e].vertices),
            t.computeFaceNormals(),
            t.computeVertexNormals();
          for (let t = 0, e = this.faces.length; t < e; t++) {
            const e = this.faces[t],
              r = i.faceNormals[t],
              s = i.vertexNormals[t];
            r.copy(e.normal),
              s.a.copy(e.vertexNormals[0]),
              s.b.copy(e.vertexNormals[1]),
              s.c.copy(e.vertexNormals[2]);
          }
        }
        for (let t = 0, e = this.faces.length; t < e; t++) {
          const e = this.faces[t];
          (e.normal = e.__originalFaceNormal),
            (e.vertexNormals = e.__originalVertexNormals);
        }
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new vi()),
          this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new Ci()),
          this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function (t, e, i) {
        if (!t || !t.isGeometry)
          return void console.error(
            "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
            t,
          );
        let r;
        const s = this.vertices.length,
          n = this.vertices,
          a = t.vertices,
          o = this.faces,
          h = t.faces,
          l = this.colors,
          u = t.colors;
        void 0 === i && (i = 0),
          void 0 !== e && (r = new E().getNormalMatrix(e));
        for (let t = 0, i = a.length; t < i; t++) {
          const i = a[t].clone();
          void 0 !== e && i.applyMatrix4(e), n.push(i);
        }
        for (let t = 0, e = u.length; t < e; t++) l.push(u[t].clone());
        for (let t = 0, e = h.length; t < e; t++) {
          const e = h[t];
          let n, a;
          const l = e.vertexNormals,
            u = e.vertexColors,
            c = new Gr(e.a + s, e.b + s, e.c + s);
          c.normal.copy(e.normal),
            void 0 !== r && c.normal.applyMatrix3(r).normalize();
          for (let t = 0, e = l.length; t < e; t++)
            (n = l[t].clone()),
              void 0 !== r && n.applyMatrix3(r).normalize(),
              c.vertexNormals.push(n);
          c.color.copy(e.color);
          for (let t = 0, e = u.length; t < e; t++)
            (a = u[t]), c.vertexColors.push(a.clone());
          (c.materialIndex = e.materialIndex + i), o.push(c);
        }
        for (let e = 0, i = t.faceVertexUvs.length; e < i; e++) {
          const i = t.faceVertexUvs[e];
          void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
          for (let t = 0, r = i.length; t < r; t++) {
            const r = i[t],
              s = [];
            for (let t = 0, e = r.length; t < e; t++) s.push(r[t].clone());
            this.faceVertexUvs[e].push(s);
          }
        }
      },
      mergeMesh: function (t) {
        t && t.isMesh
          ? (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix))
          : console.error(
              "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
              t,
            );
      },
      mergeVertices: function () {
        const t = {},
          e = [],
          i = [],
          r = Math.pow(10, 4);
        for (let s = 0, n = this.vertices.length; s < n; s++) {
          const n = this.vertices[s],
            a =
              Math.round(n.x * r) +
              "_" +
              Math.round(n.y * r) +
              "_" +
              Math.round(n.z * r);
          void 0 === t[a]
            ? ((t[a] = s), e.push(this.vertices[s]), (i[s] = e.length - 1))
            : (i[s] = i[t[a]]);
        }
        const s = [];
        for (let t = 0, e = this.faces.length; t < e; t++) {
          const e = this.faces[t];
          (e.a = i[e.a]), (e.b = i[e.b]), (e.c = i[e.c]);
          const r = [e.a, e.b, e.c];
          for (let e = 0; e < 3; e++)
            if (r[e] === r[(e + 1) % 3]) {
              s.push(t);
              break;
            }
        }
        for (let t = s.length - 1; t >= 0; t--) {
          const e = s[t];
          this.faces.splice(e, 1);
          for (let t = 0, i = this.faceVertexUvs.length; t < i; t++)
            this.faceVertexUvs[t].splice(e, 1);
        }
        const n = this.vertices.length - e.length;
        return (this.vertices = e), n;
      },
      setFromPoints: function (t) {
        this.vertices = [];
        for (let e = 0, i = t.length; e < i; e++) {
          const i = t[e];
          this.vertices.push(new h(i.x, i.y, i.z || 0));
        }
        return this;
      },
      sortFacesByMaterialIndex: function () {
        const t = this.faces,
          e = t.length;
        for (let i = 0; i < e; i++) t[i]._id = i;
        t.sort(function (t, e) {
          return t.materialIndex - e.materialIndex;
        });
        const i = this.faceVertexUvs[0],
          r = this.faceVertexUvs[1];
        let s, n;
        i && i.length === e && (s = []), r && r.length === e && (n = []);
        for (let a = 0; a < e; a++) {
          const e = t[a]._id;
          s && s.push(i[e]), n && n.push(r[e]);
        }
        s && (this.faceVertexUvs[0] = s), n && (this.faceVertexUvs[1] = n);
      },
      toJSON: function () {
        const t = {
          metadata: {
            version: 4.5,
            type: "Geometry",
            generator: "Geometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          void 0 !== this.parameters)
        ) {
          const e = this.parameters;
          for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
          return t;
        }
        const e = [];
        for (let t = 0; t < this.vertices.length; t++) {
          const i = this.vertices[t];
          e.push(i.x, i.y, i.z);
        }
        const i = [],
          r = [],
          s = {},
          n = [],
          a = {},
          o = [],
          h = {};
        for (let t = 0; t < this.faces.length; t++) {
          const e = this.faces[t],
            r = !0,
            s = !1,
            n = void 0 !== this.faceVertexUvs[0][t],
            a = e.normal.length() > 0,
            o = e.vertexNormals.length > 0,
            h = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
            d = e.vertexColors.length > 0;
          let m = 0;
          if (
            ((m = l(m, 0, 0)),
            (m = l(m, 1, r)),
            (m = l(m, 2, s)),
            (m = l(m, 3, n)),
            (m = l(m, 4, a)),
            (m = l(m, 5, o)),
            (m = l(m, 6, h)),
            (m = l(m, 7, d)),
            i.push(m),
            i.push(e.a, e.b, e.c),
            i.push(e.materialIndex),
            n)
          ) {
            const e = this.faceVertexUvs[0][t];
            i.push(p(e[0]), p(e[1]), p(e[2]));
          }
          if ((a && i.push(u(e.normal)), o)) {
            const t = e.vertexNormals;
            i.push(u(t[0]), u(t[1]), u(t[2]));
          }
          if ((h && i.push(c(e.color)), d)) {
            const t = e.vertexColors;
            i.push(c(t[0]), c(t[1]), c(t[2]));
          }
        }
        function l(t, e, i) {
          return i ? t | (1 << e) : t & ~(1 << e);
        }
        function u(t) {
          const e = t.x.toString() + t.y.toString() + t.z.toString();
          return void 0 !== s[e]
            ? s[e]
            : ((s[e] = r.length / 3), r.push(t.x, t.y, t.z), s[e]);
        }
        function c(t) {
          const e = t.r.toString() + t.g.toString() + t.b.toString();
          return void 0 !== a[e]
            ? a[e]
            : ((a[e] = n.length), n.push(t.getHex()), a[e]);
        }
        function p(t) {
          const e = t.x.toString() + t.y.toString();
          return void 0 !== h[e]
            ? h[e]
            : ((h[e] = o.length / 2), o.push(t.x, t.y), h[e]);
        }
        return (
          (t.data = {}),
          (t.data.vertices = e),
          (t.data.normals = r),
          n.length > 0 && (t.data.colors = n),
          o.length > 0 && (t.data.uvs = [o]),
          (t.data.faces = i),
          t
        );
      },
      clone: function () {
        return new oa().copy(this);
      },
      copy: function (t) {
        (this.vertices = []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.name = t.name);
        const e = t.vertices;
        for (let t = 0, i = e.length; t < i; t++)
          this.vertices.push(e[t].clone());
        const i = t.colors;
        for (let t = 0, e = i.length; t < e; t++)
          this.colors.push(i[t].clone());
        const r = t.faces;
        for (let t = 0, e = r.length; t < e; t++) this.faces.push(r[t].clone());
        for (let e = 0, i = t.faceVertexUvs.length; e < i; e++) {
          const i = t.faceVertexUvs[e];
          void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
          for (let t = 0, r = i.length; t < r; t++) {
            const r = i[t],
              s = [];
            for (let t = 0, e = r.length; t < e; t++) {
              const e = r[t];
              s.push(e.clone());
            }
            this.faceVertexUvs[e].push(s);
          }
        }
        const s = t.morphTargets;
        for (let t = 0, e = s.length; t < e; t++) {
          const e = {};
          if (((e.name = s[t].name), void 0 !== s[t].vertices)) {
            e.vertices = [];
            for (let i = 0, r = s[t].vertices.length; i < r; i++)
              e.vertices.push(s[t].vertices[i].clone());
          }
          if (void 0 !== s[t].normals) {
            e.normals = [];
            for (let i = 0, r = s[t].normals.length; i < r; i++)
              e.normals.push(s[t].normals[i].clone());
          }
          this.morphTargets.push(e);
        }
        const n = t.morphNormals;
        for (let t = 0, e = n.length; t < e; t++) {
          const e = {};
          if (void 0 !== n[t].vertexNormals) {
            e.vertexNormals = [];
            for (let i = 0, r = n[t].vertexNormals.length; i < r; i++) {
              const r = n[t].vertexNormals[i],
                s = {};
              (s.a = r.a.clone()),
                (s.b = r.b.clone()),
                (s.c = r.c.clone()),
                e.vertexNormals.push(s);
            }
          }
          if (void 0 !== n[t].faceNormals) {
            e.faceNormals = [];
            for (let i = 0, r = n[t].faceNormals.length; i < r; i++)
              e.faceNormals.push(n[t].faceNormals[i].clone());
          }
          this.morphNormals.push(e);
        }
        const a = t.skinWeights;
        for (let t = 0, e = a.length; t < e; t++)
          this.skinWeights.push(a[t].clone());
        const o = t.skinIndices;
        for (let t = 0, e = o.length; t < e; t++)
          this.skinIndices.push(o[t].clone());
        const h = t.lineDistances;
        for (let t = 0, e = h.length; t < e; t++) this.lineDistances.push(h[t]);
        const l = t.boundingBox;
        null !== l && (this.boundingBox = l.clone());
        const u = t.boundingSphere;
        return (
          null !== u && (this.boundingSphere = u.clone()),
          (this.elementsNeedUpdate = t.elementsNeedUpdate),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    })),
      (ha.prototype = Object.create(mr.prototype)),
      (ha.prototype.constructor = ha),
      (ha.prototype.isMeshLine = !0),
      (ha.prototype.setGeometry = function (t, e) {
        (this._geometry = t),
          t instanceof oa
            ? this.setPoints(t.vertices, e)
            : t instanceof mr
            ? this.setPoints(t.getAttribute("position").array, e)
            : this.setPoints(t, e);
      }),
      (ha.prototype.setPoints = function (t, e) {
        if (t instanceof Float32Array || t instanceof Array) {
          if (
            ((this._points = t),
            (this.widthCallback = e),
            (this.positions = []),
            (this.counters = []),
            t.length && t[0] instanceof h)
          )
            for (let e = 0; e < t.length; e++) {
              let i = t[e],
                r = e / t.length;
              this.positions.push(i.x, i.y, i.z),
                this.positions.push(i.x, i.y, i.z),
                this.counters.push(r),
                this.counters.push(r);
            }
          else
            for (let e = 0; e < t.length; e += 3) {
              let i = e / t.length;
              this.positions.push(t[e], t[e + 1], t[e + 2]),
                this.positions.push(t[e], t[e + 1], t[e + 2]),
                this.counters.push(i),
                this.counters.push(i);
            }
          this.process();
        } else
          console.error(
            "ERROR: The BufferArray of points is not instancied correctly.",
          );
      }),
      (ha.prototype.compareV3 = function (t, e) {
        let i = 6 * t,
          r = 6 * e;
        return (
          this.positions[i] === this.positions[r] &&
          this.positions[i + 1] === this.positions[r + 1] &&
          this.positions[i + 2] === this.positions[r + 2]
        );
      }),
      (ha.prototype.copyV3 = function (t) {
        let e = 6 * t;
        return [
          this.positions[e],
          this.positions[e + 1],
          this.positions[e + 2],
        ];
      }),
      (ha.prototype.process = function () {
        let t,
          e,
          i = this.positions.length / 6;
        (this.previous = []),
          (this.next = []),
          (this.side = []),
          (this.width = []),
          (this.indices_array = []),
          (this.uvs = []),
          (e = this.compareV3(0, i - 1) ? this.copyV3(i - 2) : this.copyV3(0)),
          this.previous.push(e[0], e[1], e[2]),
          this.previous.push(e[0], e[1], e[2]);
        for (let r = 0; r < i; r++) {
          if (
            (this.side.push(1),
            this.side.push(-1),
            (t = this.widthCallback ? this.widthCallback(r / (i - 1)) : 1),
            this.width.push(t),
            this.width.push(t),
            this.uvs.push(r / (i - 1), 0),
            this.uvs.push(r / (i - 1), 1),
            r < i - 1)
          ) {
            (e = this.copyV3(r)),
              this.previous.push(e[0], e[1], e[2]),
              this.previous.push(e[0], e[1], e[2]);
            let t = 2 * r;
            this.indices_array.push(t, t + 1, t + 2),
              this.indices_array.push(t + 2, t + 1, t + 3);
          }
          r > 0 &&
            ((e = this.copyV3(r)),
            this.next.push(e[0], e[1], e[2]),
            this.next.push(e[0], e[1], e[2]));
        }
        (e = this.compareV3(i - 1, 0) ? this.copyV3(1) : this.copyV3(i - 1)),
          this.next.push(e[0], e[1], e[2]),
          this.next.push(e[0], e[1], e[2]),
          this._attributes &&
          this._attributes.position.count === this.positions.length
            ? (this._attributes.position.copyArray(
                new Float32Array(this.positions),
              ),
              (this._attributes.position.needsUpdate = !0),
              this._attributes.previous.copyArray(
                new Float32Array(this.previous),
              ),
              (this._attributes.previous.needsUpdate = !0),
              this._attributes.next.copyArray(new Float32Array(this.next)),
              (this._attributes.next.needsUpdate = !0),
              this._attributes.side.copyArray(new Float32Array(this.side)),
              (this._attributes.side.needsUpdate = !0),
              this._attributes.width.copyArray(new Float32Array(this.width)),
              (this._attributes.width.needsUpdate = !0),
              this._attributes.uv.copyArray(new Float32Array(this.uvs)),
              (this._attributes.uv.needsUpdate = !0),
              this._attributes.index.copyArray(
                new Uint16Array(this.indices_array),
              ),
              (this._attributes.index.needsUpdate = !0))
            : (this._attributes = {
                position: new Zi(new Float32Array(this.positions), 3),
                previous: new Zi(new Float32Array(this.previous), 3),
                next: new Zi(new Float32Array(this.next), 3),
                side: new Zi(new Float32Array(this.side), 1),
                width: new Zi(new Float32Array(this.width), 1),
                uv: new Zi(new Float32Array(this.uvs), 2),
                index: new Zi(new Uint16Array(this.indices_array), 1),
                counters: new Zi(new Float32Array(this.counters), 1),
              }),
          this.setAttribute("position", this._attributes.position),
          this.setAttribute("previous", this._attributes.previous),
          this.setAttribute("next", this._attributes.next),
          this.setAttribute("side", this._attributes.side),
          this.setAttribute("width", this._attributes.width),
          this.setAttribute("uv", this._attributes.uv),
          this.setAttribute("counters", this._attributes.counters),
          this.setIndex(this._attributes.index),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }),
      (ha.prototype.advance = function (t) {
        let e = this._attributes.position.array,
          i = this._attributes.previous.array,
          r = this._attributes.next.array,
          s = e.length;
        la(e, 0, i, 0, s),
          la(e, 6, e, 0, s - 6),
          (e[s - 6] = t.x),
          (e[s - 5] = t.y),
          (e[s - 4] = t.z),
          (e[s - 3] = t.x),
          (e[s - 2] = t.y),
          (e[s - 1] = t.z),
          la(e, 6, r, 0, s - 6),
          (r[s - 6] = t.x),
          (r[s - 5] = t.y),
          (r[s - 4] = t.z),
          (r[s - 3] = t.x),
          (r[s - 2] = t.y),
          (r[s - 1] = t.z),
          (this._attributes.position.needsUpdate = !0),
          (this._attributes.previous.needsUpdate = !0),
          (this._attributes.next.needsUpdate = !0);
      });
    const ua = {};
    function ca(t) {
      wr.call(this, {
        uniforms: Object.assign({}, ls.fog, {
          lineWidth: { value: 1 },
          map: { value: null },
          useMap: { value: 0 },
          alphaMap: { value: null },
          useAlphaMap: { value: 0 },
          color: { value: new q(16777215) },
          opacity: { value: 1 },
          resolution: { value: new mi(1, 1) },
          sizeAttenuation: { value: 1 },
          dashArray: { value: 0 },
          dashOffset: { value: 0 },
          dashRatio: { value: 0.5 },
          useDash: { value: 0 },
          visibility: { value: 1 },
          alphaTest: { value: 0 },
          repeat: { value: new mi(1, 1) },
        }),
        precision: "mediump",
        vertexShader: ua.meshline_vert,
        fragmentShader: ua.meshline_frag,
      }),
        (this.type = "MeshLineMaterial"),
        Object.defineProperties(this, {
          lineWidth: {
            enumerable: !0,
            get: function () {
              return this.uniforms.lineWidth.value;
            },
            set: function (t) {
              this.uniforms.lineWidth.value = t;
            },
          },
          map: {
            enumerable: !0,
            get: function () {
              return this.uniforms.map.value;
            },
            set: function (t) {
              this.uniforms.map.value = t;
            },
          },
          useMap: {
            enumerable: !0,
            get: function () {
              return this.uniforms.useMap.value;
            },
            set: function (t) {
              this.uniforms.useMap.value = t;
            },
          },
          alphaMap: {
            enumerable: !0,
            get: function () {
              return this.uniforms.alphaMap.value;
            },
            set: function (t) {
              this.uniforms.alphaMap.value = t;
            },
          },
          useAlphaMap: {
            enumerable: !0,
            get: function () {
              return this.uniforms.useAlphaMap.value;
            },
            set: function (t) {
              this.uniforms.useAlphaMap.value = t;
            },
          },
          color: {
            enumerable: !0,
            get: function () {
              return this.uniforms.color.value;
            },
            set: function (t) {
              this.uniforms.color.value = t;
            },
          },
          opacity: {
            enumerable: !0,
            get: function () {
              return this.uniforms.opacity.value;
            },
            set: function (t) {
              this.uniforms.opacity.value = t;
            },
          },
          resolution: {
            enumerable: !0,
            get: function () {
              return this.uniforms.resolution.value;
            },
            set: function (t) {
              this.uniforms.resolution.value.copy(t);
            },
          },
          sizeAttenuation: {
            enumerable: !0,
            get: function () {
              return this.uniforms.sizeAttenuation.value;
            },
            set: function (t) {
              this.uniforms.sizeAttenuation.value = t;
            },
          },
          dashArray: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashArray.value;
            },
            set: function (t) {
              (this.uniforms.dashArray.value = t),
                (this.useDash = 0 !== t ? 1 : 0);
            },
          },
          dashOffset: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashOffset.value;
            },
            set: function (t) {
              this.uniforms.dashOffset.value = t;
            },
          },
          dashRatio: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashRatio.value;
            },
            set: function (t) {
              this.uniforms.dashRatio.value = t;
            },
          },
          useDash: {
            enumerable: !0,
            get: function () {
              return this.uniforms.useDash.value;
            },
            set: function (t) {
              this.uniforms.useDash.value = t;
            },
          },
          visibility: {
            enumerable: !0,
            get: function () {
              return this.uniforms.visibility.value;
            },
            set: function (t) {
              this.uniforms.visibility.value = t;
            },
          },
          alphaTest: {
            enumerable: !0,
            get: function () {
              return this.uniforms.alphaTest.value;
            },
            set: function (t) {
              this.uniforms.alphaTest.value = t;
            },
          },
          repeat: {
            enumerable: !0,
            get: function () {
              return this.uniforms.repeat.value;
            },
            set: function (t) {
              this.uniforms.repeat.value.copy(t);
            },
          },
        }),
        this.setValues(t);
    }
    (ua.meshline_vert =
      "\n#version 300 es\n#define attribute in\n#define varying out\nprecision mediump float;\nprecision mediump int;\n#define MEDIUM_PRECISION\n#define SHADER_NAME MeshLineMaterial\n#define VERTEX_TEXTURES\n#define GAMMA_FACTOR 2\n#define MAX_BONES 0\n#define BONE_TEXTURE\n#define USE_SIZEATTENUATION\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\nattribute float counters;\n\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform vec3 color;\nuniform float opacity;\nuniform float sizeAttenuation;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounters;\n\nvec2 fix( vec4 i, float aspect ) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    vCounters = counters;\n    return res;\n}\n\nvoid main() {\n    float aspect = resolution.x / resolution.y;\n\n    vColor = vec4( color, opacity );\n    vUV = uv;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4( position, 1.0 );\n    vec4 prevPos = m * vec4( previous, 1.0 );\n    vec4 nextPos = m * vec4( next, 1.0 );\n\n    vec2 currentP = fix( finalPosition, aspect );\n    vec2 prevP = fix( prevPos, aspect );\n    vec2 nextP = fix( nextPos, aspect );\n\n    float w = lineWidth * width;\n\n    vec2 dir;\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\n    else {\n        vec2 dir1 = normalize( currentP - prevP );\n        vec2 dir2 = normalize( nextP - currentP );\n        dir = normalize( dir1 + dir2 );\n\n        vec2 perp = vec2( -dir1.y, dir1.x );\n        vec2 miter = vec2( -dir.y, dir.x );\n        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );\n    }\n\n    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;\n    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\n    normal.xy *= .5 * w;\n    normal *= projectionMatrix;\n    if( sizeAttenuation == 0. ) {\n        normal.xy *= finalPosition.w;\n        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n    }\n\n    finalPosition.xy += normal.xy * side;\n\n    gl_Position = finalPosition;\n\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n}\n".trim()),
      (ua.meshline_frag =
        "\n#version 300 es\n#define varying in\nout mediump vec4 pc_fragColor;\nprecision mediump float;\nprecision mediump int;\n#define MEDIUM_PRECISION\n#define SHADER_NAME MeshLineMaterial\n#define GAMMA_FACTOR 2\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\n\nuniform sampler2D map;\nuniform sampler2D alphaMap;\nuniform float useMap;\nuniform float useAlphaMap;\nuniform float useDash;\nuniform float dashArray;\nuniform float dashOffset;\nuniform float dashRatio;\nuniform float visibility;\nuniform float alphaTest;\nuniform vec2 repeat;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounters;\n\nvoid main() {\nvec4 c = vColor;\n    if( useMap == 1. ) c *= texture( map, vUV * repeat );\n    if( useAlphaMap == 1. ) c.a *= texture( alphaMap, vUV * repeat ).a;\n    if( c.a < alphaTest ) discard;\n    if( useDash == 1. ){\n        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\n    }\n    pc_fragColor = c;\n    pc_fragColor.a *= step(vCounters, visibility);\n}\n".trim()),
      (ca.prototype = Object.create(wr.prototype)),
      (ca.prototype.constructor = ca),
      (ca.prototype.isMeshLineMaterial = !0),
      (ca.prototype.copy = function (t) {
        return (
          wr.prototype.copy.call(this, t),
          (this.lineWidth = t.lineWidth),
          (this.map = t.map),
          (this.useMap = t.useMap),
          (this.alphaMap = t.alphaMap),
          (this.useAlphaMap = t.useAlphaMap),
          this.color.copy(t.color),
          (this.opacity = t.opacity),
          this.resolution.copy(t.resolution),
          (this.sizeAttenuation = t.sizeAttenuation),
          this.dashArray.copy(t.dashArray),
          this.dashOffset.copy(t.dashOffset),
          this.dashRatio.copy(t.dashRatio),
          (this.useDash = t.useDash),
          (this.visibility = t.visibility),
          (this.alphaTest = t.alphaTest),
          this.repeat.copy(t.repeat),
          this
        );
      });
    class pa extends as {
      constructor({
        width: t = 0.1,
        speed: e = 0.01,
        visibleLength: i = 0.5,
        color: r = new q("#000000"),
        opacity: s = 1,
        position: n = new h(0, 0, 0),
        points: a = !1,
        transformLineMethod: o = !1,
      } = {}) {
        let l = [];
        a && (l = a);
        const u = new ha();
        u.setGeometry(l, o);
        const c = 1 - 0.5 * i;
        super(
          u.geometry,
          new ca({
            lineWidth: t,
            dashArray: 2,
            dashOffset: 0,
            dashRatio: c,
            opacity: s,
            transparent: !0,
            depthWrite: !1,
            color: r,
          }),
        ),
          this.position.copy(n),
          (this.speed = e),
          (this.voidLength = 2 * c),
          (this.dashLength = 2 - this.voidLength),
          (this.dyingAt = 1),
          (this.diedAt = this.dyingAt + this.dashLength),
          (this.update = this.update.bind(this));
      }
      update() {
        (this.material.uniforms.dashOffset.value -= this.speed),
          this.isDying() &&
            (this.material.uniforms.opacity.value =
              0.9 +
              (this.material.uniforms.dashOffset.value + 1) / this.dashLength);
      }
      isDied() {
        return this.material.uniforms.dashOffset.value < -this.diedAt;
      }
      isDying() {
        return this.material.uniforms.dashOffset.value < -this.dyingAt;
      }
    }
    class da extends D {
      constructor({ frequency: t = 0.1 } = {}, e) {
        super(),
          (this.frequency = t),
          (this.lineStaticProps = e),
          (this.isStarted = !1),
          (this.i = 0),
          (this.lines = []),
          (this.nbrOfLines = -1),
          (this.update = this.update.bind(this)),
          (this.start = this.start.bind(this)),
          (this.stop = this.stop.bind(this));
      }
      start() {
        this.isStarted = !0;
      }
      stop(t) {
        this.isStarted = !1;
      }
      addLine(t) {
        const e = new pa(Object.assign({}, this.lineStaticProps, t));
        return this.lines.push(e), this.add(e), this.nbrOfLines++, e;
      }
      removeLine(t) {
        this.remove(t), this.nbrOfLines--;
      }
      update() {
        for (
          this.isStarted && Math.random() < this.frequency && this.addLine(),
            this.i = this.nbrOfLines;
          this.i >= 0;
          this.i--
        )
          this.lines[this.i].update();
        const t = [];
        for (this.i = this.nbrOfLines; this.i >= 0; this.i--)
          this.lines[this.i].isDied()
            ? this.removeLine(this.lines[this.i])
            : t.push(this.lines[this.i]);
        this.lines = t;
      }
    }
    var ma = (t, e) => Math.random() * (e - t) + t,
      fa = (t) =>
        t[
          ((t, e) => Math.floor(Math.random() * (e - t + 1)) + t)(
            0,
            t.length - 1,
          )
        ];
    const ga = 0.3,
      ya = 0.1,
      xa = -1,
      ba = 0.08,
      va = 0.025,
      Ma = 0.02,
      wa = ["#794F98", "#3D15B9", "#53486E", "#2B2148", "#27155E"].map(
        (t) => new q(t),
      ),
      _a = { x: 0, y: 0, z: 0 };
    class Ea extends da {
      constructor(t, e, { engine: i }) {
        super(t, e), (this.engine = i);
      }
      destroy() {
        this.engine = null;
      }
      addLine() {
        if (this.lines.length > 200) return;
        let t = xa,
          e = Math.random() > 0.8 ? ya : ga,
          i = ma(0, 2 * Math.PI);
        const r = [];
        for (; t < this.engine.camera.position.z; )
          (_a.x = Math.cos(i) * e),
            (_a.y = Math.sin(i) * e),
            (_a.z = t),
            (t += ba),
            (i += va),
            (e += Ma),
            r.push(_a.x, _a.y, _a.z);
        super.addLine({
          visibleLength: ma(0.1, 0.4),
          points: r,
          speed: ma(0.005, 0.01),
          color: fa(wa),
          width: ma(0.01, 0.06),
        });
      }
    }
    const Ta = { transformLineMethod: (t) => 1.5 * t };
    var Sa = class {
      constructor({
        width: t,
        height: e,
        offsetY: i,
        pixelRatio: r,
        canvas: s,
      }) {
        this.updateLookAt = (t) => (this.engine.lookAt = new h(0, t, 0));
        const n = new ia({
          width: t,
          height: e,
          pixelRatio: r,
          canvas: s,
          z: 6,
        });
        (this.engine = n),
          this.updateLookAt(i),
          (this.lineGenerator = new Ea({ frequency: 0.9 }, Ta, { engine: n })),
          n.add(this.lineGenerator);
      }
      start() {
        this.engine.start(), this.lineGenerator.start();
      }
      destroy() {
        this.lineGenerator.destroy(),
          this.engine.destroy(),
          (this.engine = null),
          (this.lineGenerator = null);
      }
      resize({ width: t, height: e }) {
        this.engine.resize(t, e);
      }
      moveCamera({ x: t, y: e, velocity: i }) {
        const r = this.engine.lookAt;
        (this.engine.camera.position.x +=
          (t - this.engine.camera.position.x) * i),
          (this.engine.camera.position.y +=
            (e - this.engine.camera.position.y) * i),
          this.engine.camera.lookAt(r);
      }
    };
    let Aa = 0;
    const Ra = () => Aa++;
    const La = new (class {
      constructor() {
        (this.init = ({ name: t, ...e }) => {
          switch (t) {
            case "spiral":
              const i = Ra();
              return (this[i] = new Sa(e)), i;
            case "default":
              throw new Error("expected name for CanvasHandler, received -", t);
          }
        }),
          (this.start = (t) => {
            this[t].start();
          }),
          (this.destroy = (t) => {
            this[t].destroy(), (this[t] = null);
          }),
          (this.call = ({ method: t, payload: e, id: i }) => {
            this[i][t](e);
          });
      }
    })();
    Object(r.installHandler)(async (t, e) => {
      if (!La.hasOwnProperty(t)) throw new Error("invalid worker method", t);
      return La[t](...e);
    });
  },
  function (t, e) {
    function i(t) {
      return t instanceof Error
        ? { ...t, name: t.name, message: t.message, stack: r(t.stack) }
        : { name: t.name || "UNKNOWN", message: JSON.stringify(t) };
    }
    function r(t) {
      return t
        .replace(/\/Users\/[^/]+/g, "")
        .replace(/\\Users\\[^\\]+/g, "")
        .replace(/\/home\/[^/]+/g, "");
    }
    t.exports = {
      toObject: i,
      JSONReplacer: function (t, e) {
        return e instanceof Error ? i(e) : e;
      },
      cleanStack: r,
    };
  },
  function (t, e, i) {
    if (void 0 !== globalThis.Buffer && globalThis.Buffer) {
      const Buffer = globalThis.Buffer;
      (Buffer.poolSize = 0),
        (Buffer.allocUnsafe = function (t) {
          return Buffer.alloc(t);
        }),
        (Buffer.allocUnsafeSlow = Buffer.allocUnsafe),
        Object.freeze(Buffer);
    }
    const r = Object.getPrototypeOf(Int8Array);
    for (const t of [
      ...[Object, Array, Number, String, Function, Set, Map, WeakSet, WeakMap],
      ...[Reflect, TypeError, BigInt, URL, Date, JSON, Math],
      ...[Int8Array, Int16Array, Int32Array, DataView],
      ...[Uint8Array, Uint16Array, Uint32Array, r],
    ])
      Object.freeze(t);
    crypto &&
      crypto.subtle &&
      (Object.freeze(crypto), Object.freeze(crypto.subtle));
  },
  function (t, e) {
    const i = (...t) => {
      const e = t
        .reduce(
          (t, e) =>
            t.concat(
              ((t) => t instanceof Error && t.stack)(e) ? e.stack : e,
              "\n",
            ),
          "",
        )
        .trim();
      console._errorOriginal(e);
    };
    console._errorOriginal ||
      ((console._errorOriginal = console.error.bind(console)),
      (console.error = i));
  },
  function (t, e, i) {
    i(4), i(3);
  },
  function (t, e, i) {
    i(5), i(1);
  },
]);
