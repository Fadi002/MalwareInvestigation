!(function (e) {
  var t = {};
  function n(r) {
    if (t[r]) return t[r].exports;
    var o = (t[r] = { i: r, l: !1, exports: {} });
    return e[r].call(o.exports, o, o.exports, n), (o.l = !0), o.exports;
  }
  (n.m = e),
    (n.c = t),
    (n.d = function (e, t, r) {
      n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r });
    }),
    (n.r = function (e) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (n.t = function (e, t) {
      if ((1 & t && (e = n(e)), 8 & t)) return e;
      if (4 & t && "object" == typeof e && e && e.__esModule) return e;
      var r = Object.create(null);
      if (
        (n.r(r),
        Object.defineProperty(r, "default", { enumerable: !0, value: e }),
        2 & t && "string" != typeof e)
      )
        for (var o in e)
          n.d(
            r,
            o,
            function (t) {
              return e[t];
            }.bind(null, o),
          );
      return r;
    }),
    (n.n = function (e) {
      var t =
        e && e.__esModule
          ? function () {
              return e.default;
            }
          : function () {
              return e;
            };
      return n.d(t, "a", t), t;
    }),
    (n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }),
    (n.p = ""),
    n((n.s = 192));
})([
  function (e, t) {
    e.exports = require("path");
  },
  function (e, t, n) {
    var r,
      o,
      i = n(13),
      c = n(180),
      s = n(178),
      a = n(176),
      u = n(64);
    function f(e, t) {
      Object.defineProperty(e, r, {
        get: function () {
          return t;
        },
      });
    }
    (r = Symbol.for("graceful-fs.queue")),
      (o = Symbol.for("graceful-fs.previous"));
    var l,
      d = function () {};
    if (
      (u.debuglog
        ? (d = u.debuglog("gfs4"))
        : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") &&
          (d = function () {
            var e = u.format.apply(u, arguments);
            (e = "GFS4: " + e.split(/\n/).join("\nGFS4: ")), console.error(e);
          }),
      !i[r])
    ) {
      var y = global[r] || [];
      f(i, y),
        (i.close = (function (e) {
          function t(t, n) {
            return e.call(i, t, function (e) {
              e || m(), "function" == typeof n && n.apply(this, arguments);
            });
          }
          return Object.defineProperty(t, o, { value: e }), t;
        })(i.close)),
        (i.closeSync = (function (e) {
          function t(t) {
            e.apply(i, arguments), m();
          }
          return Object.defineProperty(t, o, { value: e }), t;
        })(i.closeSync)),
        /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") &&
          process.on("exit", function () {
            d(i[r]), n(20).equal(i[r].length, 0);
          });
    }
    function p(e) {
      d("ENQUEUE", e[0].name, e[1]), i[r].push(e), h();
    }
    function m() {
      for (var e = Date.now(), t = 0; t < i[r].length; ++t)
        i[r][t].length > 2 && ((i[r][t][3] = e), (i[r][t][4] = e));
      h();
    }
    function h() {
      if ((clearTimeout(l), (l = void 0), 0 !== i[r].length)) {
        var e = i[r].shift(),
          t = e[0],
          n = e[1],
          o = e[2],
          c = e[3],
          s = e[4];
        if (void 0 === c) d("RETRY", t.name, n), t.apply(null, n);
        else if (Date.now() - c >= 6e4) {
          d("TIMEOUT", t.name, n);
          var a = n.pop();
          "function" == typeof a && a.call(null, o);
        } else {
          var u = Date.now() - s,
            f = Math.max(s - c, 1);
          u >= Math.min(1.2 * f, 100)
            ? (d("RETRY", t.name, n), t.apply(null, n.concat([c])))
            : i[r].push(e);
        }
        void 0 === l && (l = setTimeout(h, 0));
      }
    }
    global[r] || f(global, i[r]),
      (e.exports = (function e(t) {
        c(t);
        t.gracefulify = e;
        t.createReadStream = function (e, n) {
          return new t.ReadStream(e, n);
        };
        t.createWriteStream = function (e, n) {
          return new t.WriteStream(e, n);
        };
        var n = t.readFile;
        t.readFile = function (e, t, r) {
          "function" == typeof t && ((r = t), (t = null));
          return (function e(t, r, o, i) {
            return n(t, r, function (n) {
              !n || ("EMFILE" !== n.code && "ENFILE" !== n.code)
                ? "function" == typeof o && o.apply(this, arguments)
                : p([e, [t, r, o], n, i || Date.now(), Date.now()]);
            });
          })(e, t, r);
        };
        var r = t.writeFile;
        t.writeFile = function (e, t, n, o) {
          "function" == typeof n && ((o = n), (n = null));
          return (function e(t, n, o, i, c) {
            return r(t, n, o, function (r) {
              !r || ("EMFILE" !== r.code && "ENFILE" !== r.code)
                ? "function" == typeof i && i.apply(this, arguments)
                : p([e, [t, n, o, i], r, c || Date.now(), Date.now()]);
            });
          })(e, t, n, o);
        };
        var o = t.appendFile;
        o &&
          (t.appendFile = function (e, t, n, r) {
            "function" == typeof n && ((r = n), (n = null));
            return (function e(t, n, r, i, c) {
              return o(t, n, r, function (o) {
                !o || ("EMFILE" !== o.code && "ENFILE" !== o.code)
                  ? "function" == typeof i && i.apply(this, arguments)
                  : p([e, [t, n, r, i], o, c || Date.now(), Date.now()]);
              });
            })(e, t, n, r);
          });
        var i = t.copyFile;
        i &&
          (t.copyFile = function (e, t, n, r) {
            "function" == typeof n && ((r = n), (n = 0));
            return (function e(t, n, r, o, c) {
              return i(t, n, r, function (i) {
                !i || ("EMFILE" !== i.code && "ENFILE" !== i.code)
                  ? "function" == typeof o && o.apply(this, arguments)
                  : p([e, [t, n, r, o], i, c || Date.now(), Date.now()]);
              });
            })(e, t, n, r);
          });
        var a = t.readdir;
        t.readdir = function (e, t, n) {
          "function" == typeof t && ((n = t), (t = null));
          var r = u.test(process.version)
            ? function (e, t, n, r) {
                return a(e, o(e, t, n, r));
              }
            : function (e, t, n, r) {
                return a(e, t, o(e, t, n, r));
              };
          return r(e, t, n);
          function o(e, t, n, o) {
            return function (i, c) {
              !i || ("EMFILE" !== i.code && "ENFILE" !== i.code)
                ? (c && c.sort && c.sort(),
                  "function" == typeof n && n.call(this, i, c))
                : p([r, [e, t, n], i, o || Date.now(), Date.now()]);
            };
          }
        };
        var u = /^v[0-5]\./;
        if ("v0.8" === process.version.substr(0, 4)) {
          var f = s(t);
          (h = f.ReadStream), (w = f.WriteStream);
        }
        var l = t.ReadStream;
        l &&
          ((h.prototype = Object.create(l.prototype)),
          (h.prototype.open = function () {
            var e = this;
            E(e.path, e.flags, e.mode, function (t, n) {
              t
                ? (e.autoClose && e.destroy(), e.emit("error", t))
                : ((e.fd = n), e.emit("open", n), e.read());
            });
          }));
        var d = t.WriteStream;
        d &&
          ((w.prototype = Object.create(d.prototype)),
          (w.prototype.open = function () {
            var e = this;
            E(e.path, e.flags, e.mode, function (t, n) {
              t
                ? (e.destroy(), e.emit("error", t))
                : ((e.fd = n), e.emit("open", n));
            });
          }));
        Object.defineProperty(t, "ReadStream", {
          get: function () {
            return h;
          },
          set: function (e) {
            h = e;
          },
          enumerable: !0,
          configurable: !0,
        });
        Object.defineProperty(t, "WriteStream", {
          get: function () {
            return w;
          },
          set: function (e) {
            w = e;
          },
          enumerable: !0,
          configurable: !0,
        });
        var y = h;
        Object.defineProperty(t, "FileReadStream", {
          get: function () {
            return y;
          },
          set: function (e) {
            y = e;
          },
          enumerable: !0,
          configurable: !0,
        });
        var m = w;
        Object.defineProperty(t, "FileWriteStream", {
          get: function () {
            return m;
          },
          set: function (e) {
            m = e;
          },
          enumerable: !0,
          configurable: !0,
        });
        function h(e, t) {
          return this instanceof h
            ? (l.apply(this, arguments), this)
            : h.apply(Object.create(h.prototype), arguments);
        }
        function w(e, t) {
          return this instanceof w
            ? (d.apply(this, arguments), this)
            : w.apply(Object.create(w.prototype), arguments);
        }
        var S = t.open;
        t.open = E;
        function E(e, t, n, r) {
          return (
            "function" == typeof n && ((r = n), (n = null)),
            (function e(t, n, r, o, i) {
              return S(t, n, r, function (c, s) {
                !c || ("EMFILE" !== c.code && "ENFILE" !== c.code)
                  ? "function" == typeof o && o.apply(this, arguments)
                  : p([e, [t, n, r, o], c, i || Date.now(), Date.now()]);
              });
            })(e, t, n, r)
          );
        }
        return t;
      })(a(i)));
  },
  function (e, t, n) {
    "use strict";
    (t.fromCallback = function (e) {
      return Object.defineProperty(
        function () {
          if ("function" != typeof arguments[arguments.length - 1])
            return new Promise((t, n) => {
              (arguments[arguments.length] = (e, r) => {
                if (e) return n(e);
                t(r);
              }),
                arguments.length++,
                e.apply(this, arguments);
            });
          e.apply(this, arguments);
        },
        "name",
        { value: e.name },
      );
    }),
      (t.fromPromise = function (e) {
        return Object.defineProperty(
          function () {
            const t = arguments[arguments.length - 1];
            if ("function" != typeof t) return e.apply(this, arguments);
            e.apply(this, arguments)
              .then((e) => t(null, e))
              .catch(t);
          },
          "name",
          { value: e.name },
        );
      });
  },
  function (e, t, n) {
    e.exports = n(72);
  },
  function (e, t, n) {
    "use strict";
    e.exports = {
      ...n(18),
      ...n(30),
      ...n(117),
      ...n(115),
      ...n(109),
      ...n(9),
      ...n(104),
      ...n(28),
      ...n(14),
      ...n(22),
    };
  },
  function (e, t, n) {
    "use strict";
    (t.fromCallback = function (e) {
      return Object.defineProperty(
        function (...t) {
          if ("function" != typeof t[t.length - 1])
            return new Promise((n, r) => {
              e.call(this, ...t, (e, t) => (null != e ? r(e) : n(t)));
            });
          e.apply(this, t);
        },
        "name",
        { value: e.name },
      );
    }),
      (t.fromPromise = function (e) {
        return Object.defineProperty(
          function (...t) {
            const n = t[t.length - 1];
            if ("function" != typeof n) return e.apply(this, t);
            e.apply(this, t.slice(0, -1)).then((e) => n(null, e), n);
          },
          "name",
          { value: e.name },
        );
      });
  },
  function (e, t, n) {
    "use strict";
    const r = (0, n(2).fromCallback)(n(96)),
      o = n(95);
    e.exports = {
      mkdirs: r,
      mkdirsSync: o,
      mkdirp: r,
      mkdirpSync: o,
      ensureDir: r,
      ensureDirSync: o,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = (0, n(2).fromCallback)(n(140)),
      o = n(139);
    e.exports = {
      mkdirs: r,
      mkdirsSync: o,
      mkdirp: r,
      mkdirpSync: o,
      ensureDir: r,
      ensureDirSync: o,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = (0, n(2).fromCallback)(n(174)),
      o = n(173);
    e.exports = {
      mkdirs: r,
      mkdirsSync: o,
      mkdirp: r,
      mkdirpSync: o,
      ensureDir: r,
      ensureDirSync: o,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromPromise,
      { makeDir: o, makeDirSync: i } = n(120),
      c = r(o);
    e.exports = {
      mkdirs: c,
      mkdirsSync: i,
      mkdirp: c,
      mkdirpSync: i,
      ensureDir: c,
      ensureDirSync: i,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromPromise,
      o = n(47);
    e.exports = {
      pathExists: r(function (e) {
        return o
          .access(e)
          .then(() => !0)
          .catch(() => !1);
      }),
      pathExistsSync: o.existsSync,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromPromise,
      o = n(53);
    e.exports = {
      pathExists: r(function (e) {
        return o
          .access(e)
          .then(() => !0)
          .catch(() => !1);
      }),
      pathExistsSync: o.existsSync,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromPromise,
      o = n(65);
    e.exports = {
      pathExists: r(function (e) {
        return o
          .access(e)
          .then(() => !0)
          .catch(() => !1);
      }),
      pathExistsSync: o.existsSync,
    };
  },
  function (e, t) {
    e.exports = require("fs");
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromPromise,
      o = n(18);
    e.exports = {
      pathExists: r(function (e) {
        return o
          .access(e)
          .then(() => !0)
          .catch(() => !1);
      }),
      pathExistsSync: o.existsSync,
    };
  },
  function (e, t, n) {
    "use strict";
    (t.reduce = function (e, t, n) {
      for (var r = 0; r < e.length; ++r) n = t(n, e[r], r, e);
      return n;
    }),
      (t.isAbstractCodec = function (e) {
        return (
          e &&
          "function" == typeof e.encode &&
          "function" == typeof e.decode &&
          "function" == typeof e.encodingLength
        );
      });
  },
  function (e, t, n) {
    e.exports = n(74);
  },
  function (e, t, n) {
    "use strict";
    const r = n(18),
      o = n(0),
      i = n(64);
    function c(e, t, n) {
      const o = n.dereference
        ? (e) => r.stat(e, { bigint: !0 })
        : (e) => r.lstat(e, { bigint: !0 });
      return Promise.all([
        o(e),
        o(t).catch((e) => {
          if ("ENOENT" === e.code) return null;
          throw e;
        }),
      ]).then(([e, t]) => ({ srcStat: e, destStat: t }));
    }
    function s(e, t) {
      return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
    }
    function a(e, t) {
      const n = o
          .resolve(e)
          .split(o.sep)
          .filter((e) => e),
        r = o
          .resolve(t)
          .split(o.sep)
          .filter((e) => e);
      return n.reduce((e, t, n) => e && r[n] === t, !0);
    }
    function u(e, t, n) {
      return `Cannot ${n} '${e}' to a subdirectory of itself, '${t}'.`;
    }
    e.exports = {
      checkPaths: function (e, t, n, r, f) {
        i.callbackify(c)(e, t, r, (r, i) => {
          if (r) return f(r);
          const { srcStat: c, destStat: l } = i;
          if (l) {
            if (s(c, l)) {
              const r = o.basename(e),
                i = o.basename(t);
              return "move" === n &&
                r !== i &&
                r.toLowerCase() === i.toLowerCase()
                ? f(null, { srcStat: c, destStat: l, isChangingCase: !0 })
                : f(new Error("Source and destination must not be the same."));
            }
            if (c.isDirectory() && !l.isDirectory())
              return f(
                new Error(
                  `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
                ),
              );
            if (!c.isDirectory() && l.isDirectory())
              return f(
                new Error(
                  `Cannot overwrite directory '${t}' with non-directory '${e}'.`,
                ),
              );
          }
          return c.isDirectory() && a(e, t)
            ? f(new Error(u(e, t, n)))
            : f(null, { srcStat: c, destStat: l });
        });
      },
      checkPathsSync: function (e, t, n, i) {
        const { srcStat: c, destStat: f } = (function (e, t, n) {
          let o;
          const i = n.dereference
              ? (e) => r.statSync(e, { bigint: !0 })
              : (e) => r.lstatSync(e, { bigint: !0 }),
            c = i(e);
          try {
            o = i(t);
          } catch (e) {
            if ("ENOENT" === e.code) return { srcStat: c, destStat: null };
            throw e;
          }
          return { srcStat: c, destStat: o };
        })(e, t, i);
        if (f) {
          if (s(c, f)) {
            const r = o.basename(e),
              i = o.basename(t);
            if ("move" === n && r !== i && r.toLowerCase() === i.toLowerCase())
              return { srcStat: c, destStat: f, isChangingCase: !0 };
            throw new Error("Source and destination must not be the same.");
          }
          if (c.isDirectory() && !f.isDirectory())
            throw new Error(
              `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
            );
          if (!c.isDirectory() && f.isDirectory())
            throw new Error(
              `Cannot overwrite directory '${t}' with non-directory '${e}'.`,
            );
        }
        if (c.isDirectory() && a(e, t)) throw new Error(u(e, t, n));
        return { srcStat: c, destStat: f };
      },
      checkParentPaths: function e(t, n, i, c, a) {
        const f = o.resolve(o.dirname(t)),
          l = o.resolve(o.dirname(i));
        if (l === f || l === o.parse(l).root) return a();
        r.stat(l, { bigint: !0 }, (r, o) =>
          r
            ? "ENOENT" === r.code
              ? a()
              : a(r)
            : s(n, o)
            ? a(new Error(u(t, i, c)))
            : e(t, n, l, c, a),
        );
      },
      checkParentPathsSync: function e(t, n, i, c) {
        const a = o.resolve(o.dirname(t)),
          f = o.resolve(o.dirname(i));
        if (f === a || f === o.parse(f).root) return;
        let l;
        try {
          l = r.statSync(f, { bigint: !0 });
        } catch (e) {
          if ("ENOENT" === e.code) return;
          throw e;
        }
        if (s(n, l)) throw new Error(u(t, i, c));
        return e(t, n, f, c);
      },
      isSrcSubdir: a,
      areIdentical: s,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromCallback,
      o = n(1),
      i = [
        "access",
        "appendFile",
        "chmod",
        "chown",
        "close",
        "copyFile",
        "fchmod",
        "fchown",
        "fdatasync",
        "fstat",
        "fsync",
        "ftruncate",
        "futimes",
        "lchmod",
        "lchown",
        "link",
        "lstat",
        "mkdir",
        "mkdtemp",
        "open",
        "opendir",
        "readdir",
        "readFile",
        "readlink",
        "realpath",
        "rename",
        "rm",
        "rmdir",
        "stat",
        "symlink",
        "truncate",
        "unlink",
        "utimes",
        "writeFile",
      ].filter((e) => "function" == typeof o[e]);
    Object.assign(t, o),
      i.forEach((e) => {
        t[e] = r(o[e]);
      }),
      (t.exists = function (e, t) {
        return "function" == typeof t
          ? o.exists(e, t)
          : new Promise((t) => o.exists(e, t));
      }),
      (t.read = function (e, t, n, r, i, c) {
        return "function" == typeof c
          ? o.read(e, t, n, r, i, c)
          : new Promise((c, s) => {
              o.read(e, t, n, r, i, (e, t, n) => {
                if (e) return s(e);
                c({ bytesRead: t, buffer: n });
              });
            });
      }),
      (t.write = function (e, t, ...n) {
        return "function" == typeof n[n.length - 1]
          ? o.write(e, t, ...n)
          : new Promise((r, i) => {
              o.write(e, t, ...n, (e, t, n) => {
                if (e) return i(e);
                r({ bytesWritten: t, buffer: n });
              });
            });
      }),
      "function" == typeof o.writev &&
        (t.writev = function (e, t, ...n) {
          return "function" == typeof n[n.length - 1]
            ? o.writev(e, t, ...n)
            : new Promise((r, i) => {
                o.writev(e, t, ...n, (e, t, n) => {
                  if (e) return i(e);
                  r({ bytesWritten: t, buffers: n });
                });
              });
        }),
      "function" == typeof o.realpath.native
        ? (t.realpath.native = r(o.realpath.native))
        : process.emitWarning(
            "fs.realpath.native is not a function. Is fs being monkey-patched?",
            "Warning",
            "fs-extra-WARN0003",
          );
  },
  function (e, t) {
    e.exports = require("crypto");
  },
  function (e, t) {
    e.exports = require("assert");
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(93);
    e.exports = { remove: r(o), removeSync: o.sync };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(5).fromCallback,
      i = n(116);
    e.exports = {
      remove: o(function (e, t) {
        if (r.rm) return r.rm(e, { recursive: !0, force: !0 }, t);
        i(e, t);
      }),
      removeSync: function (e) {
        if (r.rmSync) return r.rmSync(e, { recursive: !0, force: !0 });
        i.sync(e);
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(136);
    e.exports = { remove: r(o), removeSync: o.sync };
  },
  function (e, t, n) {
    "use strict";
    e.exports = t = n(155);
    var r = n(154);
    (t.Byte = r.Byte),
      (t.Int8 = r.Int8),
      (t.UInt8 = r.UInt8),
      (t.Int16BE = r.Int16BE),
      (t.Int16LE = r.Int16LE),
      (t.UInt16BE = r.UInt16BE),
      (t.UInt16LE = r.UInt16LE),
      (t.Int32BE = r.Int32BE),
      (t.Int32LE = r.Int32LE),
      (t.UInt32BE = r.UInt32BE),
      (t.UInt32LE = r.UInt32LE),
      (t.Int64BE = r.Int64BE),
      (t.Int64LE = r.Int64LE),
      (t.UInt64BE = r.UInt64BE),
      (t.UInt64LE = r.UInt64LE),
      (t.FloatBE = r.FloatBE),
      (t.FloatLE = r.FloatLE),
      (t.DoubleBE = r.DoubleBE),
      (t.DoubleLE = r.DoubleLE),
      (t.Array = n(152)),
      (t.VarArray = n(151)),
      (t.Sequence = n(150)),
      (t.Buffer = n(57)),
      (t.VarBuffer = n(56)),
      (t.String = n(149)),
      (t.VarString = n(148)),
      (t.Bound = n(147));
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(171);
    e.exports = { remove: r(o), removeSync: o.sync };
  },
  function (e, t, n) {
    "use strict";
    e.exports = n(185);
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(91);
    e.exports = {
      readJson: r(o.readFile),
      readJsonSync: o.readFileSync,
      writeJson: r(o.writeFile),
      writeJsonSync: o.writeFileSync,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromCallback,
      o = n(1),
      i = n(0),
      c = n(9),
      s = n(14).pathExists;
    e.exports = {
      outputFile: r(function (e, t, n, r) {
        "function" == typeof n && ((r = n), (n = "utf8"));
        const a = i.dirname(e);
        s(a, (i, s) =>
          i
            ? r(i)
            : s
            ? o.writeFile(e, t, n, r)
            : void c.mkdirs(a, (i) => {
                if (i) return r(i);
                o.writeFile(e, t, n, r);
              }),
        );
      }),
      outputFileSync: function (e, ...t) {
        const n = i.dirname(e);
        if (o.existsSync(n)) return o.writeFileSync(e, ...t);
        c.mkdirsSync(n), o.writeFileSync(e, ...t);
      },
    };
  },
  function (e, t) {
    e.exports = {
      stringify: function (
        e,
        { EOL: t = "\n", finalEOL: n = !0, replacer: r = null, spaces: o } = {},
      ) {
        const i = n ? t : "";
        return JSON.stringify(e, r, o).replace(/\n/g, t) + i;
      },
      stripBom: function (e) {
        return (
          Buffer.isBuffer(e) && (e = e.toString("utf8")),
          e.replace(/^\uFEFF/, "")
        );
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromCallback;
    e.exports = { copy: r(n(121)), copySync: n(118) };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(134);
    e.exports = {
      readJson: r(o.readFile),
      readJsonSync: o.readFileSync,
      writeJson: r(o.writeFile),
      writeJsonSync: o.writeFileSync,
    };
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.struct = void 0),
      (t.decode = d),
      (t.encode = function (e) {
        return l.encode(e);
      }),
      (t.computeChecksum = y),
      (t.checkContents = function (e) {
        let t = d(e);
        return t.checksum.equals(y(t.metadata, t.blob));
      });
    var r,
      o = n(24),
      i = (r = o) && r.__esModule ? r : { default: r },
      c = n(146),
      s = (function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
        return (t.default = e), t;
      })(n(36)),
      a = n(34),
      u = n(35),
      f = n(33);
    const l = (t.struct = (0, i.default)(
      (0, a.vsf)([
        ["header", (0, o.Buffer)(u.HEADER_LEN_BYTES)],
        ["checksum", (0, o.Buffer)(32)],
        ["metadata", (0, o.Buffer)(f.METADATA_LEN_BYTES)],
        ["blob", (0, o.VarBuffer)(o.UInt32BE)],
      ]),
    ));
    function d(e) {
      return l.decode(e);
    }
    function y(e, t) {
      return s.sha256(Buffer.concat([e, (0, c.fromUInt32BE)(t.byteLength), t]));
    }
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.struct = t.METADATA_LEN_BYTES = void 0),
      (t.decode = function (e) {
        e.byteLength > a &&
          console.warn(
            "metadata greater than `${METADATA_LEN_BYTES}` bytes, are you sure this is the SECO metadata?",
          );
        return u.decode(e);
      }),
      (t.encode = f),
      (t.serialize = function (e) {
        let t = Buffer.alloc(a);
        return f(e).copy(t), t;
      }),
      (t.create = function (e = (0, c.createScryptParams)()) {
        return {
          scrypt: e,
          cipher: "aes-256-gcm",
          blobKey: {
            iv: Buffer.alloc(c.IV_LEN_BYTES),
            authTag: Buffer.alloc(16),
            key: Buffer.alloc(32),
          },
          blob: { iv: Buffer.alloc(c.IV_LEN_BYTES), authTag: Buffer.alloc(16) },
        };
      }),
      (t.encryptBlobKey = function (e, t, n) {
        const {
          authTag: r,
          blob: o,
          iv: i,
          salt: s,
        } = (0, c.boxEncrypt)(t, n, e.scrypt);
        (e.scrypt.salt = s), (e.blobKey = { authTag: r, iv: i, key: o });
      }),
      (t.decryptBlobKey = function (e, t) {
        return (0, c.boxDecrypt)(t, e.blobKey.key, e.blobKey, e.scrypt);
      });
    var r,
      o = n(24),
      i = (r = o) && r.__esModule ? r : { default: r },
      c = n(36),
      s = n(34);
    const a = (t.METADATA_LEN_BYTES = 256),
      u = (t.struct = (0, i.default)(
        (0, s.vsf)([
          [
            "scrypt",
            [
              ["salt", (0, o.Buffer)(32)],
              ["n", o.UInt32BE],
              ["r", o.UInt32BE],
              ["p", o.UInt32BE],
            ],
          ],
          ["cipher", (0, s.CStr)(32)],
          [
            "blobKey",
            [
              ["iv", (0, o.Buffer)(c.IV_LEN_BYTES)],
              ["authTag", (0, o.Buffer)(16)],
              ["key", (0, o.Buffer)(32)],
            ],
          ],
          [
            "blob",
            [
              ["iv", (0, o.Buffer)(c.IV_LEN_BYTES)],
              ["authTag", (0, o.Buffer)(16)],
            ],
          ],
        ]),
      ));
    function f(e) {
      return u.encode(e);
    }
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.vsf = function e(t) {
        return t.map((t) => ({
          name: t[0],
          type: Array.isArray(t[1]) ? (0, i.default)(e(t[1])) : t[1],
        }));
      }),
      (t.CStr = function (e, t = "utf8") {
        let n = (0, o.Buffer)(e);
        function r(r, o, i) {
          let c = Buffer.alloc(e);
          return c.write(r, t), n.encode(c, o, i);
        }
        function i(e, r, o) {
          let i = n.decode(e, r, o),
            c = 0;
          for (; c < i.length && 0 !== i[c]; c++);
          return i.slice(0, c).toString(t);
        }
        return (
          (r.bytes = i.bytes = e),
          { encode: r, decode: i, encodingLength: () => e }
        );
      });
    var r,
      o = n(24),
      i = (r = o) && r.__esModule ? r : { default: r };
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.struct = t.MAGIC = t.HEADER_VERSION_TAG = t.HEADER_LEN_BYTES = void 0),
      (t.checkMagic = f),
      (t.decode = function (e) {
        e.byteLength > s &&
          console.warn(
            `header greater than ${s} bytes, are you sure this is the header?`,
          );
        return l.decode(e);
      }),
      (t.encode = d),
      (t.serialize = function (e) {
        let t = Buffer.alloc(s);
        return d(e).copy(t), t;
      }),
      (t.create = function (
        { appName: e, appVersion: t } = { appName: "", appVersion: "" },
      ) {
        return {
          magic: u,
          version: 0,
          reserved: 0,
          versionTag: a,
          appName: e,
          appVersion: t,
        };
      });
    var r,
      o = n(24),
      i = (r = o) && r.__esModule ? r : { default: r },
      c = n(34);
    const s = (t.HEADER_LEN_BYTES = 224),
      a = (t.HEADER_VERSION_TAG = "seco-v0-scrypt-aes"),
      u = (t.MAGIC = Buffer.from("SECO", "utf8"));
    function f(e) {
      if (!e.equals(u)) throw new RangeError("Invalid secure container magic.");
    }
    const l = (t.struct = (0, i.default)(
      (0, c.vsf)([
        ["magic", (0, o.Bound)(i.default.Buffer(4), f)],
        ["version", o.UInt32BE],
        ["reserved", o.UInt32BE],
        ["versionTag", (0, o.VarString)(o.UInt8)],
        ["appName", (0, o.VarString)(o.UInt8, "utf-8")],
        ["appVersion", (0, o.VarString)(o.UInt8, "utf-8")],
      ]),
    ));
    function d(e) {
      return l.encode(e);
    }
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.IV_LEN_BYTES = void 0);
    var r =
      Object.assign ||
      function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n)
            Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
        return e;
      };
    (t.createScryptParams = a),
      (t.stretchPassphrase = u),
      (t.aesEncrypt = f),
      (t.aesDecrypt = l),
      (t.boxEncrypt = function (e, t, n) {
        const { key: r, salt: o } = u(e, n),
          { authTag: i, blob: c, iv: s } = f(r, t);
        return { authTag: i, blob: c, iv: s, salt: o };
      }),
      (t.boxDecrypt = function (e, t, { iv: n, authTag: o }, i) {
        i = r({}, a(), i);
        const { key: c } = u(e, i);
        return l(c, t, { iv: n, authTag: o });
      }),
      (t.sha256 = function (e) {
        return o.default.createHash("sha256").update(e).digest();
      });
    var o = c(n(19)),
      i = c(n(156));
    function c(e) {
      return e && e.__esModule ? e : { default: e };
    }
    const s = (t.IV_LEN_BYTES = 12);
    function a(e = {}) {
      return r({ salt: o.default.randomBytes(32), n: 16384, r: 8, p: 1 }, e);
    }
    function u(e, { salt: t, n: n, r: r, p: o } = a()) {
      return { key: (0, i.default)(e, t, n, r, o, 32), salt: t };
    }
    function f(
      e,
      t,
      n = { cipher: "aes-256-gcm", iv: o.default.randomBytes(s) },
    ) {
      const r = o.default.createCipheriv(n.cipher, e, n.iv),
        i = Buffer.concat([r.update(t), r.final()]);
      return { authTag: r.getAuthTag(), blob: i, iv: n.iv };
    }
    function l(e, t, { cipher: n = "aes-256-gcm", iv: r, authTag: i } = {}) {
      const c = o.default.createDecipheriv(n, e, r);
      return c.setAuthTag(i), Buffer.concat([c.update(t), c.final()]);
    }
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(169);
    e.exports = {
      readJson: r(o.readFile),
      readJsonSync: o.readFileSync,
      writeJson: r(o.writeFile),
      writeJsonSync: o.writeFileSync,
    };
  },
  function (e, t) {
    e.exports = require("os");
  },
  function (e, t) {
    e.exports = require("module");
  },
  function (e, t) {
    var n = 1e3,
      r = 60 * n,
      o = 60 * r,
      i = 24 * o,
      c = 365.25 * i;
    function s(e, t, n) {
      if (!(e < t))
        return e < 1.5 * t
          ? Math.floor(e / t) + " " + n
          : Math.ceil(e / t) + " " + n + "s";
    }
    e.exports = function (e, t) {
      t = t || {};
      var a,
        u = typeof e;
      if ("string" === u && e.length > 0)
        return (function (e) {
          if ((e = String(e)).length > 1e4) return;
          var t =
            /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
              e,
            );
          if (!t) return;
          var s = parseFloat(t[1]);
          switch ((t[2] || "ms").toLowerCase()) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return s * c;
            case "days":
            case "day":
            case "d":
              return s * i;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return s * o;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return s * r;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return s * n;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return s;
            default:
              return;
          }
        })(e);
      if ("number" === u && !1 === isNaN(e))
        return t.long
          ? s((a = e), i, "day") ||
              s(a, o, "hour") ||
              s(a, r, "minute") ||
              s(a, n, "second") ||
              a + " ms"
          : (function (e) {
              if (e >= i) return Math.round(e / i) + "d";
              if (e >= o) return Math.round(e / o) + "h";
              if (e >= r) return Math.round(e / r) + "m";
              if (e >= n) return Math.round(e / n) + "s";
              return e + "ms";
            })(e);
      throw new Error(
        "val is not a non-empty string or a valid number. val=" +
          JSON.stringify(e),
      );
    };
  },
  function (e, t, n) {
    e.exports = n(101);
  },
  function (e, t) {
    e.exports = function (e) {
      if ("function" == typeof Buffer.allocUnsafe)
        try {
          return Buffer.allocUnsafe(e);
        } catch (t) {
          return new Buffer(e);
        }
      return new Buffer(e);
    };
  },
  function (e, t, n) {
    e.exports = { copySync: n(94) };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(38),
      i = n(0);
    e.exports = {
      hasMillisRes: function (e) {
        let t = i.join(
          "millis-test" +
            Date.now().toString() +
            Math.random().toString().slice(2),
        );
        t = i.join(o.tmpdir(), t);
        const n = new Date(1435410243862);
        r.writeFile(
          t,
          "https://github.com/jprichardson/node-fs-extra/pull/141",
          (o) => {
            if (o) return e(o);
            r.open(t, "r+", (o, i) => {
              if (o) return e(o);
              r.futimes(i, n, n, (n) => {
                if (n) return e(n);
                r.close(i, (n) => {
                  if (n) return e(n);
                  r.stat(t, (t, n) => {
                    if (t) return e(t);
                    e(null, n.mtime > 1435410243e3);
                  });
                });
              });
            });
          },
        );
      },
      hasMillisResSync: function () {
        let e = i.join(
          "millis-test-sync" +
            Date.now().toString() +
            Math.random().toString().slice(2),
        );
        e = i.join(o.tmpdir(), e);
        const t = new Date(1435410243862);
        r.writeFileSync(
          e,
          "https://github.com/jprichardson/node-fs-extra/pull/141",
        );
        const n = r.openSync(e, "r+");
        return (
          r.futimesSync(n, t, t),
          r.closeSync(n),
          r.statSync(e).mtime > 1435410243e3
        );
      },
      timeRemoveMillis: function (e) {
        if ("number" == typeof e) return 1e3 * Math.floor(e / 1e3);
        if (e instanceof Date)
          return new Date(1e3 * Math.floor(e.getTime() / 1e3));
        throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
      },
      utimesMillis: function (e, t, n, o) {
        r.open(e, "r+", (e, i) => {
          if (e) return o(e);
          r.futimes(i, t, n, (e) => {
            r.close(i, (t) => {
              o && o(e || t);
            });
          });
        });
      },
      utimesMillisSync: function (e, t, n) {
        const o = r.openSync(e, "r+");
        return r.futimesSync(o, t, n), r.closeSync(o);
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0);
    function o(e) {
      return (e = r.normalize(r.resolve(e)).split(r.sep)).length > 0
        ? e[0]
        : null;
    }
    const i = /[<>:"|?*]/;
    e.exports = {
      getRootPath: o,
      invalidWin32Path: function (e) {
        const t = o(e);
        return (e = e.replace(t, "")), i.test(e);
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(6).mkdirs,
      c = n(10).pathExists,
      s = n(44).utimesMillis,
      a = Symbol("notExist"),
      u = Symbol("existsReg");
    function f(e, t, n, r) {
      const s = o.dirname(t);
      c(s, (o, c) =>
        o
          ? r(o)
          : c
          ? l(e, t, n, r)
          : void i(s, (o) => (o ? r(o) : l(e, t, n, r))),
      );
    }
    function l(e, t, n, r) {
      return n.filter ? d(y, e, t, n, r) : y(e, t, n, r);
    }
    function d(e, t, n, r, o) {
      Promise.resolve(r.filter(t, n)).then(
        (i) => (i ? e(t, n, r, o) : o()),
        (e) => o(e),
      );
    }
    function y(e, t, n, i) {
      (n.dereference ? r.stat : r.lstat)(e, (c, s) =>
        c
          ? i(c)
          : s.isDirectory()
          ? (function (e, t, n, o, i) {
              S(n, (c, s) =>
                c
                  ? i(c)
                  : s === a
                  ? E(t, n)
                    ? i(
                        new Error(
                          `Cannot copy '${t}' to a subdirectory of itself, '${n}'.`,
                        ),
                      )
                    : (function (e, t, n, o, i) {
                        r.mkdir(n, e.mode, (c) => {
                          if (c) return i(c);
                          r.chmod(n, e.mode, (e) => (e ? i(e) : w(t, n, o, i)));
                        });
                      })(e, t, n, o, i)
                  : s === u
                  ? E(t, n)
                    ? i(
                        new Error(
                          `Cannot copy '${t}' to a subdirectory of itself, '${n}'.`,
                        ),
                      )
                    : (function (e, t, n, o) {
                        r.stat(t, (r, i) =>
                          r
                            ? o(r)
                            : i.isDirectory()
                            ? w(e, t, n, o)
                            : o(
                                new Error(
                                  `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
                                ),
                              ),
                        );
                      })(t, n, o, i)
                  : t === s
                  ? i()
                  : w(t, n, o, i),
              );
            })(s, e, t, n, i)
          : s.isFile() || s.isCharacterDevice() || s.isBlockDevice()
          ? (function (e, t, n, r, o) {
              S(n, (i, c) =>
                i
                  ? o(i)
                  : c === a
                  ? m(e, t, n, r, o)
                  : c === u
                  ? p(e, t, n, r, o)
                  : t === c
                  ? o()
                  : p(e, t, n, r, o),
              );
            })(s, e, t, n, i)
          : s.isSymbolicLink()
          ? (function (e, t, n, i) {
              r.readlink(e, (e, c) => {
                if (e) return i(e);
                n.dereference && (c = o.resolve(process.cwd(), c)),
                  S(t, (e, s) =>
                    e
                      ? i(e)
                      : s === a || s === u
                      ? r.symlink(c, t, i)
                      : (n.dereference && (s = o.resolve(process.cwd(), s)),
                        s === c
                          ? i()
                          : void r.stat(t, (e, n) =>
                              e
                                ? i(e)
                                : n.isDirectory() && E(s, c)
                                ? i(
                                    new Error(
                                      `Cannot overwrite '${s}' with '${c}'.`,
                                    ),
                                  )
                                : (function (e, t, n) {
                                    r.unlink(t, (o) =>
                                      o ? n(o) : r.symlink(e, t, n),
                                    );
                                  })(c, t, i),
                            )),
                  );
              });
            })(e, t, n, i)
          : void 0,
      );
    }
    function p(e, t, n, o, i) {
      if (!o.overwrite)
        return o.errorOnExist ? i(new Error(`'${n}' already exists`)) : i();
      r.unlink(n, (r) => (r ? i(r) : m(e, t, n, o, i)));
    }
    function m(e, t, n, o, i) {
      return "function" == typeof r.copyFile
        ? r.copyFile(t, n, (t) => (t ? i(t) : h(e, n, o, i)))
        : (function (e, t, n, o, i) {
            const c = r.createReadStream(t);
            c.on("error", (e) => i(e)).once("open", () => {
              const t = r.createWriteStream(n, { mode: e.mode });
              t.on("error", (e) => i(e))
                .on("open", () => c.pipe(t))
                .once("close", () => h(e, n, o, i));
            });
          })(e, t, n, o, i);
    }
    function h(e, t, n, o) {
      r.chmod(t, e.mode, (r) =>
        r ? o(r) : n.preserveTimestamps ? s(t, e.atime, e.mtime, o) : o(),
      );
    }
    function w(e, t, n, i) {
      r.readdir(e, (r, c) =>
        r
          ? i(r)
          : (function e(t, n, r, i, c) {
              const s = t.pop();
              if (!s) return c();
              l(o.join(n, s), o.join(r, s), i, (o) =>
                o ? c(o) : e(t, n, r, i, c),
              );
            })(c, e, t, n, i),
      );
    }
    function S(e, t) {
      r.readlink(e, (e, n) =>
        e
          ? "ENOENT" === e.code
            ? t(null, a)
            : "EINVAL" === e.code || "UNKNOWN" === e.code
            ? t(null, u)
            : t(e)
          : t(null, n),
      );
    }
    function E(e, t) {
      const n = t.split(o.dirname(e) + o.sep)[1];
      if (n) {
        const r = n.split(o.sep)[0];
        return !!r && e !== t && t.indexOf(e) > -1 && r === o.basename(e);
      }
      return !1;
    }
    e.exports = function (e, t, n, r) {
      return (
        "function" != typeof n || r
          ? "function" == typeof n && (n = { filter: n })
          : ((r = n), (n = {})),
        (r = r || function () {}),
        ((n = n || {}).clobber = !("clobber" in n && !n.clobber)),
        (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
        n.preserveTimestamps &&
          "ia32" === process.arch &&
          console.warn(
            "fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269",
          ),
        (e = o.resolve(e)) === (t = o.resolve(t))
          ? r(new Error("Source and destination must not be the same."))
          : n.filter
          ? d(f, e, t, n, r)
          : f(e, t, n, r)
      );
    };
  },
  function (e, t, n) {
    const r = n(2).fromCallback,
      o = n(1),
      i = [
        "access",
        "appendFile",
        "chmod",
        "chown",
        "close",
        "copyFile",
        "fchmod",
        "fchown",
        "fdatasync",
        "fstat",
        "fsync",
        "ftruncate",
        "futimes",
        "lchown",
        "link",
        "lstat",
        "mkdir",
        "mkdtemp",
        "open",
        "readFile",
        "readdir",
        "readlink",
        "realpath",
        "rename",
        "rmdir",
        "stat",
        "symlink",
        "truncate",
        "unlink",
        "utimes",
        "writeFile",
      ].filter((e) => "function" == typeof o[e]);
    Object.keys(o).forEach((e) => {
      t[e] = o[e];
    }),
      i.forEach((e) => {
        t[e] = r(o[e]);
      }),
      (t.exists = function (e, t) {
        return "function" == typeof t
          ? o.exists(e, t)
          : new Promise((t) => o.exists(e, t));
      }),
      (t.read = function (e, t, n, r, i, c) {
        return "function" == typeof c
          ? o.read(e, t, n, r, i, c)
          : new Promise((c, s) => {
              o.read(e, t, n, r, i, (e, t, n) => {
                if (e) return s(e);
                c({ bytesRead: t, buffer: n });
              });
            });
      }),
      (t.write = function (e, t, n, r, i, c) {
        return "function" == typeof arguments[arguments.length - 1]
          ? o.write(e, t, n, r, i, c)
          : "string" == typeof t
          ? new Promise((i, c) => {
              o.write(e, t, n, r, (e, t, n) => {
                if (e) return c(e);
                i({ bytesWritten: t, buffer: n });
              });
            })
          : new Promise((c, s) => {
              o.write(e, t, n, r, i, (e, t, n) => {
                if (e) return s(e);
                c({ bytesWritten: t, buffer: n });
              });
            });
      });
  },
  function (e, t, n) {
    "use strict";
    const r = n(1);
    e.exports = {
      utimesMillis: function (e, t, n, o) {
        r.open(e, "r+", (e, i) => {
          if (e) return o(e);
          r.futimes(i, t, n, (e) => {
            r.close(i, (t) => {
              o && o(e || t);
            });
          });
        });
      },
      utimesMillisSync: function (e, t, n) {
        const o = r.openSync(e, "r+");
        return r.futimesSync(o, t, n), r.closeSync(o);
      },
    };
  },
  function (e, t) {
    e.exports = function (e) {
      if ("function" == typeof Buffer.allocUnsafe)
        try {
          return Buffer.allocUnsafe(e);
        } catch (t) {
          return new Buffer(e);
        }
      return new Buffer(e);
    };
  },
  function (e, t, n) {
    e.exports = { copySync: n(138) };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0);
    function o(e) {
      return (e = r.normalize(r.resolve(e)).split(r.sep)).length > 0
        ? e[0]
        : null;
    }
    const i = /[<>:"|?*]/;
    e.exports = {
      getRootPath: o,
      invalidWin32Path: function (e) {
        const t = o(e);
        return (e = e.replace(t, "")), i.test(e);
      },
    };
  },
  function (e, t, n) {
    var r = n(1),
      o = n(0),
      i = n(141);
    e.exports = function (e, t, n, c) {
      c || ((c = n), (n = {}));
      var s = process.cwd(),
        a = o.resolve(s, e),
        u = o.resolve(s, t),
        f = n.filter,
        l = n.transform,
        d = n.overwrite;
      void 0 === d && (d = n.clobber), void 0 === d && (d = !0);
      var y = n.errorOnExist,
        p = n.dereference,
        m = !0 === n.preserveTimestamps,
        h = 0,
        w = 0,
        S = 0,
        E = !1;
      function v(e) {
        if ((h++, f))
          if (f instanceof RegExp) {
            if (
              (console.warn(
                "Warning: fs-extra: Passing a RegExp filter is deprecated, use a function",
              ),
              !f.test(e))
            )
              return N(!0);
          } else if ("function" == typeof f && !f(e, t)) return N(!0);
        return (function (e) {
          var t = p ? r.stat : r.lstat;
          S++,
            t(e, function (t, n) {
              if (t) return T(t);
              var i,
                c,
                f = {
                  name: e,
                  mode: n.mode,
                  mtime: n.mtime,
                  atime: n.atime,
                  stats: n,
                };
              if (!n.isDirectory())
                return n.isFile() || n.isCharacterDevice() || n.isBlockDevice()
                  ? (function (e) {
                      var t = e.name.replace(a, u.replace("$", "$$$$"));
                      O(t, function (n) {
                        n
                          ? b(e, t)
                          : d
                          ? g(t, function () {
                              b(e, t);
                            })
                          : y
                          ? T(new Error(t + " already exists"))
                          : N();
                      });
                    })(f)
                  : n.isSymbolicLink()
                  ? (function (e) {
                      var t = e.replace(a, u);
                      r.readlink(e, function (e, n) {
                        if (e) return T(e);
                        !(function (e, t) {
                          p && (e = o.resolve(s, e)),
                            O(t, function (n) {
                              if (n) return x(e, t);
                              r.readlink(t, function (n, r) {
                                return n
                                  ? T(n)
                                  : (p && (r = o.resolve(s, r)),
                                    r === e
                                      ? N()
                                      : g(t, function () {
                                          x(e, t);
                                        }));
                              });
                            });
                        })(n, t);
                      });
                    })(e)
                  : void 0;
              O(
                (c = (i = f).name.replace(a, u.replace("$", "$$$$"))),
                function (e) {
                  if (e)
                    return (function (e, t) {
                      r.mkdir(t, e.mode, function (n) {
                        if (n) return T(n);
                        r.chmod(t, e.mode, function (t) {
                          if (t) return T(t);
                          k(e.name);
                        });
                      });
                    })(i, c);
                  k(i.name);
                },
              );
            });
        })(e);
      }
      function b(e, t) {
        var n = r.createReadStream(e.name),
          o = r.createWriteStream(t, { mode: e.mode });
        n.on("error", T),
          o.on("error", T),
          l
            ? l(n, o, e)
            : o.on("open", function () {
                n.pipe(o);
              }),
          o.once("close", function () {
            r.chmod(t, e.mode, function (n) {
              if (n) return T(n);
              m
                ? i.utimesMillis(t, e.atime, e.mtime, function (e) {
                    return e ? T(e) : N();
                  })
                : N();
            });
          });
      }
      function g(e, t) {
        r.unlink(e, function (e) {
          return e ? T(e) : t();
        });
      }
      function k(e) {
        r.readdir(e, function (t, n) {
          return t
            ? T(t)
            : (n.forEach(function (t) {
                v(o.join(e, t));
              }),
              N());
        });
      }
      function x(e, t) {
        r.symlink(e, t, function (e) {
          return e ? T(e) : N();
        });
      }
      function O(e, t) {
        r.lstat(e, function (e) {
          return e && "ENOENT" === e.code ? t(!0) : t(!1);
        });
      }
      function T(e) {
        if (!E && void 0 !== c) return (E = !0), c(e);
      }
      function N(e) {
        if ((e || S--, h === ++w && 0 === S && void 0 !== c)) return c(null);
      }
      v(a);
    };
  },
  function (e, t, n) {
    const r = n(2).fromCallback,
      o = n(1),
      i = [
        "access",
        "appendFile",
        "chmod",
        "chown",
        "close",
        "fchmod",
        "fchown",
        "fdatasync",
        "fstat",
        "fsync",
        "ftruncate",
        "futimes",
        "lchown",
        "link",
        "lstat",
        "mkdir",
        "open",
        "read",
        "readFile",
        "readdir",
        "readlink",
        "realpath",
        "rename",
        "rmdir",
        "stat",
        "symlink",
        "truncate",
        "unlink",
        "utimes",
        "write",
        "writeFile",
      ];
    "function" == typeof o.mkdtemp && i.push("mkdtemp"),
      Object.keys(o).forEach((e) => {
        t[e] = o[e];
      }),
      i.forEach((e) => {
        t[e] = r(o[e]);
      }),
      (t.exists = function (e, t) {
        return "function" == typeof t
          ? o.exists(e, t)
          : new Promise((t) => o.exists(e, t));
      });
  },
  function (e, t) {
    e.exports = require("zlib");
  },
  function (e, t, n) {
    const r = n(19);
    e.exports = function (e) {
      return {
        expand(t) {
          const n = r.randomBytes(t.length < e - 4 ? e : t.length + 4);
          return n.writeUInt32BE(t.length, 0), t.copy(n, 4, 0), n;
        },
        shrink(e) {
          const t = e.readUInt32BE(0);
          return e.slice(4, t + 4);
        },
      };
    };
  },
  function (e, t, n) {
    "use strict";
    var r = n(15);
    e.exports = function (e) {
      if (!r.isAbstractCodec(e))
        throw new TypeError("lengthType is invalid codec");
      function t(t) {
        return e.encodingLength(t.length) + t.length;
      }
      return {
        encode: function n(r, o, i) {
          if (!Buffer.isBuffer(r))
            throw new TypeError("value must be a Buffer instance");
          if (
            (o || (o = new Buffer(t(r))),
            i || (i = 0),
            e.encode(r.length, o, i),
            (i += e.encode.bytes) + r.length > o.length)
          )
            throw new RangeError("destination buffer is too small");
          return (
            r.copy(o, i, 0, r.length), (n.bytes = e.encode.bytes + r.length), o
          );
        },
        decode: function t(n, r, o) {
          r || (r = 0), o || (o = n.length);
          var i = e.decode(n, r, o);
          if ((r += e.decode.bytes) + i > o)
            throw new RangeError("not enough data for decode");
          return (t.bytes = e.decode.bytes + i), new Buffer(n.slice(r, r + i));
        },
        encodingLength: function (e) {
          if (!Buffer.isBuffer(e))
            throw new TypeError("value must be a Buffer instance");
          return t(e);
        },
      };
    };
  },
  function (e, t, n) {
    "use strict";
    e.exports = function (e) {
      if ("number" != typeof e) throw new TypeError("length must be a number");
      function t(t, n, r) {
        if (!Buffer.isBuffer(t))
          throw new TypeError("value must be a Buffer instance");
        if (t.length !== e)
          throw new RangeError("value.length is out of bounds");
        if (!n) return new Buffer(t);
        if ((r || (r = 0), r + e > n.length))
          throw new RangeError("destination buffer is too small");
        return t.copy(n, r), n;
      }
      function n(t, n, r) {
        if ((n || (n = 0), r || (r = t.length), n + e > r))
          throw new RangeError("not enough data for decode");
        return new Buffer(t.slice(n, n + e));
      }
      return (
        (t.bytes = n.bytes = e),
        {
          encode: t,
          decode: n,
          encodingLength: function () {
            return e;
          },
        }
      );
    };
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.encrypt = function (e, t, n) {
        const { authTag: o, iv: i, blob: c } = r.aesEncrypt(n, e);
        return (t.blob = { authTag: o, iv: i }), { blob: c, blobKey: n };
      }),
      (t.decrypt = function (e, t, n) {
        return r.aesDecrypt(n, e, t.blob);
      });
    var r = (function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (null != e)
        for (var n in e)
          Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
      return (t.default = e), t;
    })(n(36));
  },
  function (e, t) {
    e.exports = function (e) {
      if ("function" == typeof Buffer.allocUnsafe)
        try {
          return Buffer.allocUnsafe(e);
        } catch (t) {
          return new Buffer(e);
        }
      return new Buffer(e);
    };
  },
  function (e, t, n) {
    e.exports = { copySync: n(172) };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(38),
      i = n(0);
    e.exports = {
      hasMillisRes: function (e) {
        let t = i.join(
          "millis-test" +
            Date.now().toString() +
            Math.random().toString().slice(2),
        );
        t = i.join(o.tmpdir(), t);
        const n = new Date(1435410243862);
        r.writeFile(
          t,
          "https://github.com/jprichardson/node-fs-extra/pull/141",
          (o) => {
            if (o) return e(o);
            r.open(t, "r+", (o, i) => {
              if (o) return e(o);
              r.futimes(i, n, n, (n) => {
                if (n) return e(n);
                r.close(i, (n) => {
                  if (n) return e(n);
                  r.stat(t, (t, n) => {
                    if (t) return e(t);
                    e(null, n.mtime > 1435410243e3);
                  });
                });
              });
            });
          },
        );
      },
      hasMillisResSync: function () {
        let e = i.join(
          "millis-test-sync" +
            Date.now().toString() +
            Math.random().toString().slice(2),
        );
        e = i.join(o.tmpdir(), e);
        const t = new Date(1435410243862);
        r.writeFileSync(
          e,
          "https://github.com/jprichardson/node-fs-extra/pull/141",
        );
        const n = r.openSync(e, "r+");
        return (
          r.futimesSync(n, t, t),
          r.closeSync(n),
          r.statSync(e).mtime > 1435410243e3
        );
      },
      timeRemoveMillis: function (e) {
        if ("number" == typeof e) return 1e3 * Math.floor(e / 1e3);
        if (e instanceof Date)
          return new Date(1e3 * Math.floor(e.getTime() / 1e3));
        throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
      },
      utimesMillis: function (e, t, n, o) {
        r.open(e, "r+", (e, i) => {
          if (e) return o(e);
          r.futimes(i, t, n, (e) => {
            r.close(i, (t) => {
              o && o(e || t);
            });
          });
        });
      },
      utimesMillisSync: function (e, t, n) {
        const o = r.openSync(e, "r+");
        return r.futimesSync(o, t, n), r.closeSync(o);
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0);
    function o(e) {
      return (e = r.normalize(r.resolve(e)).split(r.sep)).length > 0
        ? e[0]
        : null;
    }
    const i = /[<>:"|?*]/;
    e.exports = {
      getRootPath: o,
      invalidWin32Path: function (e) {
        const t = o(e);
        return (e = e.replace(t, "")), i.test(e);
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(8).mkdirs,
      c = n(12).pathExists,
      s = n(61).utimesMillis,
      a = Symbol("notExist"),
      u = Symbol("existsReg");
    function f(e, t, n, r) {
      const s = o.dirname(t);
      c(s, (o, c) =>
        o
          ? r(o)
          : c
          ? l(e, t, n, r)
          : void i(s, (o) => (o ? r(o) : l(e, t, n, r))),
      );
    }
    function l(e, t, n, r) {
      return n.filter ? d(y, e, t, n, r) : y(e, t, n, r);
    }
    function d(e, t, n, r, o) {
      Promise.resolve(r.filter(t, n)).then(
        (i) => (i ? e(t, n, r, o) : o()),
        (e) => o(e),
      );
    }
    function y(e, t, n, i) {
      (n.dereference ? r.stat : r.lstat)(e, (c, s) =>
        c
          ? i(c)
          : s.isDirectory()
          ? (function (e, t, n, o, i) {
              S(n, (c, s) =>
                c
                  ? i(c)
                  : s === a
                  ? E(t, n)
                    ? i(
                        new Error(
                          `Cannot copy '${t}' to a subdirectory of itself, '${n}'.`,
                        ),
                      )
                    : (function (e, t, n, o, i) {
                        r.mkdir(n, e.mode, (c) => {
                          if (c) return i(c);
                          r.chmod(n, e.mode, (e) => (e ? i(e) : w(t, n, o, i)));
                        });
                      })(e, t, n, o, i)
                  : s === u
                  ? E(t, n)
                    ? i(
                        new Error(
                          `Cannot copy '${t}' to a subdirectory of itself, '${n}'.`,
                        ),
                      )
                    : (function (e, t, n, o) {
                        r.stat(t, (r, i) =>
                          r
                            ? o(r)
                            : i.isDirectory()
                            ? w(e, t, n, o)
                            : o(
                                new Error(
                                  `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
                                ),
                              ),
                        );
                      })(t, n, o, i)
                  : t === s
                  ? i()
                  : w(t, n, o, i),
              );
            })(s, e, t, n, i)
          : s.isFile() || s.isCharacterDevice() || s.isBlockDevice()
          ? (function (e, t, n, r, o) {
              S(n, (i, c) =>
                i
                  ? o(i)
                  : c === a
                  ? m(e, t, n, r, o)
                  : c === u
                  ? p(e, t, n, r, o)
                  : t === c
                  ? o()
                  : p(e, t, n, r, o),
              );
            })(s, e, t, n, i)
          : s.isSymbolicLink()
          ? (function (e, t, n, i) {
              r.readlink(e, (e, c) => {
                if (e) return i(e);
                n.dereference && (c = o.resolve(process.cwd(), c)),
                  S(t, (e, s) =>
                    e
                      ? i(e)
                      : s === a || s === u
                      ? r.symlink(c, t, i)
                      : (n.dereference && (s = o.resolve(process.cwd(), s)),
                        s === c
                          ? i()
                          : void r.stat(t, (e, n) =>
                              e
                                ? i(e)
                                : n.isDirectory() && E(s, c)
                                ? i(
                                    new Error(
                                      `Cannot overwrite '${s}' with '${c}'.`,
                                    ),
                                  )
                                : (function (e, t, n) {
                                    r.unlink(t, (o) =>
                                      o ? n(o) : r.symlink(e, t, n),
                                    );
                                  })(c, t, i),
                            )),
                  );
              });
            })(e, t, n, i)
          : void 0,
      );
    }
    function p(e, t, n, o, i) {
      if (!o.overwrite)
        return o.errorOnExist ? i(new Error(`'${n}' already exists`)) : i();
      r.unlink(n, (r) => (r ? i(r) : m(e, t, n, o, i)));
    }
    function m(e, t, n, o, i) {
      return "function" == typeof r.copyFile
        ? r.copyFile(t, n, (t) => (t ? i(t) : h(e, n, o, i)))
        : (function (e, t, n, o, i) {
            const c = r.createReadStream(t);
            c.on("error", (e) => i(e)).once("open", () => {
              const t = r.createWriteStream(n, { mode: e.mode });
              t.on("error", (e) => i(e))
                .on("open", () => c.pipe(t))
                .once("close", () => h(e, n, o, i));
            });
          })(e, t, n, o, i);
    }
    function h(e, t, n, o) {
      r.chmod(t, e.mode, (r) =>
        r ? o(r) : n.preserveTimestamps ? s(t, e.atime, e.mtime, o) : o(),
      );
    }
    function w(e, t, n, i) {
      r.readdir(e, (r, c) =>
        r
          ? i(r)
          : (function e(t, n, r, i, c) {
              const s = t.pop();
              if (!s) return c();
              l(o.join(n, s), o.join(r, s), i, (o) =>
                o ? c(o) : e(t, n, r, i, c),
              );
            })(c, e, t, n, i),
      );
    }
    function S(e, t) {
      r.readlink(e, (e, n) =>
        e
          ? "ENOENT" === e.code
            ? t(null, a)
            : "EINVAL" === e.code || "UNKNOWN" === e.code
            ? t(null, u)
            : t(e)
          : t(null, n),
      );
    }
    function E(e, t) {
      const n = t.split(o.dirname(e) + o.sep)[1];
      if (n) {
        const r = n.split(o.sep)[0];
        return !!r && e !== t && t.indexOf(e) > -1 && r === o.basename(e);
      }
      return !1;
    }
    e.exports = function (e, t, n, r) {
      return (
        "function" != typeof n || r
          ? "function" == typeof n && (n = { filter: n })
          : ((r = n), (n = {})),
        (r = r || function () {}),
        ((n = n || {}).clobber = !("clobber" in n && !n.clobber)),
        (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
        n.preserveTimestamps &&
          "ia32" === process.arch &&
          console.warn(
            "fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269",
          ),
        (e = o.resolve(e)) === (t = o.resolve(t))
          ? r(new Error("Source and destination must not be the same."))
          : n.filter
          ? d(f, e, t, n, r)
          : f(e, t, n, r)
      );
    };
  },
  function (e, t) {
    e.exports = require("util");
  },
  function (e, t, n) {
    const r = n(2).fromCallback,
      o = n(1),
      i = [
        "access",
        "appendFile",
        "chmod",
        "chown",
        "close",
        "copyFile",
        "fchmod",
        "fchown",
        "fdatasync",
        "fstat",
        "fsync",
        "ftruncate",
        "futimes",
        "lchown",
        "link",
        "lstat",
        "mkdir",
        "mkdtemp",
        "open",
        "readFile",
        "readdir",
        "readlink",
        "realpath",
        "rename",
        "rmdir",
        "stat",
        "symlink",
        "truncate",
        "unlink",
        "utimes",
        "writeFile",
      ].filter((e) => "function" == typeof o[e]);
    Object.keys(o).forEach((e) => {
      t[e] = o[e];
    }),
      i.forEach((e) => {
        t[e] = r(o[e]);
      }),
      (t.exists = function (e, t) {
        return "function" == typeof t
          ? o.exists(e, t)
          : new Promise((t) => o.exists(e, t));
      }),
      (t.read = function (e, t, n, r, i, c) {
        return "function" == typeof c
          ? o.read(e, t, n, r, i, c)
          : new Promise((c, s) => {
              o.read(e, t, n, r, i, (e, t, n) => {
                if (e) return s(e);
                c({ bytesRead: t, buffer: n });
              });
            });
      }),
      (t.write = function (e, t, n, r, i, c) {
        return "function" == typeof arguments[arguments.length - 1]
          ? o.write(e, t, n, r, i, c)
          : "string" == typeof t
          ? new Promise((i, c) => {
              o.write(e, t, n, r, (e, t, n) => {
                if (e) return c(e);
                i({ bytesWritten: t, buffer: n });
              });
            })
          : new Promise((c, s) => {
              o.write(e, t, n, r, i, (e, t, n) => {
                if (e) return s(e);
                c({ bytesWritten: t, buffer: n });
              });
            });
      });
  },
  function (e) {
    e.exports = {
      name: "exodus",
      productName: "Exodus",
      version: "23.8.1",
      description: "Secure, manage, and trade blockchain assets.",
    };
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 });
    var r = a(n(184)),
      o = a(n(55)),
      i = n(54),
      c = a(n(145)),
      s = n(19);
    function a(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function u(e) {
      return function () {
        var t = e.apply(this, arguments);
        return new Promise(function (e, n) {
          return (function r(o, i) {
            try {
              var c = t[o](i),
                s = c.value;
            } catch (e) {
              return void n(e);
            }
            if (!c.done)
              return Promise.resolve(s).then(
                function (e) {
                  r("next", e);
                },
                function (e) {
                  r("throw", e);
                },
              );
            e(s);
          })("next");
        });
      };
    }
    const { expand: f, shrink: l } = (0, o.default)(Math.pow(2, 15));
    t.default = class {
      constructor(e, t) {
        (this.hasOpened = !1),
          (this.file = e),
          (this.header = t),
          (this._data = {}),
          (this._hash = Buffer.alloc(0));
      }
      open(e, t = {}) {
        var n = this;
        return u(function* () {
          if (
            ((n._seco = (0, r.default)(n.file, e, n.header)),
            yield c.default.pathExists(n.file))
          ) {
            let e = yield n._seco.read();
            (e = (0, i.gunzipSync)(l(e))),
              (n._data = JSON.parse(e.toString("utf8")));
          } else
            yield n._seco.write(
              f((0, i.gzipSync)(Buffer.from(JSON.stringify(t)))),
            ),
              (n._data = t);
          n.hasOpened = !0;
        })();
      }
      getAllData() {
        return this._data;
      }
      setAllData(e = {}) {
        var t = this;
        return u(function* () {
          if (!t.hasOpened) throw new Error("Must open first.");
          yield t._seco.write(
            f((0, i.gzipSync)(Buffer.from(JSON.stringify(e)))),
          ),
            (t._data = e);
        })();
      }
      set(e, t) {
        var n = this;
        return u(function* () {
          return n.batch([{ type: "set", key: e, value: t }]);
        })();
      }
      batch(e) {
        var t = this;
        return u(function* () {
          if (!t.hasOpened) throw new Error("Must open first.");
          e.forEach(function ({ type: e, key: n, value: r }) {
            switch (e) {
              case "set":
                t._data[n] = r;
                break;
              case "delete":
                delete t._data[n];
            }
          });
          const n = Buffer.from(JSON.stringify(t._data)),
            r = (0, s.createHash)("sha256").update(n).digest();
          t._hash.equals(r) ||
            ((t._hash = r), yield t._seco.write(f((0, i.gzipSync)(n))));
        })();
      }
      get(e) {
        if (!this.hasOpened) throw new Error("Must open first.");
        return this._data[e];
      }
      delete(e) {
        var t = this;
        return u(function* () {
          return t.batch([{ type: "delete", key: e }]);
        })();
      }
      changePassphraseOnNextWrite(e) {
        if (!this.hasOpened) throw new Error("Must open first.");
        this._seco = (0, r.default)(this.file, e, this.header);
      }
      changePassphrase(e) {
        var t = this;
        return u(function* () {
          t.changePassphraseOnNextWrite(e),
            yield t._seco.write(
              f((0, i.gzipSync)(Buffer.from(JSON.stringify(t._data)))),
            );
        })();
      }
      inspect() {
        return `<SecoKeyval: ${this.file}>`;
      }
    };
  },
  function (e, t, n) {
    "use strict";
    e.exports = () => {
      const e = {};
      return (
        (e.promise = new Promise((t, n) => {
          (e.resolve = t), (e.reject = n);
        })),
        e
      );
    };
  },
  function (e, t) {
    function n(e) {
      if (!(this instanceof n)) return new n(e);
      this.value = e;
    }
    function r(e, t, n) {
      var r = [],
        i = [],
        c = !0;
      return (function e(s) {
        var a = n ? o(s) : s,
          u = {},
          f = {
            node: a,
            node_: s,
            path: [].concat(r),
            parent: i.slice(-1)[0],
            key: r.slice(-1)[0],
            isRoot: 0 === r.length,
            level: r.length,
            circular: null,
            update: function (e) {
              f.isRoot || (f.parent.node[f.key] = e), (f.node = e);
            },
            delete: function () {
              delete f.parent.node[f.key];
            },
            remove: function () {
              Array.isArray(f.parent.node)
                ? f.parent.node.splice(f.key, 1)
                : delete f.parent.node[f.key];
            },
            before: function (e) {
              u.before = e;
            },
            after: function (e) {
              u.after = e;
            },
            pre: function (e) {
              u.pre = e;
            },
            post: function (e) {
              u.post = e;
            },
            stop: function () {
              c = !1;
            },
          };
        if (!c) return f;
        if ("object" == typeof a && null !== a) {
          f.isLeaf = 0 == Object.keys(a).length;
          for (var l = 0; l < i.length; l++)
            if (i[l].node_ === s) {
              f.circular = i[l];
              break;
            }
        } else f.isLeaf = !0;
        (f.notLeaf = !f.isLeaf), (f.notRoot = !f.isRoot);
        var d = t.call(f, f.node);
        if (
          (void 0 !== d && f.update && f.update(d),
          u.before && u.before.call(f, f.node),
          "object" == typeof f.node && null !== f.node && !f.circular)
        ) {
          i.push(f);
          var y = Object.keys(f.node);
          y.forEach(function (t, o) {
            r.push(t), u.pre && u.pre.call(f, f.node[t], t);
            var i = e(f.node[t]);
            n && Object.hasOwnProperty.call(f.node, t) && (f.node[t] = i.node),
              (i.isLast = o == y.length - 1),
              (i.isFirst = 0 == o),
              u.post && u.post.call(f, i),
              r.pop();
          }),
            i.pop();
        }
        return u.after && u.after.call(f, f.node), f;
      })(e).node;
    }
    function o(e) {
      var t;
      return "object" == typeof e && null !== e
        ? ((t = Array.isArray(e)
            ? []
            : e instanceof Date
            ? new Date(e)
            : e instanceof Boolean
            ? new Boolean(e)
            : e instanceof Number
            ? new Number(e)
            : e instanceof String
            ? new String(e)
            : Object.create(Object.getPrototypeOf(e))),
          Object.keys(e).forEach(function (n) {
            t[n] = e[n];
          }),
          t)
        : e;
    }
    (e.exports = n),
      (n.prototype.get = function (e) {
        for (var t = this.value, n = 0; n < e.length; n++) {
          var r = e[n];
          if (!Object.hasOwnProperty.call(t, r)) {
            t = void 0;
            break;
          }
          t = t[r];
        }
        return t;
      }),
      (n.prototype.set = function (e, t) {
        for (var n = this.value, r = 0; r < e.length - 1; r++) {
          var o = e[r];
          Object.hasOwnProperty.call(n, o) || (n[o] = {}), (n = n[o]);
        }
        return (n[e[r]] = t), t;
      }),
      (n.prototype.map = function (e) {
        return r(this.value, e, !0);
      }),
      (n.prototype.forEach = function (e) {
        return (this.value = r(this.value, e, !1)), this.value;
      }),
      (n.prototype.reduce = function (e, t) {
        var n = 1 === arguments.length,
          r = n ? this.value : t;
        return (
          this.forEach(function (t) {
            (this.isRoot && n) || (r = e.call(this, r, t));
          }),
          r
        );
      }),
      (n.prototype.deepEqual = function (e) {
        if (1 !== arguments.length)
          throw new Error(
            "deepEqual requires exactly one object to compare against",
          );
        var t = !0,
          r = e;
        return (
          this.forEach(function (o) {
            var i = function () {
              t = !1;
            }.bind(this);
            if (!this.isRoot) {
              if ("object" != typeof r) return i();
              r = r[this.key];
            }
            var c = r;
            this.post(function () {
              r = c;
            });
            var s = function (e) {
              return Object.prototype.toString.call(e);
            };
            if (this.circular) n(e).get(this.circular.path) !== c && i();
            else if (typeof c != typeof o) i();
            else if (null === c || null === o || void 0 === c || void 0 === o)
              c !== o && i();
            else if (c.__proto__ !== o.__proto__) i();
            else if (c === o);
            else if ("function" == typeof c)
              c instanceof RegExp
                ? c.toString() != o.toString() && i()
                : c !== o && i();
            else if ("object" == typeof c)
              if (
                "[object Arguments]" === s(o) ||
                "[object Arguments]" === s(c)
              )
                s(c) !== s(o) && i();
              else if (c instanceof Date || o instanceof Date)
                (c instanceof Date &&
                  o instanceof Date &&
                  c.getTime() === o.getTime()) ||
                  i();
              else {
                var a = Object.keys(c),
                  u = Object.keys(o);
                if (a.length !== u.length) return i();
                for (var f = 0; f < a.length; f++) {
                  var l = a[f];
                  Object.hasOwnProperty.call(o, l) || i();
                }
              }
          }),
          t
        );
      }),
      (n.prototype.paths = function () {
        var e = [];
        return (
          this.forEach(function (t) {
            e.push(this.path);
          }),
          e
        );
      }),
      (n.prototype.nodes = function () {
        var e = [];
        return (
          this.forEach(function (t) {
            e.push(this.node);
          }),
          e
        );
      }),
      (n.prototype.clone = function () {
        var e = [],
          t = [];
        return (function n(r) {
          for (var i = 0; i < e.length; i++) if (e[i] === r) return t[i];
          if ("object" == typeof r && null !== r) {
            var c = o(r);
            return (
              e.push(r),
              t.push(c),
              Object.keys(r).forEach(function (e) {
                c[e] = n(r[e]);
              }),
              e.pop(),
              t.pop(),
              c
            );
          }
          return r;
        })(this.value);
      }),
      Object.keys(n.prototype).forEach(function (e) {
        n[e] = function (t) {
          var r = [].slice.call(arguments, 1),
            o = n(t);
          return o[e].apply(o, r);
        };
      });
  },
  function (e, t) {
    function n(e) {
      return e instanceof Error
        ? { ...e, name: e.name, message: e.message, stack: r(e.stack) }
        : { name: e.name || "UNKNOWN", message: JSON.stringify(e) };
    }
    function r(e) {
      return e
        .replace(/\/Users\/[^/]+/g, "")
        .replace(/\\Users\\[^\\]+/g, "")
        .replace(/\/home\/[^/]+/g, "");
    }
    e.exports = {
      toObject: n,
      JSONReplacer: function (e, t) {
        return t instanceof Error ? n(t) : t;
      },
      cleanStack: r,
    };
  },
  function (e, t, n) {
    "use strict";
    let r = globalThis.crypto;
    t.randomUUID = r.randomUUID.bind(r);
  },
  function (e, t, n) {
    "use strict";
    n.r(t);
    var r = n(26),
      o = n(71);
    class i extends Error {
      constructor(...e) {
        super(...e), (this.name = "UnknownError");
      }
    }
    const c = globalThis,
      s = [
        ...[
          Error,
          EvalError,
          RangeError,
          ReferenceError,
          SyntaxError,
          TypeError,
          URIError,
        ],
        ...[c.RTCError, c.OverconstrainedError, c.DOMError, c.MediaError],
        i,
        class extends Error {
          constructor(...e) {
            super(...e), (this.name = "AssertionError");
          }
        },
      ],
      a = new Map();
    for (const e of s)
      e && (e === Error || e.prototype instanceof Error) && a.set(e.name, e);
    const u = "electron-rpc-broadcast";
    function f(e, t, n, r, c, { wrap: s, unwrap: f } = {}) {
      if ("main" === n)
        throw new Error("Use 'ui' as the target instead of 'main'");
      return function (...l) {
        const d = Object(o.randomUUID)(),
          y = `${u}:${r}:response:${d}`;
        return new Promise((o, p) => {
          const m = `${u}:${r}:call`;
          s && (l = s(c, l));
          const h = { func: c, args: l, token: d };
          e.once(y, (e, { payload: t }) => {
            const [n, r] = t;
            n
              ? p(
                  (function (e) {
                    const t = new (a.get(e.name) || i)(e.message);
                    for (const n of Object.keys(e))
                      n in t ||
                        ["__proto__", "name", "message"].includes(n) ||
                        (t[n] = e[n]);
                    return e.stack && (t.stack = e.stack), t;
                  })(n),
                )
              : o(f ? f(c, r) : r);
          }),
            setImmediate(() => {
              try {
                t(n, m, h);
              } catch (e) {
                p(e);
              }
            });
        });
      };
    }
    var l = n(70);
    function d(e, t, n, r, o, i, { wrap: c, unwrap: s } = {}) {
      const a = `${u}:${r}:call`,
        f = async (e, a) => {
          const f = n(e, a);
          if (!o.includes(f))
            return void console.error(
              `Skipping unexpected message from (${f}) to channel: ${r}`,
            );
          const { func: d, args: y, token: p } = a.payload,
            [m, h] = await (async function (e, t) {
              if ("function" == typeof i[e])
                try {
                  s && (t = s(e, t));
                  let n = await i[e](...t);
                  return c && (n = c(e, n)), [null, n];
                } catch (e) {
                  return [e, null];
                }
              try {
                return [null, i[e]];
              } catch (e) {
                return [e];
              }
            })(d, y),
            w = m ? Object(l.toObject)(m) : null;
          t(f, `${u}:${r}:response:${p}`, [w, h]);
        };
      return e.on(a, f), { stop: () => e.removeListener(a, f) };
    }
    var y = n(69),
      p = n.n(y),
      m = (e) => (
        p()(e).forEach(function (e) {
          e instanceof Uint8Array && this.update(globalThis.Buffer.from(e));
        }),
        e
      );
    const h = new WeakMap(),
      w = new WeakMap();
    function S(e, t, n) {
      const r = w.get(e);
      if (r && (r.filter !== t || r.useBuffers !== n))
        throw new Error(
          "Attempting to register the same handler with different parameters",
        );
      w.set(e, { filter: t, useBuffers: n });
      const o = h.get(e);
      if (o) return o;
      const i = (r, ...o) => {
        if (!0 !== t(r)) return;
        const i = n ? m(o) : o;
        return e(r, ...i);
      };
      return h.set(e, i), i;
    }
    n.d(t, "targeted", function () {
      return g;
    }),
      n.d(t, "rpcRenderer", function () {
        return P;
      }),
      n.d(t, "rpcListener", function () {
        return I;
      }),
      n.d(t, "createServer", function () {
        return j;
      }),
      n.d(t, "createClient", function () {
        return L;
      }),
      n.d(t, "createClientMethod", function () {
        return B;
      });
    const E =
      ((v = r.ipcRenderer),
      (b = function (e) {
        return (
          0 === e.senderId ||
          (console.error(
            "Blocked direct IPC communication from a non-browser process",
          ),
          !1)
        );
      }),
      {
        on(e, t, n = !0) {
          v.on(e, S(t, b, n));
        },
        once(e, t, n = !0) {
          v.once(e, S(t, b, n));
        },
        removeListener(e, t) {
          v.removeListener(e, h.get(t));
        },
        removeAllListeners(e) {
          v.removeAllListeners(e);
        },
        handle(e, t, n = !0) {
          v.handle(e, S(t, b, n));
        },
        removeHandler(e) {
          v.removeHandler(e);
        },
        send(...e) {
          v.send(...e);
        },
        sendSync: (...e) => v.sendSync(...e),
        invoke: (...e) => v.invoke(...e),
      });
    var v, b;
    function g(e, t, n) {
      "#" === e
        ? r.ipcRenderer.send(t, { channel: t, payload: n })
        : r.ipcRenderer.send("ipc:target:send", {
            target: e,
            channel: t,
            payload: n,
          });
    }
    const {
        on: k,
        once: x,
        removeListener: O,
        removeAllListeners: T,
        send: N,
        sendSync: F,
        invoke: D,
      } = E,
      P = {
        on: k,
        once: x,
        removeListener: O,
        removeAllListeners: T,
        send: N,
        sendSync: F,
        invoke: D,
      },
      I = P;
    function j(...e) {
      return d(E, g, (e, t) => t.origin, ...e);
    }
    function L(...e) {
      return (function (e, t, n, r, o = {}) {
        return new Proxy(
          {},
          {
            get: (i, c, s) =>
              "string" == typeof c ? f(e, t, n, r, c, o) : void 0,
          },
        );
      })(E, g, ...e);
    }
    function B(...e) {
      return f(E, g, ...e);
    }
  },
  function (e, t, n) {
    "use strict";
    n.r(t);
    var r = n(3),
      o = n(68),
      i = n.n(o),
      c = 0;
    function s(e, t) {
      if (!Object.prototype.hasOwnProperty.call(e, t))
        throw new TypeError("attempted to use private field on non-instance");
      return e;
    }
    class a {
      constructor({ sendMessage: e, attachListener: t }) {
        (this.isDone = !1),
          Object.defineProperty(this, u, { writable: !0, value: i()() }),
          (this.awaitDone = () => s(this, u)[u].promise),
          t((t) => {
            switch (t) {
              case "reach":
                e("grasp"), (this.isDone = !0);
                break;
              case "grasp":
                this.isDone = !0;
            }
            this.isDone && s(this, u)[u].resolve();
          }),
          e("reach");
      }
    }
    var u = "__private_" + c++ + "_" + "deferred";
    new a({
      sendMessage: (e) =>
        Object(r.targeted)("network", "core-network-handshake", e),
      attachListener: (e) =>
        r.rpcListener.on("core-network-handshake", (t, { payload: n }) => e(n)),
    });
    new a({
      sendMessage: (e) => Object(r.targeted)("ui", "core-ui-handshake", e),
      attachListener: (e) =>
        r.rpcListener.on("core-ui-handshake", (t, { payload: n }) => e(n)),
    });
    var f = n(4),
      l = n.n(f),
      d = n(67),
      y = n.n(d);
    var p = n(41),
      m = n(0),
      h = n.n(m);
    const w = "moneroInitialHeight",
      S = "moneroSubaddressesEnabled";
    var E = n(40),
      v = n.n(E);
    const b = n(66),
      g = !1,
      k = g,
      x = void 0,
      O =
        (x && x.match(/^http/),
        Math.max(6e3, 3640),
        v()("5m"),
        v()("3s"),
        [
          { localKey: "fiat.unit", profilePath: "private.currency" },
          { localKey: w, profilePath: `private.${w}` },
          { localKey: S, profilePath: S },
          { localKey: "theme.name", profilePath: "theme" },
          {
            localKey: "advanced.advancedMode.assets.bitcoin",
            profilePath: "rbfEnabled_bitcoin",
          },
          {
            localKey: "advanced.advancedMode.assets.ethereum",
            profilePath: "rbfEnabled_ethereum",
          },
          {
            localKey: "adaLegacyAddressEnabled",
            profilePath: "private.adaLegacyAddressEnabled",
          },
          {
            localKey: "bitcoinLegacyAddressEnabled",
            profilePath: "bitcoinLegacyAddressEnabled",
          },
          {
            localKey: "bitcoinTaprootAddressEnabled",
            profilePath: "bitcoinTaprootAddressEnabled",
          },
          {
            localKey: "fiatOnramp.wentThroughFiatOnboarding",
            profilePath: "fiatOnramp.wentThroughFiatOnboarding",
          },
        ].concat(
          k ? { localKey: "assets", profilePath: "private.assets" } : [],
        ),
        "exodus.wallet"),
      T = (e) => ({
        get infoFile() {
          return h.a.join(e, "info.seco");
        },
        async infoFileExists() {
          return l.a.pathExists(this.infoFile);
        },
        get passphraseFile() {
          return h.a.join(e, "passphrase.json");
        },
        async passphraseFileExists() {
          return l.a.pathExists(this.passphraseFile);
        },
        get seedFile() {
          return h.a.join(e, "seed.seco");
        },
        async seedFileExists() {
          return l.a.pathExists(this.seedFile);
        },
        get seedBackupFile() {
          return this.seedFile + ".bak";
        },
        async seedBackupFileExists() {
          return l.a.pathExists(this.seedBackupFile);
        },
        get storageFile() {
          return h.a.join(e, "storage.seco");
        },
        get twoFactorFile() {
          return h.a.join(e, "twofactor.seco");
        },
        get twoFactorSecretFile() {
          return h.a.join(e, "twofactor-secret.seco");
        },
        async twoFactorFileExists() {
          return l.a.pathExists(this.twoFactorFile);
        },
        async twoFactorSecretFileExists() {
          return l.a.pathExists(this.twoFactorSecretFile);
        },
        get lightningFile() {
          return h.a.join(e, "lightning-v2.seco");
        },
        get lightningSecretFile() {
          return h.a.join(e, "lightning-secret-v2.seco");
        },
        async lightningFileExists() {
          return l.a.pathExists(this.lightningFile);
        },
        async lightningSecretFileExists() {
          return l.a.pathExists(this.lightningSecretFile);
        },
        async walletExists() {
          const e = await this.seedFileExists(),
            t = await this.twoFactorFileExists();
          return e || t;
        },
        get walletDir() {
          return e;
        },
        get restoreFromCurrentPhraseFlagFile() {
          return h.a.join(e, "..", "restore-from-current-phrase");
        },
        restoreFromCurrentPhraseFlagFileExistsSync() {
          return l.a.pathExistsSync(this.restoreFromCurrentPhraseFlagFile);
        },
      });
    var N = T,
      F = n(16);
    let D;
    const P = new Promise((e) => {
        D = e;
      }),
      I = Object(p.createStorageInternal)({
        file: N(h.a.join(Object(F.dataDir)(), O)).storageFile,
        getSecoPassphrase: () => P,
        header: { appName: "Exodus", appVersion: b.version },
      }),
      j = D;
    var L = I;
    console.log("run"),
      (() => {
        const e = (() => {
          let e;
          return new Proxy(
            {},
            {
              get: (t, n) =>
                function (...t) {
                  if ("init" === n) return (e = new y.a(...t));
                  if (!e) throw new Error("secoKeyVal not initialized");
                  if ("batchWithLock" === n)
                    return (async function () {
                      const [n, r] = t;
                      await l.a.outputFile(r, "");
                      try {
                        await e.batch(n);
                      } finally {
                        await l.a.remove(r);
                      }
                    })();
                  if (!e[n] || e[n] === {}[n])
                    throw new Error("invalid method", n);
                  return e[n](...t);
                },
            },
          );
        })();
        Object(r.createServer)("keyval-call", ["ui"], e);
      })(),
      Object(r.createServer)("storage-seco-ui", ["ui"], L),
      Object(r.createServer)(
        "storage-seco-network",
        ["network"],
        ((e) => Object(p.restrictToNamespaces)(I, e))([
          "fusion",
          "syncedBalances",
        ]),
      ),
      Object(r.createServer)("storage-seco-controller", ["ui"], {
        setSecoPassphrase: j,
      });
  },
  function (e, t, n) {
    "use strict";
    n.r(t),
      n.d(t, "dataDir", function () {
        return o;
      }),
      n.d(t, "desktopDir", function () {
        return i;
      });
    var r = n(3);
    function o() {
      return r.rpcListener.sendSync("app:path", "userData");
    }
    function i() {
      return r.rpcListener.sendSync("app:path", "desktop");
    }
  },
  function (e, t) {
    (e.exports.getLockFile = (e) => `${e}.lock`),
      (e.exports.getTmpFile = (e) => `${e}.tmp`);
  },
  function (e, t) {
    e.exports = function (e) {
      const t = (n = "") => {
        const r = (e) => {
          if (e.includes("!"))
            throw new Error(`keys cannot contain !; recieved ${e}`);
          return n + e;
        };
        return {
          get: async (t) => e.get(r(t)),
          batchGet: async (t) => e.batchGet(t.map((e) => r(e))),
          set: async (t, n) => e.set(r(t), n),
          batchSet: async (t) =>
            e.batchSet(
              Object.fromEntries(Object.entries(t).map(([e, t]) => [r(e), t])),
            ),
          delete: async (t) => e.delete(r(t)),
          batchDelete: async (t) => e.batchDelete(t.map((e) => r(e))),
          clear: async () => e.clear(n),
          namespace: (e) => {
            if (e.includes("!"))
              throw new Error(`prefixes cannot contain !; recieved ${e}`);
            return t(`${n}!${e}!`);
          },
        };
      };
      return t();
    };
  },
  function (e, t, n) {
    "use strict";
    const r = () => {
        const e = new Error("Delay aborted");
        return (e.name = "AbortError"), e;
      },
      o =
        ({ clearTimeout: e, setTimeout: t, willResolve: n }) =>
        (o, { value: i, signal: c } = {}) => {
          if (c && c.aborted) return Promise.reject(r());
          let s, a, u;
          const f = e || clearTimeout,
            l = () => {
              f(s), u(r());
            },
            d = new Promise((e, r) => {
              (a = () => {
                c && c.removeEventListener("abort", l), n ? e(i) : r(i);
              }),
                (u = r),
                (s = (t || setTimeout)(a, o));
            });
          return (
            c && c.addEventListener("abort", l, { once: !0 }),
            (d.clear = () => {
              f(s), (s = null), a();
            }),
            d
          );
        },
      i = (e) => {
        const t = o({ ...e, willResolve: !0 });
        return (
          (t.reject = o({ ...e, willResolve: !1 })),
          (t.range = (e, n, r) =>
            t(
              ((e, t) => Math.floor(Math.random() * (t - e + 1) + e))(e, n),
              r,
            )),
          t
        );
      },
      c = i();
    (c.createWithTimers = i), (e.exports = c), (e.exports.default = c);
  },
  function (e, t) {
    e.exports = function (e, { concurrency: t = 1 } = {}) {
      !(function (e) {
        if (!("number" == typeof e && e > 0) || (e !== 1 / 0 && e % 1 != 0))
          throw new TypeError(`Invalid concurrency value: ${e}`);
      })(t);
      let n = 0;
      const r = [];
      return async function (...o) {
        n += 1;
        try {
          return (
            n > t && (await new Promise((e) => r.push({ resolve: e }))),
            await e(...o)
          );
        } finally {
          (n -= 1), r.length > 0 && r.shift().resolve();
        }
      };
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(1),
      i = n(0),
      c = n(6),
      s = n(10).pathExists;
    e.exports = {
      outputFile: r(function (e, t, n, r) {
        "function" == typeof n && ((r = n), (n = "utf8"));
        const a = i.dirname(e);
        s(a, (i, s) =>
          i
            ? r(i)
            : s
            ? o.writeFile(e, t, n, r)
            : void c.mkdirs(a, (i) => {
                if (i) return r(i);
                o.writeFile(e, t, n, r);
              }),
        );
      }),
      outputFileSync: function (e, t, n) {
        const r = i.dirname(e);
        if (o.existsSync(r)) return o.writeFileSync.apply(o, arguments);
        c.mkdirsSync(r), o.writeFileSync.apply(o, arguments);
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1);
    e.exports = {
      symlinkType: function (e, t, n) {
        if (
          ((n = "function" == typeof t ? t : n),
          (t = "function" != typeof t && t))
        )
          return n(null, t);
        r.lstat(e, (e, r) => {
          if (e) return n(null, "file");
          (t = r && r.isDirectory() ? "dir" : "file"), n(null, t);
        });
      },
      symlinkTypeSync: function (e, t) {
        let n;
        if (t) return t;
        try {
          n = r.lstatSync(e);
        } catch (e) {
          return "file";
        }
        return n && n.isDirectory() ? "dir" : "file";
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0),
      o = n(1),
      i = n(10).pathExists;
    e.exports = {
      symlinkPaths: function (e, t, n) {
        if (r.isAbsolute(e))
          return o.lstat(e, (t, r) =>
            t
              ? ((t.message = t.message.replace("lstat", "ensureSymlink")),
                n(t))
              : n(null, { toCwd: e, toDst: e }),
          );
        {
          const c = r.dirname(t),
            s = r.join(c, e);
          return i(s, (t, i) =>
            t
              ? n(t)
              : i
              ? n(null, { toCwd: s, toDst: e })
              : o.lstat(e, (t, o) =>
                  t
                    ? ((t.message = t.message.replace(
                        "lstat",
                        "ensureSymlink",
                      )),
                      n(t))
                    : n(null, { toCwd: e, toDst: r.relative(c, e) }),
                ),
          );
        }
      },
      symlinkPathsSync: function (e, t) {
        let n;
        if (r.isAbsolute(e)) {
          if (!(n = o.existsSync(e)))
            throw new Error("absolute srcpath does not exist");
          return { toCwd: e, toDst: e };
        }
        {
          const i = r.dirname(t),
            c = r.join(i, e);
          if ((n = o.existsSync(c))) return { toCwd: c, toDst: e };
          if (!(n = o.existsSync(e)))
            throw new Error("relative srcpath does not exist");
          return { toCwd: e, toDst: r.relative(i, e) };
        }
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(6),
      s = c.mkdirs,
      a = c.mkdirsSync,
      u = n(81),
      f = u.symlinkPaths,
      l = u.symlinkPathsSync,
      d = n(80),
      y = d.symlinkType,
      p = d.symlinkTypeSync,
      m = n(10).pathExists;
    e.exports = {
      createSymlink: r(function (e, t, n, r) {
        (r = "function" == typeof n ? n : r),
          (n = "function" != typeof n && n),
          m(t, (c, a) =>
            c
              ? r(c)
              : a
              ? r(null)
              : void f(e, t, (c, a) => {
                  if (c) return r(c);
                  (e = a.toDst),
                    y(a.toCwd, n, (n, c) => {
                      if (n) return r(n);
                      const a = o.dirname(t);
                      m(a, (n, o) =>
                        n
                          ? r(n)
                          : o
                          ? i.symlink(e, t, c, r)
                          : void s(a, (n) => {
                              if (n) return r(n);
                              i.symlink(e, t, c, r);
                            }),
                      );
                    });
                }),
          );
      }),
      createSymlinkSync: function (e, t, n, r) {
        if (
          ((r = "function" == typeof n ? n : r),
          (n = "function" != typeof n && n),
          i.existsSync(t))
        )
          return;
        const c = l(e, t);
        (e = c.toDst), (n = p(c.toCwd, n));
        const s = o.dirname(t);
        return i.existsSync(s)
          ? i.symlinkSync(e, t, n)
          : (a(s), i.symlinkSync(e, t, n));
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(6),
      s = n(10).pathExists;
    e.exports = {
      createLink: r(function (e, t, n) {
        function r(e, t) {
          i.link(e, t, (e) => {
            if (e) return n(e);
            n(null);
          });
        }
        s(t, (a, u) =>
          a
            ? n(a)
            : u
            ? n(null)
            : void i.lstat(e, (i, a) => {
                if (i)
                  return (
                    (i.message = i.message.replace("lstat", "ensureLink")), n(i)
                  );
                const u = o.dirname(t);
                s(u, (o, i) =>
                  o
                    ? n(o)
                    : i
                    ? r(e, t)
                    : void c.mkdirs(u, (o) => {
                        if (o) return n(o);
                        r(e, t);
                      }),
                );
              }),
        );
      }),
      createLinkSync: function (e, t, n) {
        if (i.existsSync(t)) return;
        try {
          i.lstatSync(e);
        } catch (e) {
          throw ((e.message = e.message.replace("lstat", "ensureLink")), e);
        }
        const r = o.dirname(t);
        return i.existsSync(r)
          ? i.linkSync(e, t)
          : (c.mkdirsSync(r), i.linkSync(e, t));
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(6),
      s = n(10).pathExists;
    e.exports = {
      createFile: r(function (e, t) {
        function n() {
          i.writeFile(e, "", (e) => {
            if (e) return t(e);
            t();
          });
        }
        i.stat(e, (r, i) => {
          if (!r && i.isFile()) return t();
          const a = o.dirname(e);
          s(a, (e, r) =>
            e
              ? t(e)
              : r
              ? n()
              : void c.mkdirs(a, (e) => {
                  if (e) return t(e);
                  n();
                }),
          );
        });
      }),
      createFileSync: function (e) {
        let t;
        try {
          t = i.statSync(e);
        } catch (e) {}
        if (t && t.isFile()) return;
        const n = o.dirname(e);
        i.existsSync(n) || c.mkdirsSync(n), i.writeFileSync(e, "");
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(84),
      o = n(83),
      i = n(82);
    e.exports = {
      createFile: r.createFile,
      createFileSync: r.createFileSync,
      ensureFile: r.createFile,
      ensureFileSync: r.createFileSync,
      createLink: o.createLink,
      createLinkSync: o.createLinkSync,
      ensureLink: o.createLink,
      ensureLinkSync: o.createLinkSync,
      createSymlink: i.createSymlink,
      createSymlinkSync: i.createSymlinkSync,
      ensureSymlink: i.createSymlink,
      ensureSymlinkSync: i.createSymlinkSync,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(13),
      i = n(0),
      c = n(6),
      s = n(21),
      a = r(function (e, t) {
        (t = t || function () {}),
          o.readdir(e, (n, r) => {
            if (n) return c.mkdirs(e, t);
            (r = r.map((t) => i.join(e, t))),
              (function e() {
                const n = r.pop();
                if (!n) return t();
                s.remove(n, (n) => {
                  if (n) return t(n);
                  e();
                });
              })();
          });
      });
    function u(e) {
      let t;
      try {
        t = o.readdirSync(e);
      } catch (t) {
        return c.mkdirsSync(e);
      }
      t.forEach((t) => {
        (t = i.join(e, t)), s.removeSync(t);
      });
    }
    e.exports = { emptyDirSync: u, emptydirSync: u, emptyDir: a, emptydir: a };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(43).copySync,
      c = n(21).removeSync,
      s = n(6).mkdirsSync,
      a = n(42);
    function u(e, t, n) {
      return r.statSync(e).isDirectory()
        ? (function (e, t, n) {
            const r = { overwrite: !1 };
            n ? (c(t), o()) : o();
            function o() {
              return i(e, t, r), c(e);
            }
          })(e, t, n)
        : (function (e, t, n) {
            const o = a(65536),
              i = n ? "w" : "wx",
              c = r.openSync(e, "r"),
              s = r.fstatSync(c),
              u = r.openSync(t, i, s.mode);
            let f = 1,
              l = 0;
            for (; f > 0; )
              (f = r.readSync(c, o, 0, 65536, l)),
                r.writeSync(u, o, 0, f),
                (l += f);
            return r.closeSync(c), r.closeSync(u), r.unlinkSync(e);
          })(e, t, n);
    }
    e.exports = {
      moveSync: function e(t, n, i) {
        const a = (i = i || {}).overwrite || i.clobber || !1;
        if (((t = o.resolve(t)), (n = o.resolve(n)), t === n))
          return r.accessSync(t);
        if (
          (function (e, t) {
            try {
              return (
                r.statSync(e).isDirectory() &&
                e !== t &&
                t.indexOf(e) > -1 &&
                t.split(o.dirname(e) + o.sep)[1].split(o.sep)[0] ===
                  o.basename(e)
              );
            } catch (e) {
              return !1;
            }
          })(t, n)
        )
          throw new Error(`Cannot move '${t}' into itself '${n}'.`);
        s(o.dirname(n)),
          (function () {
            if (a)
              try {
                r.renameSync(t, n);
              } catch (r) {
                if (
                  "ENOTEMPTY" === r.code ||
                  "EEXIST" === r.code ||
                  "EPERM" === r.code
                )
                  return c(n), (i.overwrite = !1), e(t, n, i);
                if ("EXDEV" !== r.code) throw r;
                return u(t, n, a);
              }
            else
              try {
                r.linkSync(t, n), r.unlinkSync(t);
              } catch (e) {
                if (
                  "EXDEV" === e.code ||
                  "EISDIR" === e.code ||
                  "EPERM" === e.code ||
                  "ENOTSUP" === e.code
                )
                  return u(t, n, a);
                throw e;
              }
          })();
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(1),
      i = n(46),
      c = n(0),
      s = n(21).remove,
      a = n(6).mkdirs;
    function u(e, t, n, r) {
      o.stat(e, (i, c) => {
        if (i) return r(i);
        c.isDirectory()
          ? f(e, t, n, r)
          : (function (e, t, n, r) {
              const i = n ? "w" : "wx",
                c = o.createReadStream(e),
                s = o.createWriteStream(t, { flags: i });
              function a() {
                o.unlink(e, r);
              }
              c.on("error", (i) => {
                c.destroy(),
                  s.destroy(),
                  s.removeListener("close", a),
                  o.unlink(t, () => {
                    "EISDIR" === i.code || "EPERM" === i.code
                      ? f(e, t, n, r)
                      : r(i);
                  });
              }),
                s.on("error", (e) => {
                  c.destroy(), s.destroy(), s.removeListener("close", a), r(e);
                }),
                s.once("close", a),
                c.pipe(s);
            })(e, t, n, r);
      });
    }
    function f(e, t, n, r) {
      const o = { overwrite: !1 };
      function c() {
        i(e, t, o, (t) => {
          if (t) return r(t);
          s(e, r);
        });
      }
      n
        ? s(t, (e) => {
            if (e) return r(e);
            c();
          })
        : c();
    }
    e.exports = {
      move: r(function e(t, n, r, i) {
        "function" == typeof r && ((i = r), (r = {}));
        const f = r.overwrite || r.clobber || !1;
        !(function (e, t, n) {
          o.stat(e, (r, o) => {
            if (r) return n(r);
            if (o.isDirectory()) {
              const r = t.split(c.dirname(e) + c.sep)[1];
              if (r) {
                const o = r.split(c.sep)[0];
                return n(
                  null,
                  !!o && e !== t && t.indexOf(e) > -1 && o === c.basename(e),
                );
              }
              return n(null, !1);
            }
            return n(null, !1);
          });
        })(t, n, (l, d) =>
          l
            ? i(l)
            : d
            ? i(
                new Error(
                  `Cannot move '${t}' to a subdirectory of itself, '${n}'.`,
                ),
              )
            : void a(c.dirname(n), (a) => {
                if (a) return i(a);
                c.resolve(t) === c.resolve(n)
                  ? o.access(t, i)
                  : f
                  ? o.rename(t, n, (o) => {
                      if (!o) return i();
                      if ("ENOTEMPTY" !== o.code && "EEXIST" !== o.code) {
                        if ("EPERM" !== o.code)
                          return "EXDEV" !== o.code ? i(o) : void u(t, n, f, i);
                        setTimeout(() => {
                          s(n, (o) => {
                            if (o) return i(o);
                            (r.overwrite = !1), e(t, n, r, i);
                          });
                        }, 200);
                      } else
                        s(n, (o) => {
                          if (o) return i(o);
                          (r.overwrite = !1), e(t, n, r, i);
                        });
                    })
                  : o.link(t, n, (e) =>
                      e
                        ? "EXDEV" === e.code ||
                          "EISDIR" === e.code ||
                          "EPERM" === e.code ||
                          "ENOTSUP" === e.code
                          ? u(t, n, f, i)
                          : i(e)
                        : o.unlink(t, i),
                    );
              }),
        );
      }),
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(6),
      c = n(27);
    e.exports = function (e, t, n) {
      const s = o.dirname(e);
      r.existsSync(s) || i.mkdirsSync(s), c.writeJsonSync(e, t, n);
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0),
      o = n(6),
      i = n(10).pathExists,
      c = n(27);
    e.exports = function (e, t, n, s) {
      "function" == typeof n && ((s = n), (n = {}));
      const a = r.dirname(e);
      i(a, (r, i) =>
        r
          ? s(r)
          : i
          ? c.writeJson(e, t, n, s)
          : void o.mkdirs(a, (r) => {
              if (r) return s(r);
              c.writeJson(e, t, n, s);
            }),
      );
    };
  },
  function (e, t, n) {
    var r;
    try {
      r = n(1);
    } catch (e) {
      r = n(13);
    }
    function o(e, t) {
      var n,
        r = "\n";
      return (
        "object" == typeof t &&
          null !== t &&
          (t.spaces && (n = t.spaces), t.EOL && (r = t.EOL)),
        JSON.stringify(e, t ? t.replacer : null, n).replace(/\n/g, r) + r
      );
    }
    function i(e) {
      return (
        Buffer.isBuffer(e) && (e = e.toString("utf8")),
        (e = e.replace(/^\uFEFF/, ""))
      );
    }
    var c = {
      readFile: function (e, t, n) {
        null == n && ((n = t), (t = {})),
          "string" == typeof t && (t = { encoding: t });
        var o = (t = t || {}).fs || r,
          c = !0;
        "throws" in t && (c = t.throws),
          o.readFile(e, t, function (r, o) {
            if (r) return n(r);
            var s;
            o = i(o);
            try {
              s = JSON.parse(o, t ? t.reviver : null);
            } catch (t) {
              return c
                ? ((t.message = e + ": " + t.message), n(t))
                : n(null, null);
            }
            n(null, s);
          });
      },
      readFileSync: function (e, t) {
        "string" == typeof (t = t || {}) && (t = { encoding: t });
        var n = t.fs || r,
          o = !0;
        "throws" in t && (o = t.throws);
        try {
          var c = n.readFileSync(e, t);
          return (c = i(c)), JSON.parse(c, t.reviver);
        } catch (t) {
          if (o) throw ((t.message = e + ": " + t.message), t);
          return null;
        }
      },
      writeFile: function (e, t, n, i) {
        null == i && ((i = n), (n = {}));
        var c = (n = n || {}).fs || r,
          s = "";
        try {
          s = o(t, n);
        } catch (e) {
          return void (i && i(e, null));
        }
        c.writeFile(e, s, n, i);
      },
      writeFileSync: function (e, t, n) {
        var i = (n = n || {}).fs || r,
          c = o(t, n);
        return i.writeFileSync(e, c, n);
      },
    };
    e.exports = c;
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(27);
    (o.outputJson = r(n(90))),
      (o.outputJsonSync = n(89)),
      (o.outputJSON = o.outputJson),
      (o.outputJSONSync = o.outputJsonSync),
      (o.writeJSON = o.writeJson),
      (o.writeJSONSync = o.writeJsonSync),
      (o.readJSON = o.readJson),
      (o.readJSONSync = o.readJsonSync),
      (e.exports = o);
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(20),
      c = "win32" === process.platform;
    function s(e) {
      ["unlink", "chmod", "stat", "lstat", "rmdir", "readdir"].forEach((t) => {
        (e[t] = e[t] || r[t]), (e[(t += "Sync")] = e[t] || r[t]);
      }),
        (e.maxBusyTries = e.maxBusyTries || 3);
    }
    function a(e, t, n) {
      let r = 0;
      "function" == typeof t && ((n = t), (t = {})),
        i(e, "rimraf: missing path"),
        i.equal(typeof e, "string", "rimraf: path should be a string"),
        i.equal(typeof n, "function", "rimraf: callback function required"),
        i(t, "rimraf: invalid options argument provided"),
        i.equal(typeof t, "object", "rimraf: options should be object"),
        s(t),
        u(e, t, function o(i) {
          if (i) {
            if (
              ("EBUSY" === i.code ||
                "ENOTEMPTY" === i.code ||
                "EPERM" === i.code) &&
              r < t.maxBusyTries
            ) {
              return r++, setTimeout(() => u(e, t, o), 100 * r);
            }
            "ENOENT" === i.code && (i = null);
          }
          n(i);
        });
    }
    function u(e, t, n) {
      i(e),
        i(t),
        i("function" == typeof n),
        t.lstat(e, (r, o) =>
          r && "ENOENT" === r.code
            ? n(null)
            : r && "EPERM" === r.code && c
            ? f(e, t, r, n)
            : o && o.isDirectory()
            ? d(e, t, r, n)
            : void t.unlink(e, (r) => {
                if (r) {
                  if ("ENOENT" === r.code) return n(null);
                  if ("EPERM" === r.code)
                    return c ? f(e, t, r, n) : d(e, t, r, n);
                  if ("EISDIR" === r.code) return d(e, t, r, n);
                }
                return n(r);
              }),
        );
    }
    function f(e, t, n, r) {
      i(e),
        i(t),
        i("function" == typeof r),
        n && i(n instanceof Error),
        t.chmod(e, 438, (o) => {
          o
            ? r("ENOENT" === o.code ? null : n)
            : t.stat(e, (o, i) => {
                o
                  ? r("ENOENT" === o.code ? null : n)
                  : i.isDirectory()
                  ? d(e, t, n, r)
                  : t.unlink(e, r);
              });
        });
    }
    function l(e, t, n) {
      let r;
      i(e), i(t), n && i(n instanceof Error);
      try {
        t.chmodSync(e, 438);
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw n;
      }
      try {
        r = t.statSync(e);
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw n;
      }
      r.isDirectory() ? p(e, t, n) : t.unlinkSync(e);
    }
    function d(e, t, n, r) {
      i(e),
        i(t),
        n && i(n instanceof Error),
        i("function" == typeof r),
        t.rmdir(e, (c) => {
          !c ||
          ("ENOTEMPTY" !== c.code && "EEXIST" !== c.code && "EPERM" !== c.code)
            ? c && "ENOTDIR" === c.code
              ? r(n)
              : r(c)
            : (function (e, t, n) {
                i(e),
                  i(t),
                  i("function" == typeof n),
                  t.readdir(e, (r, i) => {
                    if (r) return n(r);
                    let c,
                      s = i.length;
                    if (0 === s) return t.rmdir(e, n);
                    i.forEach((r) => {
                      a(o.join(e, r), t, (r) => {
                        if (!c)
                          return r
                            ? n((c = r))
                            : void (0 == --s && t.rmdir(e, n));
                      });
                    });
                  });
              })(e, t, r);
        });
    }
    function y(e, t) {
      let n;
      s((t = t || {})),
        i(e, "rimraf: missing path"),
        i.equal(typeof e, "string", "rimraf: path should be a string"),
        i(t, "rimraf: missing options"),
        i.equal(typeof t, "object", "rimraf: options should be object");
      try {
        n = t.lstatSync(e);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        "EPERM" === n.code && c && l(e, t, n);
      }
      try {
        n && n.isDirectory() ? p(e, t, null) : t.unlinkSync(e);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        if ("EPERM" === n.code) return c ? l(e, t, n) : p(e, t, n);
        if ("EISDIR" !== n.code) throw n;
        p(e, t, n);
      }
    }
    function p(e, t, n) {
      i(e), i(t), n && i(n instanceof Error);
      try {
        t.rmdirSync(e);
      } catch (r) {
        if ("ENOTDIR" === r.code) throw n;
        if ("ENOTEMPTY" === r.code || "EEXIST" === r.code || "EPERM" === r.code)
          !(function (e, t) {
            i(e), i(t), t.readdirSync(e).forEach((n) => y(o.join(e, n), t));
            const n = c ? 100 : 1;
            let r = 0;
            for (;;) {
              let o = !0;
              try {
                const i = t.rmdirSync(e, t);
                return (o = !1), i;
              } finally {
                if (++r < n && o) continue;
              }
            }
          })(e, t);
        else if ("ENOENT" !== r.code) throw r;
      }
    }
    (e.exports = a), (a.sync = y);
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(6).mkdirsSync,
      c = n(44).utimesMillisSync,
      s = Symbol("notExist"),
      a = Symbol("existsReg");
    function u(e, t, n) {
      if (!n.filter || n.filter(e, t))
        return (function (e, t, n) {
          const i = (n.dereference ? r.statSync : r.lstatSync)(e);
          if (i.isDirectory())
            return (function (e, t, n, o) {
              const i = y(n);
              if (i === s) {
                if (p(t, n))
                  throw new Error(
                    `Cannot copy '${t}' to a subdirectory of itself, '${n}'.`,
                  );
                return (function (e, t, n, o) {
                  return (
                    r.mkdirSync(n, e.mode), r.chmodSync(n, e.mode), d(t, n, o)
                  );
                })(e, t, n, o);
              }
              if (i === a) {
                if (p(t, n))
                  throw new Error(
                    `Cannot copy '${t}' to a subdirectory of itself, '${n}'.`,
                  );
                return (function (e, t, n) {
                  if (!r.statSync(t).isDirectory())
                    throw new Error(
                      `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
                    );
                  return d(e, t, n);
                })(t, n, o);
              }
              if (t === i) return;
              return d(t, n, o);
            })(i, e, t, n);
          if (i.isFile() || i.isCharacterDevice() || i.isBlockDevice())
            return (function (e, t, n, r) {
              const o = y(n);
              if (o === s) return l(e, t, n, r);
              if (o === a) return f(e, t, n, r);
              if (t === o) return;
              return f(e, t, n, r);
            })(i, e, t, n);
          if (i.isSymbolicLink())
            return (function (e, t, n) {
              let i = r.readlinkSync(e);
              n.dereference && (i = o.resolve(process.cwd(), i));
              let c = y(t);
              if (c === s || c === a) return r.symlinkSync(i, t);
              if ((n.dereference && (c = o.resolve(process.cwd(), c)), c === i))
                return;
              if (r.statSync(t).isDirectory() && p(c, i))
                throw new Error(`Cannot overwrite '${c}' with '${i}'.`);
              return (function (e, t) {
                return r.unlinkSync(t), r.symlinkSync(e, t);
              })(i, t);
            })(e, t, n);
        })(e, t, n);
    }
    function f(e, t, n, o) {
      if (o.overwrite) return r.unlinkSync(n), l(e, t, n, o);
      if (o.errorOnExist) throw new Error(`'${n}' already exists`);
    }
    function l(e, t, o, i) {
      return "function" == typeof r.copyFileSync
        ? (r.copyFileSync(t, o),
          r.chmodSync(o, e.mode),
          i.preserveTimestamps ? c(o, e.atime, e.mtime) : void 0)
        : (function (e, t, o, i) {
            const c = n(42)(65536),
              s = r.openSync(t, "r"),
              a = r.openSync(o, "w", e.mode);
            let u = 1,
              f = 0;
            for (; u > 0; )
              (u = r.readSync(s, c, 0, 65536, f)),
                r.writeSync(a, c, 0, u),
                (f += u);
            i.preserveTimestamps && r.futimesSync(a, e.atime, e.mtime);
            r.closeSync(s), r.closeSync(a);
          })(e, t, o, i);
    }
    function d(e, t, n) {
      r.readdirSync(e).forEach((r) => {
        u(o.join(e, r), o.join(t, r), n);
      });
    }
    function y(e) {
      let t;
      try {
        t = r.readlinkSync(e);
      } catch (e) {
        if ("ENOENT" === e.code) return s;
        if ("EINVAL" === e.code || "UNKNOWN" === e.code) return a;
        throw e;
      }
      return t;
    }
    function p(e, t) {
      const n = t.split(o.dirname(e) + o.sep)[1];
      if (n) {
        const r = n.split(o.sep)[0];
        return !!r && e !== t && t.indexOf(e) > -1 && r === o.basename(e);
      }
      return !1;
    }
    e.exports = function (e, t, n) {
      if (
        ("function" == typeof n && (n = { filter: n }),
        ((n = n || {}).clobber = !("clobber" in n && !n.clobber)),
        (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
        n.preserveTimestamps &&
          "ia32" === process.arch &&
          console.warn(
            "fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269",
          ),
        (e = o.resolve(e)) === (t = o.resolve(t)))
      )
        throw new Error("Source and destination must not be the same.");
      if (n.filter && !n.filter(e, t)) return;
      const c = o.dirname(t);
      return r.existsSync(c) || i(c), u(e, t, n);
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(45).invalidWin32Path,
      c = parseInt("0777", 8);
    e.exports = function e(t, n, s) {
      (n && "object" == typeof n) || (n = { mode: n });
      let a = n.mode;
      const u = n.fs || r;
      if ("win32" === process.platform && i(t)) {
        const e = new Error(t + " contains invalid WIN32 path characters.");
        throw ((e.code = "EINVAL"), e);
      }
      void 0 === a && (a = c & ~process.umask()),
        s || (s = null),
        (t = o.resolve(t));
      try {
        u.mkdirSync(t, a), (s = s || t);
      } catch (r) {
        switch (r.code) {
          case "ENOENT":
            if (o.dirname(t) === t) throw r;
            (s = e(o.dirname(t), n, s)), e(t, n, s);
            break;
          default:
            let i;
            try {
              i = u.statSync(t);
            } catch (e) {
              throw r;
            }
            if (!i.isDirectory()) throw r;
        }
      }
      return s;
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(45).invalidWin32Path,
      c = parseInt("0777", 8);
    e.exports = function e(t, n, s, a) {
      if (
        ("function" == typeof n
          ? ((s = n), (n = {}))
          : (n && "object" == typeof n) || (n = { mode: n }),
        "win32" === process.platform && i(t))
      ) {
        const e = new Error(t + " contains invalid WIN32 path characters.");
        return (e.code = "EINVAL"), s(e);
      }
      let u = n.mode;
      const f = n.fs || r;
      void 0 === u && (u = c & ~process.umask()),
        a || (a = null),
        (s = s || function () {}),
        (t = o.resolve(t)),
        f.mkdir(t, u, (r) => {
          if (!r) return s(null, (a = a || t));
          switch (r.code) {
            case "ENOENT":
              if (o.dirname(t) === t) return s(r);
              e(o.dirname(t), n, (r, o) => {
                r ? s(r, o) : e(t, n, s, o);
              });
              break;
            default:
              f.stat(t, (e, t) => {
                e || !t.isDirectory() ? s(r, a) : s(null, a);
              });
          }
        });
    };
  },
  function (e, t, n) {
    const r = n(2).fromCallback;
    e.exports = { copy: r(n(46)) };
  },
  function (e, t, n) {
    "use strict";
    e.exports = function () {
      const e = [].slice.call(arguments).filter((e) => e),
        t = e.shift();
      return (
        e.forEach((e) => {
          Object.keys(e).forEach((n) => {
            t[n] = e[n];
          });
        }),
        t
      );
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(98),
      o = {};
    r(o, n(47)),
      r(o, n(97)),
      r(o, n(43)),
      r(o, n(6)),
      r(o, n(21)),
      r(o, n(92)),
      r(o, n(88)),
      r(o, n(87)),
      r(o, n(86)),
      r(o, n(85)),
      r(o, n(79)),
      r(o, n(10)),
      (e.exports = o);
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.read = t.write = void 0);
    var r =
      Object.assign ||
      function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n)
            Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
        return e;
      };
    t.write =
      ((o = m(function* (e, t, n = {}) {
        if (
          !(n = r({ overwrite: !1 }, n)).overwrite &&
          (yield a.default.pathExists(e))
        )
          throw new Error(`${e} exists. Set 'overwrite' to true.`);
        var o = h(t, n);
        const i = o.encryptedData,
          c = o.blobKey,
          s = o.metadata;
        return yield a.default.outputFile(e, i), { blobKey: c, metadata: s };
      })),
      function (e, t) {
        return o.apply(this, arguments);
      });
    var o;
    t.read =
      ((i = m(function* (e, t) {
        let n,
          r = yield a.default.readFile(e);
        try {
          n = w(r, t);
        } catch (t) {
          if (
            t.message.match(
              /seco checksum does not match; data may be corrupted/,
            )
          )
            throw new Error(
              `${e}: seco checksum does not match; file may be corrupted`,
            );
          throw t;
        }
        return n;
      })),
      function (e, t) {
        return i.apply(this, arguments);
      });
    var i;
    (t.encryptData = h), (t.decryptData = w);
    var c,
      s = n(99),
      a = (c = s) && c.__esModule ? c : { default: c },
      u = p(n(19)),
      f = p(n(58)),
      l = p(n(35)),
      d = p(n(33)),
      y = p(n(32));
    function p(e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (null != e)
        for (var n in e)
          Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
      return (t.default = e), t;
    }
    function m(e) {
      return function () {
        var t = e.apply(this, arguments);
        return new Promise(function (e, n) {
          return (function r(o, i) {
            try {
              var c = t[o](i),
                s = c.value;
            } catch (e) {
              return void n(e);
            }
            if (!c.done)
              return Promise.resolve(s).then(
                function (e) {
                  r("next", e);
                },
                function (e) {
                  r("throw", e);
                },
              );
            e(s);
          })("next");
        });
      };
    }
    function h(e, t = {}) {
      t.header || console.warn("seco-file: should pass options.header.");
      let n,
        r,
        o = l.create(t.header);
      if (t.passphrase)
        (n = u.randomBytes(32)),
          (r = d.create()),
          d.encryptBlobKey(r, t.passphrase, n);
      else {
        if (!t.metadata || !t.blobKey)
          throw new Error(
            "Must set either passphrase or (metadata and blobKey)",
          );
        (n = t.blobKey), (r = t.metadata);
      }
      e = Buffer.isBuffer(e) ? e : Buffer.from(e, "utf8");
      let i = f.encrypt(e, r, n).blob;
      const c = l.serialize(o),
        s = d.serialize(r);
      let a = {
        header: c,
        checksum: y.computeChecksum(s, i),
        metadata: s,
        blob: i,
      };
      return { encryptedData: y.encode(a), blobKey: n, metadata: r };
    }
    function w(e, t) {
      const n = y.decode(e),
        r = y.computeChecksum(n.metadata, n.blob);
      if (!n.checksum.equals(r))
        throw new Error("seco checksum does not match; data may be corrupted");
      let o = d.decode(n.metadata),
        i = d.decryptBlobKey(o, t),
        c = l.decode(n.header);
      return {
        data: f.decrypt(n.blob, o, i),
        blobKey: i,
        metadata: o,
        header: c,
      };
    }
  },
  function (e, t, n) {
    const r = n(4),
      { gzipSync: o, gunzipSync: i } = n(54),
      c = n(100),
      { checkContents: s } = n(32),
      a = n(55),
      u = n(78),
      f = n(77),
      l = n(76),
      { getLockFile: d, getTmpFile: y } = n(75),
      { expand: p, shrink: m } = a(32768);
    e.exports = {
      createStorageInternal: function ({
        file: e,
        getSecoPassphrase: t,
        header: n,
        expandTo32k: a = !1,
      }) {
        const l = d(e),
          h = y(e);
        let w, S, E;
        const v = (async function () {
          const r = await t();
          try {
            let t;
            ({ data: t, metadata: S, blobKey: E } = await c.read(e, r)),
              a && (t = m(t)),
              (w = JSON.parse(i(t).toString("utf8")));
          } catch (t) {
            if ("ENOENT" !== t.code) throw t;
            let i = o(Buffer.from(JSON.stringify({})));
            a && (i = p(i)),
              ({ metadata: S, blobKey: E } = await c.write(e, i, {
                passphrase: r,
                header: n,
              })),
              (w = {});
          }
        })();
        let b = !1;
        const g = u(
            async () => {
              if (b) {
                await f(100);
                try {
                  let t,
                    i = o(Buffer.from(JSON.stringify(w)));
                  a && (i = p(i)), (b = !1);
                  let u = 0;
                  do {
                    t && console.warn(`seco write invalid; retrying ${u}`),
                      await c.write(h, i, {
                        metadata: S,
                        blobKey: E,
                        header: n,
                        overwrite: !0,
                      }),
                      (t = await r.readFile(h));
                  } while (!s(t) && u++ < 5);
                  await r.move(h, e, { overwrite: !0 });
                } finally {
                  b || (await r.remove(l));
                }
              }
            },
            { concurrency: 1 },
          ),
          k = async () => {
            (b = !0), await r.outputFile(l, ""), await g();
          };
        return {
          get: async (e) => (await v, w[e]),
          batchGet: async (e) => (await v, e.map((e) => w[e])),
          set: async (e, t) => {
            if ((await v, void 0 === t))
              throw new Error(`cannot set ${e} to undefined`);
            (w[e] = t), await k();
          },
          batchSet: async (e) => {
            await v,
              Object.entries(e).forEach(([e, t]) => {
                if (void 0 === t)
                  throw new Error(`cannot set ${e} to undefined`);
                w[e] = t;
              }),
              await k();
          },
          delete: async (e) => {
            await v, delete w[e], await k();
          },
          batchDelete: async (e) => {
            await v, e.forEach((e) => delete w[e]), await k();
          },
          clear: async (e) => {
            await v,
              Object.keys(w).forEach((t) => {
                t.startsWith(e) && delete w[t];
              }),
              await k();
          },
        };
      },
      restrictToNamespaces: function (e, t) {
        const n = t.map(
            (e) => (
              Array.isArray(e) || (e = [e]),
              e
                .map((e) => {
                  if ("string" != typeof e || e.includes("!"))
                    throw new Error(`invalid namespace segment ${e}`);
                  return `!${e}!`;
                })
                .join("")
            ),
          ),
          r = (e) =>
            e && "string" == typeof e && n.some((t) => e.startsWith(t)),
          o = (e) => {
            if (r(e)) return e;
            throw new Error(
              `not permitted to access this namespace; tried to access key ${e}`,
            );
          };
        return {
          get: async (t) => e.get(o(t)),
          batchGet: async (t) => e.batchGet(t.map((e) => o(e))),
          set: async (t, n) => e.set(o(t), n),
          batchSet: async (t) =>
            e.batchSet(
              Object.fromEntries(Object.entries(t).map(([e, t]) => [o(e), t])),
            ),
          delete: async (t) => e.delete(o(t)),
          batchDelete: async (t) => e.batchDelete(t.map((e) => o(e))),
          clear: async (t) => {
            if (r(t)) return e.clear(t);
            throw new Error(
              `not permitted to access this namespace; tried to clear ${
                t || "root-level storage"
              }`,
            );
          },
        };
      },
      addNamespacing: l,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(30).copySync,
      c = n(22).removeSync,
      s = n(9).mkdirpSync,
      a = n(17);
    function u(e, t, n) {
      try {
        r.renameSync(e, t);
      } catch (r) {
        if ("EXDEV" !== r.code) throw r;
        return (function (e, t, n) {
          return i(e, t, { overwrite: n, errorOnExist: !0 }), c(e);
        })(e, t, n);
      }
    }
    e.exports = function (e, t, n) {
      const i = (n = n || {}).overwrite || n.clobber || !1,
        { srcStat: f, isChangingCase: l = !1 } = a.checkPathsSync(
          e,
          t,
          "move",
          n,
        );
      return (
        a.checkParentPathsSync(e, f, t, "move"),
        (function (e) {
          const t = o.dirname(e);
          return o.parse(t).root === t;
        })(t) || s(o.dirname(t)),
        (function (e, t, n, o) {
          if (o) return u(e, t, n);
          if (n) return c(t), u(e, t, n);
          if (r.existsSync(t)) throw new Error("dest already exists.");
          return u(e, t, n);
        })(e, t, i, l)
      );
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(30).copy,
      c = n(22).remove,
      s = n(9).mkdirp,
      a = n(14).pathExists,
      u = n(17);
    function f(e, t, n, r, o) {
      return r
        ? l(e, t, n, o)
        : n
        ? c(t, (r) => (r ? o(r) : l(e, t, n, o)))
        : void a(t, (r, i) =>
            r ? o(r) : i ? o(new Error("dest already exists.")) : l(e, t, n, o),
          );
    }
    function l(e, t, n, o) {
      r.rename(e, t, (r) =>
        r
          ? "EXDEV" !== r.code
            ? o(r)
            : (function (e, t, n, r) {
                i(e, t, { overwrite: n, errorOnExist: !0 }, (t) =>
                  t ? r(t) : c(e, r),
                );
              })(e, t, n, o)
          : o(),
      );
    }
    e.exports = function (e, t, n, r) {
      "function" == typeof n && ((r = n), (n = {}));
      const i = (n = n || {}).overwrite || n.clobber || !1;
      u.checkPaths(e, t, "move", n, (n, c) => {
        if (n) return r(n);
        const { srcStat: a, isChangingCase: l = !1 } = c;
        u.checkParentPaths(e, a, t, "move", (n) =>
          n
            ? r(n)
            : (function (e) {
                const t = o.dirname(e);
                return o.parse(t).root === t;
              })(t)
            ? f(e, t, i, l, r)
            : void s(o.dirname(t), (n) => (n ? r(n) : f(e, t, i, l, r))),
        );
      });
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromCallback;
    e.exports = { move: r(n(103)), moveSync: n(102) };
  },
  function (e, t, n) {
    "use strict";
    const { stringify: r } = n(29),
      { outputFileSync: o } = n(28);
    e.exports = function (e, t, n) {
      const i = r(t, n);
      o(e, i, n);
    };
  },
  function (e, t, n) {
    "use strict";
    const { stringify: r } = n(29),
      { outputFile: o } = n(28);
    e.exports = async function (e, t, n = {}) {
      const i = r(t, n);
      await o(e, i, n);
    };
  },
  function (e, t, n) {
    let r;
    try {
      r = n(1);
    } catch (e) {
      r = n(13);
    }
    const o = n(5),
      { stringify: i, stripBom: c } = n(29);
    const s = {
      readFile: o.fromPromise(async function (e, t = {}) {
        "string" == typeof t && (t = { encoding: t });
        const n = t.fs || r,
          i = !("throws" in t) || t.throws;
        let s,
          a = await o.fromCallback(n.readFile)(e, t);
        a = c(a);
        try {
          s = JSON.parse(a, t ? t.reviver : null);
        } catch (t) {
          if (i) throw ((t.message = `${e}: ${t.message}`), t);
          return null;
        }
        return s;
      }),
      readFileSync: function (e, t = {}) {
        "string" == typeof t && (t = { encoding: t });
        const n = t.fs || r,
          o = !("throws" in t) || t.throws;
        try {
          let r = n.readFileSync(e, t);
          return (r = c(r)), JSON.parse(r, t.reviver);
        } catch (t) {
          if (o) throw ((t.message = `${e}: ${t.message}`), t);
          return null;
        }
      },
      writeFile: o.fromPromise(async function (e, t, n = {}) {
        const c = n.fs || r,
          s = i(t, n);
        await o.fromCallback(c.writeFile)(e, s, n);
      }),
      writeFileSync: function (e, t, n = {}) {
        const o = n.fs || r,
          c = i(t, n);
        return o.writeFileSync(e, c, n);
      },
    };
    e.exports = s;
  },
  function (e, t, n) {
    "use strict";
    const r = n(107);
    e.exports = {
      readJson: r.readFile,
      readJsonSync: r.readFileSync,
      writeJson: r.writeFile,
      writeJsonSync: r.writeFileSync,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromPromise,
      o = n(108);
    (o.outputJson = r(n(106))),
      (o.outputJsonSync = n(105)),
      (o.outputJSON = o.outputJson),
      (o.outputJSONSync = o.outputJsonSync),
      (o.writeJSON = o.writeJson),
      (o.writeJSONSync = o.writeJsonSync),
      (o.readJSON = o.readJson),
      (o.readJSONSync = o.readJsonSync),
      (e.exports = o);
  },
  function (e, t, n) {
    "use strict";
    const r = n(1);
    e.exports = {
      symlinkType: function (e, t, n) {
        if (
          ((n = "function" == typeof t ? t : n),
          (t = "function" != typeof t && t))
        )
          return n(null, t);
        r.lstat(e, (e, r) => {
          if (e) return n(null, "file");
          (t = r && r.isDirectory() ? "dir" : "file"), n(null, t);
        });
      },
      symlinkTypeSync: function (e, t) {
        let n;
        if (t) return t;
        try {
          n = r.lstatSync(e);
        } catch {
          return "file";
        }
        return n && n.isDirectory() ? "dir" : "file";
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0),
      o = n(1),
      i = n(14).pathExists;
    e.exports = {
      symlinkPaths: function (e, t, n) {
        if (r.isAbsolute(e))
          return o.lstat(e, (t) =>
            t
              ? ((t.message = t.message.replace("lstat", "ensureSymlink")),
                n(t))
              : n(null, { toCwd: e, toDst: e }),
          );
        {
          const c = r.dirname(t),
            s = r.join(c, e);
          return i(s, (t, i) =>
            t
              ? n(t)
              : i
              ? n(null, { toCwd: s, toDst: e })
              : o.lstat(e, (t) =>
                  t
                    ? ((t.message = t.message.replace(
                        "lstat",
                        "ensureSymlink",
                      )),
                      n(t))
                    : n(null, { toCwd: e, toDst: r.relative(c, e) }),
                ),
          );
        }
      },
      symlinkPathsSync: function (e, t) {
        let n;
        if (r.isAbsolute(e)) {
          if (!(n = o.existsSync(e)))
            throw new Error("absolute srcpath does not exist");
          return { toCwd: e, toDst: e };
        }
        {
          const i = r.dirname(t),
            c = r.join(i, e);
          if ((n = o.existsSync(c))) return { toCwd: c, toDst: e };
          if (!(n = o.existsSync(e)))
            throw new Error("relative srcpath does not exist");
          return { toCwd: e, toDst: r.relative(i, e) };
        }
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromCallback,
      o = n(0),
      i = n(18),
      c = n(9),
      s = c.mkdirs,
      a = c.mkdirsSync,
      u = n(111),
      f = u.symlinkPaths,
      l = u.symlinkPathsSync,
      d = n(110),
      y = d.symlinkType,
      p = d.symlinkTypeSync,
      m = n(14).pathExists,
      { areIdentical: h } = n(17);
    function w(e, t, n, r) {
      f(e, t, (c, a) => {
        if (c) return r(c);
        (e = a.toDst),
          y(a.toCwd, n, (n, c) => {
            if (n) return r(n);
            const a = o.dirname(t);
            m(a, (n, o) =>
              n
                ? r(n)
                : o
                ? i.symlink(e, t, c, r)
                : void s(a, (n) => {
                    if (n) return r(n);
                    i.symlink(e, t, c, r);
                  }),
            );
          });
      });
    }
    e.exports = {
      createSymlink: r(function (e, t, n, r) {
        (r = "function" == typeof n ? n : r),
          (n = "function" != typeof n && n),
          i.lstat(t, (o, c) => {
            !o && c.isSymbolicLink()
              ? Promise.all([i.stat(e), i.stat(t)]).then(([o, i]) => {
                  if (h(o, i)) return r(null);
                  w(e, t, n, r);
                })
              : w(e, t, n, r);
          });
      }),
      createSymlinkSync: function (e, t, n) {
        let r;
        try {
          r = i.lstatSync(t);
        } catch {}
        if (r && r.isSymbolicLink()) {
          const n = i.statSync(e),
            r = i.statSync(t);
          if (h(n, r)) return;
        }
        const c = l(e, t);
        (e = c.toDst), (n = p(c.toCwd, n));
        const s = o.dirname(t);
        return i.existsSync(s)
          ? i.symlinkSync(e, t, n)
          : (a(s), i.symlinkSync(e, t, n));
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromCallback,
      o = n(0),
      i = n(1),
      c = n(9),
      s = n(14).pathExists,
      { areIdentical: a } = n(17);
    e.exports = {
      createLink: r(function (e, t, n) {
        function r(e, t) {
          i.link(e, t, (e) => {
            if (e) return n(e);
            n(null);
          });
        }
        i.lstat(t, (u, f) => {
          i.lstat(e, (i, u) => {
            if (i)
              return (
                (i.message = i.message.replace("lstat", "ensureLink")), n(i)
              );
            if (f && a(u, f)) return n(null);
            const l = o.dirname(t);
            s(l, (o, i) =>
              o
                ? n(o)
                : i
                ? r(e, t)
                : void c.mkdirs(l, (o) => {
                    if (o) return n(o);
                    r(e, t);
                  }),
            );
          });
        });
      }),
      createLinkSync: function (e, t) {
        let n;
        try {
          n = i.lstatSync(t);
        } catch {}
        try {
          const t = i.lstatSync(e);
          if (n && a(t, n)) return;
        } catch (e) {
          throw ((e.message = e.message.replace("lstat", "ensureLink")), e);
        }
        const r = o.dirname(t);
        return i.existsSync(r)
          ? i.linkSync(e, t)
          : (c.mkdirsSync(r), i.linkSync(e, t));
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromCallback,
      o = n(0),
      i = n(1),
      c = n(9);
    e.exports = {
      createFile: r(function (e, t) {
        function n() {
          i.writeFile(e, "", (e) => {
            if (e) return t(e);
            t();
          });
        }
        i.stat(e, (r, s) => {
          if (!r && s.isFile()) return t();
          const a = o.dirname(e);
          i.stat(a, (e, r) => {
            if (e)
              return "ENOENT" === e.code
                ? c.mkdirs(a, (e) => {
                    if (e) return t(e);
                    n();
                  })
                : t(e);
            r.isDirectory()
              ? n()
              : i.readdir(a, (e) => {
                  if (e) return t(e);
                });
          });
        });
      }),
      createFileSync: function (e) {
        let t;
        try {
          t = i.statSync(e);
        } catch {}
        if (t && t.isFile()) return;
        const n = o.dirname(e);
        try {
          i.statSync(n).isDirectory() || i.readdirSync(n);
        } catch (e) {
          if (!e || "ENOENT" !== e.code) throw e;
          c.mkdirsSync(n);
        }
        i.writeFileSync(e, "");
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const { createFile: r, createFileSync: o } = n(114),
      { createLink: i, createLinkSync: c } = n(113),
      { createSymlink: s, createSymlinkSync: a } = n(112);
    e.exports = {
      createFile: r,
      createFileSync: o,
      ensureFile: r,
      ensureFileSync: o,
      createLink: i,
      createLinkSync: c,
      ensureLink: i,
      ensureLinkSync: c,
      createSymlink: s,
      createSymlinkSync: a,
      ensureSymlink: s,
      ensureSymlinkSync: a,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(20),
      c = "win32" === process.platform;
    function s(e) {
      ["unlink", "chmod", "stat", "lstat", "rmdir", "readdir"].forEach((t) => {
        (e[t] = e[t] || r[t]), (e[(t += "Sync")] = e[t] || r[t]);
      }),
        (e.maxBusyTries = e.maxBusyTries || 3);
    }
    function a(e, t, n) {
      let r = 0;
      "function" == typeof t && ((n = t), (t = {})),
        i(e, "rimraf: missing path"),
        i.strictEqual(typeof e, "string", "rimraf: path should be a string"),
        i.strictEqual(
          typeof n,
          "function",
          "rimraf: callback function required",
        ),
        i(t, "rimraf: invalid options argument provided"),
        i.strictEqual(typeof t, "object", "rimraf: options should be object"),
        s(t),
        u(e, t, function o(i) {
          if (i) {
            if (
              ("EBUSY" === i.code ||
                "ENOTEMPTY" === i.code ||
                "EPERM" === i.code) &&
              r < t.maxBusyTries
            ) {
              return r++, setTimeout(() => u(e, t, o), 100 * r);
            }
            "ENOENT" === i.code && (i = null);
          }
          n(i);
        });
    }
    function u(e, t, n) {
      i(e),
        i(t),
        i("function" == typeof n),
        t.lstat(e, (r, o) =>
          r && "ENOENT" === r.code
            ? n(null)
            : r && "EPERM" === r.code && c
            ? f(e, t, r, n)
            : o && o.isDirectory()
            ? d(e, t, r, n)
            : void t.unlink(e, (r) => {
                if (r) {
                  if ("ENOENT" === r.code) return n(null);
                  if ("EPERM" === r.code)
                    return c ? f(e, t, r, n) : d(e, t, r, n);
                  if ("EISDIR" === r.code) return d(e, t, r, n);
                }
                return n(r);
              }),
        );
    }
    function f(e, t, n, r) {
      i(e),
        i(t),
        i("function" == typeof r),
        t.chmod(e, 438, (o) => {
          o
            ? r("ENOENT" === o.code ? null : n)
            : t.stat(e, (o, i) => {
                o
                  ? r("ENOENT" === o.code ? null : n)
                  : i.isDirectory()
                  ? d(e, t, n, r)
                  : t.unlink(e, r);
              });
        });
    }
    function l(e, t, n) {
      let r;
      i(e), i(t);
      try {
        t.chmodSync(e, 438);
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw n;
      }
      try {
        r = t.statSync(e);
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw n;
      }
      r.isDirectory() ? p(e, t, n) : t.unlinkSync(e);
    }
    function d(e, t, n, r) {
      i(e),
        i(t),
        i("function" == typeof r),
        t.rmdir(e, (c) => {
          !c ||
          ("ENOTEMPTY" !== c.code && "EEXIST" !== c.code && "EPERM" !== c.code)
            ? c && "ENOTDIR" === c.code
              ? r(n)
              : r(c)
            : (function (e, t, n) {
                i(e),
                  i(t),
                  i("function" == typeof n),
                  t.readdir(e, (r, i) => {
                    if (r) return n(r);
                    let c,
                      s = i.length;
                    if (0 === s) return t.rmdir(e, n);
                    i.forEach((r) => {
                      a(o.join(e, r), t, (r) => {
                        if (!c)
                          return r
                            ? n((c = r))
                            : void (0 == --s && t.rmdir(e, n));
                      });
                    });
                  });
              })(e, t, r);
        });
    }
    function y(e, t) {
      let n;
      s((t = t || {})),
        i(e, "rimraf: missing path"),
        i.strictEqual(typeof e, "string", "rimraf: path should be a string"),
        i(t, "rimraf: missing options"),
        i.strictEqual(typeof t, "object", "rimraf: options should be object");
      try {
        n = t.lstatSync(e);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        "EPERM" === n.code && c && l(e, t, n);
      }
      try {
        n && n.isDirectory() ? p(e, t, null) : t.unlinkSync(e);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        if ("EPERM" === n.code) return c ? l(e, t, n) : p(e, t, n);
        if ("EISDIR" !== n.code) throw n;
        p(e, t, n);
      }
    }
    function p(e, t, n) {
      i(e), i(t);
      try {
        t.rmdirSync(e);
      } catch (r) {
        if ("ENOTDIR" === r.code) throw n;
        if ("ENOTEMPTY" === r.code || "EEXIST" === r.code || "EPERM" === r.code)
          !(function (e, t) {
            if (
              (i(e),
              i(t),
              t.readdirSync(e).forEach((n) => y(o.join(e, n), t)),
              !c)
            ) {
              const n = t.rmdirSync(e, t);
              return n;
            }
            {
              const n = Date.now();
              do {
                try {
                  const n = t.rmdirSync(e, t);
                  return n;
                } catch {}
              } while (Date.now() - n < 500);
            }
          })(e, t);
        else if ("ENOENT" !== r.code) throw r;
      }
    }
    (e.exports = a), (a.sync = y);
  },
  function (e, t, n) {
    "use strict";
    const r = n(5).fromPromise,
      o = n(18),
      i = n(0),
      c = n(9),
      s = n(22),
      a = r(async function (e) {
        let t;
        try {
          t = await o.readdir(e);
        } catch {
          return c.mkdirs(e);
        }
        return Promise.all(t.map((t) => s.remove(i.join(e, t))));
      });
    function u(e) {
      let t;
      try {
        t = o.readdirSync(e);
      } catch {
        return c.mkdirsSync(e);
      }
      t.forEach((t) => {
        (t = i.join(e, t)), s.removeSync(t);
      });
    }
    e.exports = { emptyDirSync: u, emptydirSync: u, emptyDir: a, emptydir: a };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(9).mkdirsSync,
      c = n(48).utimesMillisSync,
      s = n(17);
    function a(e, t, n, i) {
      const c = (i.dereference ? r.statSync : r.lstatSync)(t);
      if (c.isDirectory())
        return (function (e, t, n, o, i) {
          return t
            ? l(n, o, i)
            : (function (e, t, n, o) {
                return r.mkdirSync(n), l(t, n, o), f(n, e);
              })(e.mode, n, o, i);
        })(c, e, t, n, i);
      if (c.isFile() || c.isCharacterDevice() || c.isBlockDevice())
        return (function (e, t, n, o, i) {
          return t
            ? (function (e, t, n, o) {
                if (o.overwrite) return r.unlinkSync(n), u(e, t, n, o);
                if (o.errorOnExist) throw new Error(`'${n}' already exists`);
              })(e, n, o, i)
            : u(e, n, o, i);
        })(c, e, t, n, i);
      if (c.isSymbolicLink())
        return (function (e, t, n, i) {
          let c = r.readlinkSync(t);
          i.dereference && (c = o.resolve(process.cwd(), c));
          if (e) {
            let e;
            try {
              e = r.readlinkSync(n);
            } catch (e) {
              if ("EINVAL" === e.code || "UNKNOWN" === e.code)
                return r.symlinkSync(c, n);
              throw e;
            }
            if (
              (i.dereference && (e = o.resolve(process.cwd(), e)),
              s.isSrcSubdir(c, e))
            )
              throw new Error(
                `Cannot copy '${c}' to a subdirectory of itself, '${e}'.`,
              );
            if (r.statSync(n).isDirectory() && s.isSrcSubdir(e, c))
              throw new Error(`Cannot overwrite '${e}' with '${c}'.`);
            return (function (e, t) {
              return r.unlinkSync(t), r.symlinkSync(e, t);
            })(c, n);
          }
          return r.symlinkSync(c, n);
        })(e, t, n, i);
      if (c.isSocket()) throw new Error(`Cannot copy a socket file: ${t}`);
      if (c.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${t}`);
      throw new Error(`Unknown file: ${t}`);
    }
    function u(e, t, n, o) {
      return (
        r.copyFileSync(t, n),
        o.preserveTimestamps &&
          (function (e, t, n) {
            (function (e) {
              return 0 == (128 & e);
            })(e) &&
              (function (e, t) {
                f(e, 128 | t);
              })(n, e);
            (function (e, t) {
              const n = r.statSync(e);
              c(t, n.atime, n.mtime);
            })(t, n);
          })(e.mode, t, n),
        f(n, e.mode)
      );
    }
    function f(e, t) {
      return r.chmodSync(e, t);
    }
    function l(e, t, n) {
      r.readdirSync(e).forEach((r) =>
        (function (e, t, n, r) {
          const i = o.join(t, e),
            c = o.join(n, e),
            { destStat: u } = s.checkPathsSync(i, c, "copy", r);
          return (function (e, t, n, r) {
            if (!r.filter || r.filter(t, n)) return a(e, t, n, r);
          })(u, i, c, r);
        })(r, e, t, n),
      );
    }
    e.exports = function (e, t, n) {
      "function" == typeof n && (n = { filter: n }),
        ((n = n || {}).clobber = !("clobber" in n && !n.clobber)),
        (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
        n.preserveTimestamps &&
          "ia32" === process.arch &&
          process.emitWarning(
            "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n\tsee https://github.com/jprichardson/node-fs-extra/issues/269",
            "Warning",
            "fs-extra-WARN0002",
          );
      const { srcStat: c, destStat: u } = s.checkPathsSync(e, t, "copy", n);
      return (
        s.checkParentPathsSync(e, c, t, "copy"),
        (function (e, t, n, c) {
          if (c.filter && !c.filter(t, n)) return;
          const s = o.dirname(n);
          return r.existsSync(s) || i(s), a(e, t, n, c);
        })(u, e, t, n)
      );
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0);
    e.exports.checkPath = function (e) {
      if ("win32" === process.platform) {
        if (/[<>:"|?*]/.test(e.replace(r.parse(e).root, ""))) {
          const t = new Error(`Path contains invalid characters: ${e}`);
          throw ((t.code = "EINVAL"), t);
        }
      }
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(18),
      { checkPath: o } = n(119),
      i = (e) => {
        return "number" == typeof e ? e : { ...{ mode: 511 }, ...e }.mode;
      };
    (e.exports.makeDir = async (e, t) => (
      o(e), r.mkdir(e, { mode: i(t), recursive: !0 })
    )),
      (e.exports.makeDirSync = (e, t) => (
        o(e), r.mkdirSync(e, { mode: i(t), recursive: !0 })
      ));
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(9).mkdirs,
      c = n(14).pathExists,
      s = n(48).utimesMillis,
      a = n(17);
    function u(e, t, n, r, s) {
      const a = o.dirname(n);
      c(a, (o, c) =>
        o
          ? s(o)
          : c
          ? l(e, t, n, r, s)
          : void i(a, (o) => (o ? s(o) : l(e, t, n, r, s))),
      );
    }
    function f(e, t, n, r, o, i) {
      Promise.resolve(o.filter(n, r)).then(
        (c) => (c ? e(t, n, r, o, i) : i()),
        (e) => i(e),
      );
    }
    function l(e, t, n, o, i) {
      (o.dereference ? r.stat : r.lstat)(t, (c, s) =>
        c
          ? i(c)
          : s.isDirectory()
          ? (function (e, t, n, o, i, c) {
              return t
                ? m(n, o, i, c)
                : (function (e, t, n, o, i) {
                    r.mkdir(n, (r) => {
                      if (r) return i(r);
                      m(t, n, o, (t) => (t ? i(t) : p(n, e, i)));
                    });
                  })(e.mode, n, o, i, c);
            })(s, e, t, n, o, i)
          : s.isFile() || s.isCharacterDevice() || s.isBlockDevice()
          ? (function (e, t, n, o, i, c) {
              return t
                ? (function (e, t, n, o, i) {
                    if (!o.overwrite)
                      return o.errorOnExist
                        ? i(new Error(`'${n}' already exists`))
                        : i();
                    r.unlink(n, (r) => (r ? i(r) : d(e, t, n, o, i)));
                  })(e, n, o, i, c)
                : d(e, n, o, i, c);
            })(s, e, t, n, o, i)
          : s.isSymbolicLink()
          ? w(e, t, n, o, i)
          : s.isSocket()
          ? i(new Error(`Cannot copy a socket file: ${t}`))
          : s.isFIFO()
          ? i(new Error(`Cannot copy a FIFO pipe: ${t}`))
          : i(new Error(`Unknown file: ${t}`)),
      );
    }
    function d(e, t, n, o, i) {
      r.copyFile(t, n, (r) =>
        r
          ? i(r)
          : o.preserveTimestamps
          ? (function (e, t, n, r) {
              if (
                (function (e) {
                  return 0 == (128 & e);
                })(e)
              )
                return (function (e, t, n) {
                  return p(e, 128 | t, n);
                })(n, e, (o) => (o ? r(o) : y(e, t, n, r)));
              return y(e, t, n, r);
            })(e.mode, t, n, i)
          : p(n, e.mode, i),
      );
    }
    function y(e, t, n, o) {
      !(function (e, t, n) {
        r.stat(e, (e, r) => (e ? n(e) : s(t, r.atime, r.mtime, n)));
      })(t, n, (t) => (t ? o(t) : p(n, e, o)));
    }
    function p(e, t, n) {
      return r.chmod(e, t, n);
    }
    function m(e, t, n, o) {
      r.readdir(e, (r, i) => (r ? o(r) : h(i, e, t, n, o)));
    }
    function h(e, t, n, r, i) {
      const c = e.pop();
      return c
        ? (function (e, t, n, r, i, c) {
            const s = o.join(n, t),
              u = o.join(r, t);
            a.checkPaths(s, u, "copy", i, (t, o) => {
              if (t) return c(t);
              const { destStat: a } = o;
              !(function (e, t, n, r, o) {
                r.filter ? f(l, e, t, n, r, o) : l(e, t, n, r, o);
              })(a, s, u, i, (t) => (t ? c(t) : h(e, n, r, i, c)));
            });
          })(e, c, t, n, r, i)
        : i();
    }
    function w(e, t, n, i, c) {
      r.readlink(t, (t, s) =>
        t
          ? c(t)
          : (i.dereference && (s = o.resolve(process.cwd(), s)),
            e
              ? void r.readlink(n, (t, u) =>
                  t
                    ? "EINVAL" === t.code || "UNKNOWN" === t.code
                      ? r.symlink(s, n, c)
                      : c(t)
                    : (i.dereference && (u = o.resolve(process.cwd(), u)),
                      a.isSrcSubdir(s, u)
                        ? c(
                            new Error(
                              `Cannot copy '${s}' to a subdirectory of itself, '${u}'.`,
                            ),
                          )
                        : e.isDirectory() && a.isSrcSubdir(u, s)
                        ? c(new Error(`Cannot overwrite '${u}' with '${s}'.`))
                        : (function (e, t, n) {
                            r.unlink(t, (o) => (o ? n(o) : r.symlink(e, t, n)));
                          })(s, n, c)),
                )
              : r.symlink(s, n, c)),
      );
    }
    e.exports = function (e, t, n, r) {
      "function" != typeof n || r
        ? "function" == typeof n && (n = { filter: n })
        : ((r = n), (n = {})),
        (r = r || function () {}),
        ((n = n || {}).clobber = !("clobber" in n && !n.clobber)),
        (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
        n.preserveTimestamps &&
          "ia32" === process.arch &&
          process.emitWarning(
            "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n\tsee https://github.com/jprichardson/node-fs-extra/issues/269",
            "Warning",
            "fs-extra-WARN0001",
          ),
        a.checkPaths(e, t, "copy", n, (o, i) => {
          if (o) return r(o);
          const { srcStat: c, destStat: s } = i;
          a.checkParentPaths(e, c, t, "copy", (o) =>
            o ? r(o) : n.filter ? f(u, s, e, t, n, r) : u(s, e, t, n, r),
          );
        });
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(1),
      i = n(0),
      c = n(7),
      s = n(11).pathExists;
    e.exports = {
      outputFile: r(function (e, t, n, r) {
        "function" == typeof n && ((r = n), (n = "utf8"));
        const a = i.dirname(e);
        s(a, (i, s) =>
          i
            ? r(i)
            : s
            ? o.writeFile(e, t, n, r)
            : void c.mkdirs(a, (i) => {
                if (i) return r(i);
                o.writeFile(e, t, n, r);
              }),
        );
      }),
      outputFileSync: function (e, t, n) {
        const r = i.dirname(e);
        if (o.existsSync(r)) return o.writeFileSync.apply(o, arguments);
        c.mkdirsSync(r), o.writeFileSync.apply(o, arguments);
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1);
    e.exports = {
      symlinkType: function (e, t, n) {
        if (
          ((n = "function" == typeof t ? t : n),
          (t = "function" != typeof t && t))
        )
          return n(null, t);
        r.lstat(e, (e, r) => {
          if (e) return n(null, "file");
          (t = r && r.isDirectory() ? "dir" : "file"), n(null, t);
        });
      },
      symlinkTypeSync: function (e, t) {
        let n;
        if (t) return t;
        try {
          n = r.lstatSync(e);
        } catch (e) {
          return "file";
        }
        return n && n.isDirectory() ? "dir" : "file";
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0),
      o = n(1),
      i = n(11).pathExists;
    e.exports = {
      symlinkPaths: function (e, t, n) {
        if (r.isAbsolute(e))
          return o.lstat(e, (t, r) =>
            t
              ? ((t.message = t.message.replace("lstat", "ensureSymlink")),
                n(t))
              : n(null, { toCwd: e, toDst: e }),
          );
        {
          const c = r.dirname(t),
            s = r.join(c, e);
          return i(s, (t, i) =>
            t
              ? n(t)
              : i
              ? n(null, { toCwd: s, toDst: e })
              : o.lstat(e, (t, o) =>
                  t
                    ? ((t.message = t.message.replace(
                        "lstat",
                        "ensureSymlink",
                      )),
                      n(t))
                    : n(null, { toCwd: e, toDst: r.relative(c, e) }),
                ),
          );
        }
      },
      symlinkPathsSync: function (e, t) {
        let n;
        if (r.isAbsolute(e)) {
          if (!(n = o.existsSync(e)))
            throw new Error("absolute srcpath does not exist");
          return { toCwd: e, toDst: e };
        }
        {
          const i = r.dirname(t),
            c = r.join(i, e);
          if ((n = o.existsSync(c))) return { toCwd: c, toDst: e };
          if (!(n = o.existsSync(e)))
            throw new Error("relative srcpath does not exist");
          return { toCwd: e, toDst: r.relative(i, e) };
        }
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(7),
      s = c.mkdirs,
      a = c.mkdirsSync,
      u = n(124),
      f = u.symlinkPaths,
      l = u.symlinkPathsSync,
      d = n(123),
      y = d.symlinkType,
      p = d.symlinkTypeSync,
      m = n(11).pathExists;
    e.exports = {
      createSymlink: r(function (e, t, n, r) {
        (r = "function" == typeof n ? n : r),
          (n = "function" != typeof n && n),
          m(t, (c, a) =>
            c
              ? r(c)
              : a
              ? r(null)
              : void f(e, t, (c, a) => {
                  if (c) return r(c);
                  (e = a.toDst),
                    y(a.toCwd, n, (n, c) => {
                      if (n) return r(n);
                      const a = o.dirname(t);
                      m(a, (n, o) =>
                        n
                          ? r(n)
                          : o
                          ? i.symlink(e, t, c, r)
                          : void s(a, (n) => {
                              if (n) return r(n);
                              i.symlink(e, t, c, r);
                            }),
                      );
                    });
                }),
          );
      }),
      createSymlinkSync: function (e, t, n, r) {
        if (
          ((r = "function" == typeof n ? n : r),
          (n = "function" != typeof n && n),
          i.existsSync(t))
        )
          return;
        const c = l(e, t);
        (e = c.toDst), (n = p(c.toCwd, n));
        const s = o.dirname(t);
        return i.existsSync(s)
          ? i.symlinkSync(e, t, n)
          : (a(s), i.symlinkSync(e, t, n));
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(7),
      s = n(11).pathExists;
    e.exports = {
      createLink: r(function (e, t, n) {
        function r(e, t) {
          i.link(e, t, (e) => {
            if (e) return n(e);
            n(null);
          });
        }
        s(t, (a, u) =>
          a
            ? n(a)
            : u
            ? n(null)
            : void i.lstat(e, (i, a) => {
                if (i)
                  return (
                    (i.message = i.message.replace("lstat", "ensureLink")), n(i)
                  );
                const u = o.dirname(t);
                s(u, (o, i) =>
                  o
                    ? n(o)
                    : i
                    ? r(e, t)
                    : void c.mkdirs(u, (o) => {
                        if (o) return n(o);
                        r(e, t);
                      }),
                );
              }),
        );
      }),
      createLinkSync: function (e, t, n) {
        if (i.existsSync(t)) return;
        try {
          i.lstatSync(e);
        } catch (e) {
          throw ((e.message = e.message.replace("lstat", "ensureLink")), e);
        }
        const r = o.dirname(t);
        return i.existsSync(r)
          ? i.linkSync(e, t)
          : (c.mkdirsSync(r), i.linkSync(e, t));
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(7),
      s = n(11).pathExists;
    e.exports = {
      createFile: r(function (e, t) {
        function n() {
          i.writeFile(e, "", (e) => {
            if (e) return t(e);
            t();
          });
        }
        s(e, (r, i) => {
          if (r) return t(r);
          if (i) return t();
          const a = o.dirname(e);
          s(a, (e, r) =>
            e
              ? t(e)
              : r
              ? n()
              : void c.mkdirs(a, (e) => {
                  if (e) return t(e);
                  n();
                }),
          );
        });
      }),
      createFileSync: function (e) {
        if (i.existsSync(e)) return;
        const t = o.dirname(e);
        i.existsSync(t) || c.mkdirsSync(t), i.writeFileSync(e, "");
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(127),
      o = n(126),
      i = n(125);
    e.exports = {
      createFile: r.createFile,
      createFileSync: r.createFileSync,
      ensureFile: r.createFile,
      ensureFileSync: r.createFileSync,
      createLink: o.createLink,
      createLinkSync: o.createLinkSync,
      ensureLink: o.createLink,
      ensureLinkSync: o.createLinkSync,
      createSymlink: i.createSymlink,
      createSymlinkSync: i.createSymlinkSync,
      ensureSymlink: i.createSymlink,
      ensureSymlinkSync: i.createSymlinkSync,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(13),
      i = n(0),
      c = n(7),
      s = n(23),
      a = r(function (e, t) {
        (t = t || function () {}),
          o.readdir(e, (n, r) => {
            if (n) return c.mkdirs(e, t);
            (r = r.map((t) => i.join(e, t))),
              (function e() {
                const n = r.pop();
                if (!n) return t();
                s.remove(n, (n) => {
                  if (n) return t(n);
                  e();
                });
              })();
          });
      });
    function u(e) {
      let t;
      try {
        t = o.readdirSync(e);
      } catch (t) {
        return c.mkdirsSync(e);
      }
      t.forEach((t) => {
        (t = i.join(e, t)), s.removeSync(t);
      });
    }
    e.exports = { emptyDirSync: u, emptydirSync: u, emptyDir: a, emptydir: a };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(50).copySync,
      c = n(23).removeSync,
      s = n(7).mkdirsSync,
      a = n(49);
    function u(e, t, n) {
      return r.statSync(e).isDirectory()
        ? (function (e, t, n) {
            const r = { overwrite: !1 };
            n ? (c(t), o()) : o();
            function o() {
              return i(e, t, r), c(e);
            }
          })(e, t, n)
        : (function (e, t, n) {
            const o = a(65536),
              i = n ? "w" : "wx",
              c = r.openSync(e, "r"),
              s = r.fstatSync(c),
              u = r.openSync(t, i, s.mode);
            let f = 1,
              l = 0;
            for (; f > 0; )
              (f = r.readSync(c, o, 0, 65536, l)),
                r.writeSync(u, o, 0, f),
                (l += f);
            return r.closeSync(c), r.closeSync(u), r.unlinkSync(e);
          })(e, t, n);
    }
    e.exports = {
      moveSync: function e(t, n, i) {
        const a = (i = i || {}).overwrite || i.clobber || !1;
        if (((t = o.resolve(t)), (n = o.resolve(n)), t === n))
          return r.accessSync(t);
        if (
          (function (e, t) {
            try {
              return (
                r.statSync(e).isDirectory() &&
                e !== t &&
                t.indexOf(e) > -1 &&
                t.split(o.dirname(e) + o.sep)[1].split(o.sep)[0] ===
                  o.basename(e)
              );
            } catch (e) {
              return !1;
            }
          })(t, n)
        )
          throw new Error(`Cannot move '${t}' into itself '${n}'.`);
        s(o.dirname(n)),
          (function () {
            if (a)
              try {
                r.renameSync(t, n);
              } catch (r) {
                if (
                  "ENOTEMPTY" === r.code ||
                  "EEXIST" === r.code ||
                  "EPERM" === r.code
                )
                  return c(n), (i.overwrite = !1), e(t, n, i);
                if ("EXDEV" !== r.code) throw r;
                return u(t, n, a);
              }
            else
              try {
                r.linkSync(t, n), r.unlinkSync(t);
              } catch (e) {
                if (
                  "EXDEV" === e.code ||
                  "EISDIR" === e.code ||
                  "EPERM" === e.code ||
                  "ENOTSUP" === e.code
                )
                  return u(t, n, a);
                throw e;
              }
          })();
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(1),
      i = n(52),
      c = n(0),
      s = n(23).remove,
      a = n(7).mkdirs;
    function u(e, t, n, r) {
      o.stat(e, (i, c) => {
        i
          ? r(i)
          : c.isDirectory()
          ? f(e, t, n, r)
          : (function (e, t, n, r) {
              const i = n ? "w" : "wx",
                c = o.createReadStream(e),
                s = o.createWriteStream(t, { flags: i });
              function a() {
                o.unlink(e, r);
              }
              c.on("error", (i) => {
                c.destroy(),
                  s.destroy(),
                  s.removeListener("close", a),
                  o.unlink(t, () => {
                    "EISDIR" === i.code || "EPERM" === i.code
                      ? f(e, t, n, r)
                      : r(i);
                  });
              }),
                s.on("error", (e) => {
                  c.destroy(), s.destroy(), s.removeListener("close", a), r(e);
                }),
                s.once("close", a),
                c.pipe(s);
            })(e, t, n, r);
      });
    }
    function f(e, t, n, r) {
      const o = { overwrite: !1 };
      function c() {
        i(e, t, o, (t) => {
          if (t) return r(t);
          s(e, r);
        });
      }
      n
        ? s(t, (e) => {
            if (e) return r(e);
            c();
          })
        : c();
    }
    e.exports = {
      move: r(function e(t, n, r, i) {
        "function" == typeof r && ((i = r), (r = {}));
        const f = !("mkdirp" in r) || r.mkdirp,
          l = r.overwrite || r.clobber || !1;
        function d() {
          c.resolve(t) === c.resolve(n)
            ? o.access(t, i)
            : l
            ? o.rename(t, n, (o) => {
                if (!o) return i();
                if ("ENOTEMPTY" !== o.code && "EEXIST" !== o.code) {
                  if ("EPERM" !== o.code)
                    return "EXDEV" !== o.code ? i(o) : void u(t, n, l, i);
                  setTimeout(() => {
                    s(n, (o) => {
                      if (o) return i(o);
                      (r.overwrite = !1), e(t, n, r, i);
                    });
                  }, 200);
                } else
                  s(n, (o) => {
                    if (o) return i(o);
                    (r.overwrite = !1), e(t, n, r, i);
                  });
              })
            : o.link(t, n, (e) => {
                if (e)
                  return "EXDEV" === e.code ||
                    "EISDIR" === e.code ||
                    "EPERM" === e.code ||
                    "ENOTSUP" === e.code
                    ? void u(t, n, l, i)
                    : void i(e);
                o.unlink(t, i);
              });
        }
        f
          ? a(c.dirname(n), (e) => {
              if (e) return i(e);
              d();
            })
          : d();
      }),
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0),
      o = n(7),
      i = n(11).pathExists,
      c = n(31);
    e.exports = function (e, t, n, s) {
      "function" == typeof n && ((s = n), (n = {}));
      const a = r.dirname(e);
      i(a, (r, i) =>
        r
          ? s(r)
          : i
          ? c.writeJson(e, t, n, s)
          : void o.mkdirs(a, (r) => {
              if (r) return s(r);
              c.writeJson(e, t, n, s);
            }),
      );
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(7),
      c = n(31);
    e.exports = function (e, t, n) {
      const s = o.dirname(e);
      r.existsSync(s) || i.mkdirsSync(s), c.writeJsonSync(e, t, n);
    };
  },
  function (e, t, n) {
    var r;
    try {
      r = n(1);
    } catch (e) {
      r = n(13);
    }
    function o(e) {
      return (
        Buffer.isBuffer(e) && (e = e.toString("utf8")),
        (e = e.replace(/^\uFEFF/, ""))
      );
    }
    var i = {
      spaces: null,
      readFile: function (e, t, n) {
        null == n && ((n = t), (t = {})),
          "string" == typeof t && (t = { encoding: t });
        var i = (t = t || {}).fs || r,
          c = !0;
        "passParsingErrors" in t
          ? (c = t.passParsingErrors)
          : "throws" in t && (c = t.throws),
          i.readFile(e, t, function (r, i) {
            if (r) return n(r);
            var s;
            i = o(i);
            try {
              s = JSON.parse(i, t ? t.reviver : null);
            } catch (t) {
              return c
                ? ((t.message = e + ": " + t.message), n(t))
                : n(null, null);
            }
            n(null, s);
          });
      },
      readFileSync: function (e, t) {
        "string" == typeof (t = t || {}) && (t = { encoding: t });
        var n = t.fs || r,
          i = !0;
        "passParsingErrors" in t
          ? (i = t.passParsingErrors)
          : "throws" in t && (i = t.throws);
        try {
          var c = n.readFileSync(e, t);
          return (c = o(c)), JSON.parse(c, t.reviver);
        } catch (t) {
          if (i) throw ((t.message = e + ": " + t.message), t);
          return null;
        }
      },
      writeFile: function (e, t, n, o) {
        null == o && ((o = n), (n = {}));
        var i = (n = n || {}).fs || r,
          c =
            "object" == typeof n && null !== n && "spaces" in n
              ? n.spaces
              : this.spaces,
          s = "";
        try {
          s = JSON.stringify(t, n ? n.replacer : null, c) + "\n";
        } catch (e) {
          if (o) return o(e, null);
        }
        i.writeFile(e, s, n, o);
      },
      writeFileSync: function (e, t, n) {
        var o = (n = n || {}).fs || r,
          i =
            "object" == typeof n && null !== n && "spaces" in n
              ? n.spaces
              : this.spaces,
          c = JSON.stringify(t, n.replacer, i) + "\n";
        return o.writeFileSync(e, c, n);
      },
    };
    e.exports = i;
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(31);
    (o.outputJsonSync = n(133)),
      (o.outputJson = r(n(132))),
      (o.outputJSONSync = o.outputJSONSync),
      (o.outputJSON = o.outputJson),
      (o.writeJSON = o.writeJson),
      (o.writeJSONSync = o.writeJsonSync),
      (o.readJSON = o.readJson),
      (o.readJSONSync = o.readJsonSync),
      (e.exports = o);
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(20),
      c = "win32" === process.platform;
    function s(e) {
      ["unlink", "chmod", "stat", "lstat", "rmdir", "readdir"].forEach((t) => {
        (e[t] = e[t] || r[t]), (e[(t += "Sync")] = e[t] || r[t]);
      }),
        (e.maxBusyTries = e.maxBusyTries || 3);
    }
    function a(e, t, n) {
      let r = 0;
      "function" == typeof t && ((n = t), (t = {})),
        i(e, "rimraf: missing path"),
        i.equal(typeof e, "string", "rimraf: path should be a string"),
        i.equal(typeof n, "function", "rimraf: callback function required"),
        i(t, "rimraf: invalid options argument provided"),
        i.equal(typeof t, "object", "rimraf: options should be object"),
        s(t),
        u(e, t, function o(i) {
          if (i) {
            if (
              c &&
              ("EBUSY" === i.code ||
                "ENOTEMPTY" === i.code ||
                "EPERM" === i.code) &&
              r < t.maxBusyTries
            ) {
              return r++, setTimeout(() => u(e, t, o), 100 * r);
            }
            "ENOENT" === i.code && (i = null);
          }
          n(i);
        });
    }
    function u(e, t, n) {
      i(e),
        i(t),
        i("function" == typeof n),
        t.lstat(e, (r, o) =>
          r && "ENOENT" === r.code
            ? n(null)
            : r && "EPERM" === r.code && c
            ? f(e, t, r, n)
            : o && o.isDirectory()
            ? d(e, t, r, n)
            : void t.unlink(e, (r) => {
                if (r) {
                  if ("ENOENT" === r.code) return n(null);
                  if ("EPERM" === r.code)
                    return c ? f(e, t, r, n) : d(e, t, r, n);
                  if ("EISDIR" === r.code) return d(e, t, r, n);
                }
                return n(r);
              }),
        );
    }
    function f(e, t, n, r) {
      i(e),
        i(t),
        i("function" == typeof r),
        n && i(n instanceof Error),
        t.chmod(e, 666, (o) => {
          o
            ? r("ENOENT" === o.code ? null : n)
            : t.stat(e, (o, i) => {
                o
                  ? r("ENOENT" === o.code ? null : n)
                  : i.isDirectory()
                  ? d(e, t, n, r)
                  : t.unlink(e, r);
              });
        });
    }
    function l(e, t, n) {
      let r;
      i(e), i(t), n && i(n instanceof Error);
      try {
        t.chmodSync(e, 666);
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw n;
      }
      try {
        r = t.statSync(e);
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw n;
      }
      r.isDirectory() ? p(e, t, n) : t.unlinkSync(e);
    }
    function d(e, t, n, r) {
      i(e),
        i(t),
        n && i(n instanceof Error),
        i("function" == typeof r),
        t.rmdir(e, (c) => {
          !c ||
          ("ENOTEMPTY" !== c.code && "EEXIST" !== c.code && "EPERM" !== c.code)
            ? c && "ENOTDIR" === c.code
              ? r(n)
              : r(c)
            : (function (e, t, n) {
                i(e),
                  i(t),
                  i("function" == typeof n),
                  t.readdir(e, (r, i) => {
                    if (r) return n(r);
                    let c,
                      s = i.length;
                    if (0 === s) return t.rmdir(e, n);
                    i.forEach((r) => {
                      a(o.join(e, r), t, (r) => {
                        if (!c)
                          return r
                            ? n((c = r))
                            : void (0 == --s && t.rmdir(e, n));
                      });
                    });
                  });
              })(e, t, r);
        });
    }
    function y(e, t) {
      let n;
      s((t = t || {})),
        i(e, "rimraf: missing path"),
        i.equal(typeof e, "string", "rimraf: path should be a string"),
        i(t, "rimraf: missing options"),
        i.equal(typeof t, "object", "rimraf: options should be object");
      try {
        n = t.lstatSync(e);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        "EPERM" === n.code && c && l(e, t, n);
      }
      try {
        n && n.isDirectory() ? p(e, t, null) : t.unlinkSync(e);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        if ("EPERM" === n.code) return c ? l(e, t, n) : p(e, t, n);
        if ("EISDIR" !== n.code) throw n;
        p(e, t, n);
      }
    }
    function p(e, t, n) {
      i(e), i(t), n && i(n instanceof Error);
      try {
        t.rmdirSync(e);
      } catch (r) {
        if ("ENOTDIR" === r.code) throw n;
        if ("ENOTEMPTY" === r.code || "EEXIST" === r.code || "EPERM" === r.code)
          !(function (e, t) {
            i(e),
              i(t),
              t.readdirSync(e).forEach((n) => y(o.join(e, n), t)),
              t.rmdirSync(e, t);
          })(e, t);
        else if ("ENOENT" !== r.code) throw r;
      }
    }
    (e.exports = a), (a.sync = y);
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = 65536,
      i = n(49)(o);
    e.exports = function (e, t, n) {
      const c = n.overwrite,
        s = n.errorOnExist,
        a = n.preserveTimestamps;
      if (r.existsSync(t)) {
        if (!c) {
          if (s) throw new Error(`${t} already exists`);
          return;
        }
        r.unlinkSync(t);
      }
      const u = r.openSync(e, "r"),
        f = r.fstatSync(u),
        l = r.openSync(t, "w", f.mode);
      let d = 1,
        y = 0;
      for (; d > 0; )
        (d = r.readSync(u, i, 0, o, y)), r.writeSync(l, i, 0, d), (y += d);
      a && r.futimesSync(l, f.atime, f.mtime), r.closeSync(u), r.closeSync(l);
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(137),
      c = n(7);
    e.exports = function e(t, n, s) {
      ("function" == typeof s || s instanceof RegExp) && (s = { filter: s }),
        ((s = s || {}).recursive = !!s.recursive),
        (s.clobber = !("clobber" in s && !s.clobber)),
        (s.overwrite = "overwrite" in s ? !!s.overwrite : s.clobber),
        (s.dereference = "dereference" in s && !!s.dereference),
        (s.preserveTimestamps =
          "preserveTimestamps" in s && !!s.preserveTimestamps),
        (s.filter =
          s.filter ||
          function () {
            return !0;
          }),
        s.preserveTimestamps &&
          "ia32" === process.arch &&
          console.warn(
            "fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269",
          );
      const a = s.recursive && !s.dereference ? r.lstatSync(t) : r.statSync(t),
        u = o.dirname(n),
        f = r.existsSync(u);
      let l = !1;
      if (
        (s.filter instanceof RegExp
          ? (console.warn(
              "Warning: fs-extra: Passing a RegExp filter is deprecated, use a function",
            ),
            (l = s.filter.test(t)))
          : "function" == typeof s.filter && (l = s.filter(t, n)),
        a.isFile() && l)
      )
        f || c.mkdirsSync(u),
          i(t, n, {
            overwrite: s.overwrite,
            errorOnExist: s.errorOnExist,
            preserveTimestamps: s.preserveTimestamps,
          });
      else if (a.isDirectory() && l)
        r.existsSync(n) || c.mkdirsSync(n),
          r.readdirSync(t).forEach((r) => {
            const i = s;
            (i.recursive = !0), e(o.join(t, r), o.join(n, r), i);
          });
      else if (s.recursive && a.isSymbolicLink() && l) {
        const e = r.readlinkSync(t);
        r.symlinkSync(e, n);
      }
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(51).invalidWin32Path,
      c = parseInt("0777", 8);
    e.exports = function e(t, n, s) {
      (n && "object" == typeof n) || (n = { mode: n });
      let a = n.mode;
      const u = n.fs || r;
      if ("win32" === process.platform && i(t)) {
        const e = new Error(t + " contains invalid WIN32 path characters.");
        throw ((e.code = "EINVAL"), e);
      }
      void 0 === a && (a = c & ~process.umask()),
        s || (s = null),
        (t = o.resolve(t));
      try {
        u.mkdirSync(t, a), (s = s || t);
      } catch (r) {
        switch (r.code) {
          case "ENOENT":
            if (o.dirname(t) === t) throw r;
            (s = e(o.dirname(t), n, s)), e(t, n, s);
            break;
          default:
            let i;
            try {
              i = u.statSync(t);
            } catch (e) {
              throw r;
            }
            if (!i.isDirectory()) throw r;
        }
      }
      return s;
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(51).invalidWin32Path,
      c = parseInt("0777", 8);
    e.exports = function e(t, n, s, a) {
      if (
        ("function" == typeof n
          ? ((s = n), (n = {}))
          : (n && "object" == typeof n) || (n = { mode: n }),
        "win32" === process.platform && i(t))
      ) {
        const e = new Error(t + " contains invalid WIN32 path characters.");
        return (e.code = "EINVAL"), s(e);
      }
      let u = n.mode;
      const f = n.fs || r;
      void 0 === u && (u = c & ~process.umask()),
        a || (a = null),
        (s = s || function () {}),
        (t = o.resolve(t)),
        f.mkdir(t, u, (r) => {
          if (!r) return s(null, (a = a || t));
          switch (r.code) {
            case "ENOENT":
              if (o.dirname(t) === t) return s(r);
              e(o.dirname(t), n, (r, o) => {
                r ? s(r, o) : e(t, n, s, o);
              });
              break;
            default:
              f.stat(t, (e, t) => {
                e || !t.isDirectory() ? s(r, a) : s(null, a);
              });
          }
        });
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(38),
      i = n(0);
    e.exports = {
      hasMillisRes: function (e) {
        let t = i.join(
          "millis-test" +
            Date.now().toString() +
            Math.random().toString().slice(2),
        );
        t = i.join(o.tmpdir(), t);
        const n = new Date(1435410243862);
        r.writeFile(
          t,
          "https://github.com/jprichardson/node-fs-extra/pull/141",
          (o) => {
            if (o) return e(o);
            r.open(t, "r+", (o, i) => {
              if (o) return e(o);
              r.futimes(i, n, n, (n) => {
                if (n) return e(n);
                r.close(i, (n) => {
                  if (n) return e(n);
                  r.stat(t, (t, n) => {
                    if (t) return e(t);
                    e(null, n.mtime > 1435410243e3);
                  });
                });
              });
            });
          },
        );
      },
      hasMillisResSync: function () {
        let e = i.join(
          "millis-test-sync" +
            Date.now().toString() +
            Math.random().toString().slice(2),
        );
        e = i.join(o.tmpdir(), e);
        const t = new Date(1435410243862);
        r.writeFileSync(
          e,
          "https://github.com/jprichardson/node-fs-extra/pull/141",
        );
        const n = r.openSync(e, "r+");
        return (
          r.futimesSync(n, t, t),
          r.closeSync(n),
          r.statSync(e).mtime > 1435410243e3
        );
      },
      timeRemoveMillis: function (e) {
        if ("number" == typeof e) return 1e3 * Math.floor(e / 1e3);
        if (e instanceof Date)
          return new Date(1e3 * Math.floor(e.getTime() / 1e3));
        throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
      },
      utimesMillis: function (e, t, n, o) {
        r.open(e, "r+", (e, i) => {
          if (e) return o(e);
          r.futimes(i, t, n, (e) => {
            r.close(i, (t) => {
              o && o(e || t);
            });
          });
        });
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(52),
      c = n(7),
      s = n(11).pathExists;
    e.exports = function (e, t, n, a) {
      "function" != typeof n || a
        ? ("function" == typeof n || n instanceof RegExp) && (n = { filter: n })
        : ((a = n), (n = {})),
        (a = a || function () {}),
        (n = n || {}).preserveTimestamps &&
          "ia32" === process.arch &&
          console.warn(
            "fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269",
          );
      const u = process.cwd();
      if (o.resolve(u, e) === o.resolve(u, t))
        return a(new Error("Source and destination must not be the same."));
      r.lstat(e, (r, u) => {
        if (r) return a(r);
        let f = null;
        if (u.isDirectory()) {
          const e = t.split(o.sep);
          e.pop(), (f = e.join(o.sep));
        } else f = o.dirname(t);
        s(f, (r, o) =>
          r
            ? a(r)
            : o
            ? i(e, t, n, a)
            : void c.mkdirs(f, (r) => {
                if (r) return a(r);
                i(e, t, n, a);
              }),
        );
      });
    };
  },
  function (e, t, n) {
    const r = n(2).fromCallback;
    e.exports = { copy: r(n(142)) };
  },
  function (e, t, n) {
    "use strict";
    e.exports = function () {
      const e = [].slice.call(arguments).filter((e) => e),
        t = e.shift();
      return (
        e.forEach((e) => {
          Object.keys(e).forEach((n) => {
            t[n] = e[n];
          });
        }),
        t
      );
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(144),
      o = {};
    r(o, n(53)),
      r(o, n(143)),
      r(o, n(50)),
      r(o, n(7)),
      r(o, n(23)),
      r(o, n(135)),
      r(o, n(131)),
      r(o, n(130)),
      r(o, n(129)),
      r(o, n(128)),
      r(o, n(122)),
      r(o, n(11)),
      (e.exports = o);
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.fromUInt32BE = function (e) {
        let t = Buffer.alloc(4);
        return t.writeUInt32BE(e), t;
      });
  },
  function (e, t, n) {
    "use strict";
    var r = n(15);
    e.exports = function (e, t) {
      if (!r.isAbstractCodec(e))
        throw new TypeError("itemType is invalid codec");
      if ("function" != typeof t)
        throw new TypeError("checkValue must be a function");
      return {
        encode: function n(r, o, i) {
          return t(r), (o = e.encode(r, o, i)), (n.bytes = e.encode.bytes), o;
        },
        decode: function n(r, o, i) {
          var c = e.decode(r, o, i);
          return t(c), (n.bytes = e.decode.bytes), c;
        },
        encodingLength: function (n) {
          return t(n), e.encodingLength(n);
        },
      };
    };
  },
  function (e, t, n) {
    "use strict";
    var r = n(56),
      o = n(15);
    e.exports = function (e, t) {
      if (!o.isAbstractCodec(e))
        throw new TypeError("lengthType is invalid codec");
      var n = r(e);
      return (
        t || (t = "utf8"),
        {
          encode: function e(r, o, i) {
            if ("string" != typeof r)
              throw new TypeError("value must be a string");
            return (
              (o = n.encode(new Buffer(r, t), o, i)),
              (e.bytes = n.encode.bytes),
              o
            );
          },
          decode: function e(r, o, i) {
            var c = n.decode(r, o, i);
            return (e.bytes = n.decode.bytes), c.toString(t);
          },
          encodingLength: function (e) {
            if ("string" != typeof e)
              throw new TypeError("value must be a string");
            return n.encodingLength(new Buffer(e, t));
          },
        }
      );
    };
  },
  function (e, t, n) {
    "use strict";
    var r = n(57);
    e.exports = function (e, t) {
      if ("number" != typeof e) throw new TypeError("length must be a number");
      var n = r(e);
      function o(e, r, o) {
        if ("string" != typeof e) throw new TypeError("value must be a string");
        return n.encode(new Buffer(e, t), r, o);
      }
      function i(e, r, o) {
        return n.decode(e, r, o).toString(t);
      }
      return (
        t || (t = "utf-8"),
        (o.bytes = i.bytes = e),
        { encode: o, decode: i, encodingLength: n.encodingLength }
      );
    };
  },
  function (e, t, n) {
    "use strict";
    var r = n(15);
    e.exports = function (e) {
      if (!Array.isArray(e))
        throw new TypeError("types must be an Array instance");
      function t(t) {
        return r.reduce(
          e,
          function (e, n, r) {
            return e + n.encodingLength(t[r]);
          },
          0,
        );
      }
      return (
        (e = e.map(function (e) {
          if (!r.isAbstractCodec(e))
            throw new TypeError("types Array has invalid codec");
          return e;
        })),
        {
          encode: function n(o, i, c) {
            if (!Array.isArray(o))
              throw new TypeError("value must be an Array instance");
            if (o.length !== e.length)
              throw new RangeError("value.length is out of bounds");
            return (
              i || (i = new Buffer(t(o))),
              c || (c = 0),
              (n.bytes =
                r.reduce(
                  e,
                  function (e, t, n) {
                    return t.encode(o[n], i, e), e + t.encode.bytes;
                  },
                  c,
                ) - c),
              i
            );
          },
          decode: function t(n, o, i) {
            o || (o = 0);
            var c = new Array(e.length);
            return (
              (t.bytes =
                r.reduce(
                  e,
                  function (e, t, r) {
                    return (c[r] = t.decode(n, e, i)), e + t.decode.bytes;
                  },
                  o,
                ) - o),
              c
            );
          },
          encodingLength: function (n) {
            if (!Array.isArray(n))
              throw new TypeError("value must be an Array instance");
            if (n.length !== e.length)
              throw new RangeError("value.length is out of bounds");
            return t(n);
          },
        }
      );
    };
  },
  function (e, t, n) {
    "use strict";
    var r = n(15);
    e.exports = function (e, t) {
      if (!r.isAbstractCodec(e))
        throw new TypeError("lengthType is invalid codec");
      if (!r.isAbstractCodec(t))
        throw new TypeError("itemType is invalid codec");
      function n(n) {
        return r.reduce(
          n,
          function (e, n) {
            return e + t.encodingLength(n);
          },
          e.encodingLength(n.length),
        );
      }
      return {
        encode: function o(i, c, s) {
          if (!Array.isArray(i))
            throw new TypeError("value must be an Array instance");
          return (
            c || (c = new Buffer(n(i))),
            s || (s = 0),
            e.encode(i.length, c, s),
            (o.bytes =
              r.reduce(
                i,
                function (e, n) {
                  return t.encode(n, c, e), e + t.encode.bytes;
                },
                e.encode.bytes + s,
              ) - s),
            c
          );
        },
        decode: function n(o, i, c) {
          i || (i = 0);
          var s = new Array(e.decode(o, i, c));
          return (
            (n.bytes =
              r.reduce(
                s,
                function (e, n, r) {
                  return (s[r] = t.decode(o, e, c)), e + t.decode.bytes;
                },
                e.decode.bytes + i,
              ) - i),
            s
          );
        },
        encodingLength: function (e) {
          if (!Array.isArray(e))
            throw new TypeError("value must be an Array instance");
          return n(e);
        },
      };
    };
  },
  function (e, t, n) {
    "use strict";
    var r = n(15);
    e.exports = function (e, t) {
      if ("number" != typeof e) throw new TypeError("length must be a number");
      if (!r.isAbstractCodec(t))
        throw new TypeError("itemType is invalid codec");
      function n(e) {
        return r.reduce(
          e,
          function (e, n) {
            return e + t.encodingLength(n);
          },
          0,
        );
      }
      return {
        encode: function o(i, c, s) {
          if (!Array.isArray(i))
            throw new TypeError("value must be an Array instance");
          if (i.length !== e)
            throw new RangeError("value.length is out of bounds");
          return (
            c || (c = new Buffer(n(i))),
            s || (s = 0),
            (o.bytes =
              r.reduce(
                i,
                function (e, n) {
                  return t.encode(n, c, e), e + t.encode.bytes;
                },
                s,
              ) - s),
            c
          );
        },
        decode: function n(o, i, c) {
          i || (i = 0);
          var s = new Array(e);
          return (
            (n.bytes =
              r.reduce(
                s,
                function (e, n, r) {
                  return (s[r] = t.decode(o, e, c)), e + t.decode.bytes;
                },
                i,
              ) - i),
            s
          );
        },
        encodingLength: function (t) {
          if (!Array.isArray(t))
            throw new TypeError("value must be an Array instance");
          if (t.length !== e)
            throw new RangeError("value.length is out of bounds");
          return n(t);
        },
      };
    };
  },
  function (e, t) {
    var n = {},
      r = 4294967295,
      o = 9007199254740991;
    function i(e) {
      return (e = ~e) < 0 && (e = 2147483648 + (2147483647 & e)), e;
    }
    function c(e) {
      console.assert(e > -1 && e <= o, "number out of range"),
        console.assert(Math.floor(e) === e, "number must be an integer");
      var t = 0,
        n = 4294967295 & e,
        i = n < 0 ? 2147483648 + (2147483647 & e) : n;
      return e > r && (t = (e - i) / (r + 1)), [t, i];
    }
    function s(e) {
      if (e > -1) return c(e);
      var t = c(-e),
        n = i(t[0]),
        o = i(t[1]);
      return o === r ? ((n += 1), (o = 0)) : (o += 1), [n, o];
    }
    function a(e, t, n) {
      return n && 0 != (2147483648 & e)
        ? ((e = i(e)),
          (t = i(t)),
          console.assert(e < 2097152, "number too small"),
          -(e * (r + 1) + t + 1))
        : (console.assert(e < 2097152, "number too large"), e * (r + 1) + t);
    }
    (n.readInt64BE = function (e, t) {
      return (t = t || 0), a(e.readUInt32BE(t), e.readUInt32BE(t + 4), !0);
    }),
      (n.readInt64LE = function (e, t) {
        t = t || 0;
        var n = e.readUInt32LE(t);
        return a(e.readUInt32LE(t + 4), n, !0);
      }),
      (n.readUInt64BE = function (e, t) {
        return (t = t || 0), a(e.readUInt32BE(t), e.readUInt32BE(t + 4), !1);
      }),
      (n.readUInt64LE = function (e, t) {
        t = t || 0;
        var n = e.readUInt32LE(t);
        return a(e.readUInt32LE(t + 4), n, !1);
      }),
      (n.writeInt64BE = function (e, t, n) {
        n = n || 0;
        var r = s(e);
        t.writeUInt32BE(r[0], n), t.writeUInt32BE(r[1], n + 4);
      }),
      (n.writeInt64LE = function (e, t, n) {
        n = n || 0;
        var r = s(e);
        t.writeUInt32LE(r[1], n), t.writeUInt32LE(r[0], n + 4);
      }),
      (n.writeUInt64BE = function (e, t, n) {
        n = n || 0;
        var r = c(e);
        t.writeUInt32BE(r[0], n), t.writeUInt32BE(r[1], n + 4);
      }),
      (n.writeUInt64LE = function (e, t, n) {
        n = n || 0;
        var r = c(e);
        t.writeUInt32LE(r[1], n), t.writeUInt32LE(r[0], n + 4);
      }),
      (e.exports = n);
  },
  function (e, t, n) {
    "use strict";
    var r = n(153);
    function o(e, t) {
      var n = Buffer.prototype["read" + e],
        r = Buffer.prototype["write" + e];
      function o(e, n, o) {
        return n || (n = new Buffer(t)), o || (o = 0), r.call(n, e, o), n;
      }
      function i(e, t, r) {
        return t || (t = 0), r ? n.call(e.slice(t, r), 0) : n.call(e, t);
      }
      return (
        (o.bytes = i.bytes = t),
        {
          encode: o,
          decode: i,
          encodingLength: function () {
            return t;
          },
        }
      );
    }
    function i(e, t) {
      function n(e, n, r) {
        return n || (n = new Buffer(8)), r || (r = 0), t(e, n, r), n;
      }
      function r(t, n, r) {
        return n || (n = 0), r ? e(t.slice(n, r), 0) : e(t, n);
      }
      return (
        (n.bytes = r.bytes = 8),
        {
          encode: n,
          decode: r,
          encodingLength: function () {
            return 8;
          },
        }
      );
    }
    (t.Byte = o("UInt8", 1)),
      (t.Int8 = o("Int8", 1)),
      (t.UInt8 = o("UInt8", 1)),
      (t.Int16BE = o("Int16BE", 2)),
      (t.Int16LE = o("Int16LE", 2)),
      (t.UInt16BE = o("UInt16BE", 2)),
      (t.UInt16LE = o("UInt16LE", 2)),
      (t.Int32BE = o("Int32BE", 4)),
      (t.Int32LE = o("Int32LE", 4)),
      (t.UInt32BE = o("UInt32BE", 4)),
      (t.UInt32LE = o("UInt32LE", 4)),
      (t.Int64BE = i(r.readInt64BE, r.writeInt64BE)),
      (t.Int64LE = i(r.readInt64LE, r.writeInt64LE)),
      (t.UInt64BE = i(r.readUInt64BE, r.writeUInt64BE)),
      (t.UInt64LE = i(r.readUInt64LE, r.writeUInt64LE)),
      (t.FloatBE = o("FloatBE", 4)),
      (t.FloatLE = o("FloatLE", 4)),
      (t.DoubleBE = o("DoubleBE", 8)),
      (t.DoubleLE = o("DoubleLE", 8));
  },
  function (e, t, n) {
    "use strict";
    var r = n(15);
    e.exports = function (e) {
      if (!Array.isArray(e))
        throw new TypeError("items must be an Array instance");
      function t(t) {
        return r.reduce(
          e,
          function (e, n) {
            return e + n.type.encodingLength(t[n.name]);
          },
          0,
        );
      }
      return (
        (e = e.map(function (e) {
          if (
            (Array.isArray(e) && (e = { name: e[0], type: e[1] }),
            !e || "string" != typeof e.name)
          )
            throw new TypeError('item missing "name" property');
          if (!r.isAbstractCodec(e.type))
            throw new TypeError('item "' + e.name + '" has invalid codec');
          return { name: e.name, type: e.type };
        })),
        {
          encode: function n(o, i, c) {
            if ("object" != typeof o || null === o)
              throw new TypeError("expected value as object, got " + o);
            return (
              i || (i = new Buffer(t(o))),
              c || (c = 0),
              (n.bytes =
                r.reduce(
                  e,
                  function (e, t) {
                    return (
                      t.type.encode(o[t.name], i, e), e + t.type.encode.bytes
                    );
                  },
                  c,
                ) - c),
              i
            );
          },
          decode: function t(n, o, i) {
            o || (o = 0);
            var c = {};
            return (
              (t.bytes =
                r.reduce(
                  e,
                  function (e, t) {
                    return (
                      (c[t.name] = t.type.decode(n, e, i)),
                      e + t.type.decode.bytes
                    );
                  },
                  o,
                ) - o),
              c
            );
          },
          encodingLength: t,
        }
      );
    };
  },
  function (e, t, n) {
    var r = n(19),
      o = 2147483647;
    function i(e, t, n, r, o) {
      if (Buffer.isBuffer(e) && Buffer.isBuffer(n)) e.copy(n, r, t, t + o);
      else for (; o--; ) n[r++] = e[t++];
    }
    e.exports = function (e, t, n, c, s, a, u) {
      if (0 === n || 0 != (n & (n - 1)))
        throw Error("N must be > 0 and a power of 2");
      if (n > o / 128 / c) throw Error("Parameter N is too large");
      if (c > o / 128 / s) throw Error("Parameter r is too large");
      var f,
        l = new Buffer(256 * c),
        d = new Buffer(128 * c * n),
        y = new Int32Array(16),
        p = new Int32Array(16),
        m = new Buffer(64),
        h = r.pbkdf2Sync(e, t, 1, 128 * s * c, "sha256");
      if (u) {
        var w = s * n * 2,
          S = 0;
        f = function () {
          ++S % 1e3 == 0 && u({ current: S, total: w, percent: (S / w) * 100 });
        };
      }
      for (var E = 0; E < s; E++) v(h, 128 * E * c, c, n, d, l);
      return r.pbkdf2Sync(e, h, 1, a, "sha256");
      function v(e, t, n, r, o, i) {
        var c,
          s = 128 * n;
        for (e.copy(i, 0, t, t + s), c = 0; c < r; c++)
          i.copy(o, c * s, 0, 0 + s), b(i, 0, s, n), f && f();
        for (c = 0; c < r; c++) {
          var a = 0 + 64 * (2 * n - 1);
          x(o, (i.readUInt32LE(a) & (r - 1)) * s, i, 0, s),
            b(i, 0, s, n),
            f && f();
        }
        i.copy(e, t, 0, 0 + s);
      }
      function b(e, t, n, r) {
        var o;
        for (i(e, t + 64 * (2 * r - 1), m, 0, 64), o = 0; o < 2 * r; o++)
          x(e, 64 * o, m, 0, 64), k(m), i(m, 0, e, n + 64 * o, 64);
        for (o = 0; o < r; o++) i(e, n + 2 * o * 64, e, t + 64 * o, 64);
        for (o = 0; o < r; o++)
          i(e, n + 64 * (2 * o + 1), e, t + 64 * (o + r), 64);
      }
      function g(e, t) {
        return (e << t) | (e >>> (32 - t));
      }
      function k(e) {
        var t;
        for (t = 0; t < 16; t++)
          (y[t] = (255 & e[4 * t + 0]) << 0),
            (y[t] |= (255 & e[4 * t + 1]) << 8),
            (y[t] |= (255 & e[4 * t + 2]) << 16),
            (y[t] |= (255 & e[4 * t + 3]) << 24);
        for (i(y, 0, p, 0, 16), t = 8; t > 0; t -= 2)
          (p[4] ^= g(p[0] + p[12], 7)),
            (p[8] ^= g(p[4] + p[0], 9)),
            (p[12] ^= g(p[8] + p[4], 13)),
            (p[0] ^= g(p[12] + p[8], 18)),
            (p[9] ^= g(p[5] + p[1], 7)),
            (p[13] ^= g(p[9] + p[5], 9)),
            (p[1] ^= g(p[13] + p[9], 13)),
            (p[5] ^= g(p[1] + p[13], 18)),
            (p[14] ^= g(p[10] + p[6], 7)),
            (p[2] ^= g(p[14] + p[10], 9)),
            (p[6] ^= g(p[2] + p[14], 13)),
            (p[10] ^= g(p[6] + p[2], 18)),
            (p[3] ^= g(p[15] + p[11], 7)),
            (p[7] ^= g(p[3] + p[15], 9)),
            (p[11] ^= g(p[7] + p[3], 13)),
            (p[15] ^= g(p[11] + p[7], 18)),
            (p[1] ^= g(p[0] + p[3], 7)),
            (p[2] ^= g(p[1] + p[0], 9)),
            (p[3] ^= g(p[2] + p[1], 13)),
            (p[0] ^= g(p[3] + p[2], 18)),
            (p[6] ^= g(p[5] + p[4], 7)),
            (p[7] ^= g(p[6] + p[5], 9)),
            (p[4] ^= g(p[7] + p[6], 13)),
            (p[5] ^= g(p[4] + p[7], 18)),
            (p[11] ^= g(p[10] + p[9], 7)),
            (p[8] ^= g(p[11] + p[10], 9)),
            (p[9] ^= g(p[8] + p[11], 13)),
            (p[10] ^= g(p[9] + p[8], 18)),
            (p[12] ^= g(p[15] + p[14], 7)),
            (p[13] ^= g(p[12] + p[15], 9)),
            (p[14] ^= g(p[13] + p[12], 13)),
            (p[15] ^= g(p[14] + p[13], 18));
        for (t = 0; t < 16; ++t) y[t] = p[t] + y[t];
        for (t = 0; t < 16; t++) {
          var n = 4 * t;
          (e[n + 0] = (y[t] >> 0) & 255),
            (e[n + 1] = (y[t] >> 8) & 255),
            (e[n + 2] = (y[t] >> 16) & 255),
            (e[n + 3] = (y[t] >> 24) & 255);
        }
      }
      function x(e, t, n, r, o) {
        for (var i = 0; i < o; i++) n[r + i] ^= e[t + i];
      }
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(1),
      i = n(0),
      c = n(8),
      s = n(12).pathExists;
    e.exports = {
      outputFile: r(function (e, t, n, r) {
        "function" == typeof n && ((r = n), (n = "utf8"));
        const a = i.dirname(e);
        s(a, (i, s) =>
          i
            ? r(i)
            : s
            ? o.writeFile(e, t, n, r)
            : void c.mkdirs(a, (i) => {
                if (i) return r(i);
                o.writeFile(e, t, n, r);
              }),
        );
      }),
      outputFileSync: function (e, t, n) {
        const r = i.dirname(e);
        if (o.existsSync(r)) return o.writeFileSync.apply(o, arguments);
        c.mkdirsSync(r), o.writeFileSync.apply(o, arguments);
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1);
    e.exports = {
      symlinkType: function (e, t, n) {
        if (
          ((n = "function" == typeof t ? t : n),
          (t = "function" != typeof t && t))
        )
          return n(null, t);
        r.lstat(e, (e, r) => {
          if (e) return n(null, "file");
          (t = r && r.isDirectory() ? "dir" : "file"), n(null, t);
        });
      },
      symlinkTypeSync: function (e, t) {
        let n;
        if (t) return t;
        try {
          n = r.lstatSync(e);
        } catch (e) {
          return "file";
        }
        return n && n.isDirectory() ? "dir" : "file";
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0),
      o = n(1),
      i = n(12).pathExists;
    e.exports = {
      symlinkPaths: function (e, t, n) {
        if (r.isAbsolute(e))
          return o.lstat(e, (t, r) =>
            t
              ? ((t.message = t.message.replace("lstat", "ensureSymlink")),
                n(t))
              : n(null, { toCwd: e, toDst: e }),
          );
        {
          const c = r.dirname(t),
            s = r.join(c, e);
          return i(s, (t, i) =>
            t
              ? n(t)
              : i
              ? n(null, { toCwd: s, toDst: e })
              : o.lstat(e, (t, o) =>
                  t
                    ? ((t.message = t.message.replace(
                        "lstat",
                        "ensureSymlink",
                      )),
                      n(t))
                    : n(null, { toCwd: e, toDst: r.relative(c, e) }),
                ),
          );
        }
      },
      symlinkPathsSync: function (e, t) {
        let n;
        if (r.isAbsolute(e)) {
          if (!(n = o.existsSync(e)))
            throw new Error("absolute srcpath does not exist");
          return { toCwd: e, toDst: e };
        }
        {
          const i = r.dirname(t),
            c = r.join(i, e);
          if ((n = o.existsSync(c))) return { toCwd: c, toDst: e };
          if (!(n = o.existsSync(e)))
            throw new Error("relative srcpath does not exist");
          return { toCwd: e, toDst: r.relative(i, e) };
        }
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(8),
      s = c.mkdirs,
      a = c.mkdirsSync,
      u = n(159),
      f = u.symlinkPaths,
      l = u.symlinkPathsSync,
      d = n(158),
      y = d.symlinkType,
      p = d.symlinkTypeSync,
      m = n(12).pathExists;
    e.exports = {
      createSymlink: r(function (e, t, n, r) {
        (r = "function" == typeof n ? n : r),
          (n = "function" != typeof n && n),
          m(t, (c, a) =>
            c
              ? r(c)
              : a
              ? r(null)
              : void f(e, t, (c, a) => {
                  if (c) return r(c);
                  (e = a.toDst),
                    y(a.toCwd, n, (n, c) => {
                      if (n) return r(n);
                      const a = o.dirname(t);
                      m(a, (n, o) =>
                        n
                          ? r(n)
                          : o
                          ? i.symlink(e, t, c, r)
                          : void s(a, (n) => {
                              if (n) return r(n);
                              i.symlink(e, t, c, r);
                            }),
                      );
                    });
                }),
          );
      }),
      createSymlinkSync: function (e, t, n, r) {
        if (
          ((r = "function" == typeof n ? n : r),
          (n = "function" != typeof n && n),
          i.existsSync(t))
        )
          return;
        const c = l(e, t);
        (e = c.toDst), (n = p(c.toCwd, n));
        const s = o.dirname(t);
        return i.existsSync(s)
          ? i.symlinkSync(e, t, n)
          : (a(s), i.symlinkSync(e, t, n));
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(8),
      s = n(12).pathExists;
    e.exports = {
      createLink: r(function (e, t, n) {
        function r(e, t) {
          i.link(e, t, (e) => {
            if (e) return n(e);
            n(null);
          });
        }
        s(t, (a, u) =>
          a
            ? n(a)
            : u
            ? n(null)
            : void i.lstat(e, (i, a) => {
                if (i)
                  return (
                    (i.message = i.message.replace("lstat", "ensureLink")), n(i)
                  );
                const u = o.dirname(t);
                s(u, (o, i) =>
                  o
                    ? n(o)
                    : i
                    ? r(e, t)
                    : void c.mkdirs(u, (o) => {
                        if (o) return n(o);
                        r(e, t);
                      }),
                );
              }),
        );
      }),
      createLinkSync: function (e, t, n) {
        if (i.existsSync(t)) return;
        try {
          i.lstatSync(e);
        } catch (e) {
          throw ((e.message = e.message.replace("lstat", "ensureLink")), e);
        }
        const r = o.dirname(t);
        return i.existsSync(r)
          ? i.linkSync(e, t)
          : (c.mkdirsSync(r), i.linkSync(e, t));
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(0),
      i = n(1),
      c = n(8),
      s = n(12).pathExists;
    e.exports = {
      createFile: r(function (e, t) {
        function n() {
          i.writeFile(e, "", (e) => {
            if (e) return t(e);
            t();
          });
        }
        i.stat(e, (r, i) => {
          if (!r && i.isFile()) return t();
          const a = o.dirname(e);
          s(a, (e, r) =>
            e
              ? t(e)
              : r
              ? n()
              : void c.mkdirs(a, (e) => {
                  if (e) return t(e);
                  n();
                }),
          );
        });
      }),
      createFileSync: function (e) {
        let t;
        try {
          t = i.statSync(e);
        } catch (e) {}
        if (t && t.isFile()) return;
        const n = o.dirname(e);
        i.existsSync(n) || c.mkdirsSync(n), i.writeFileSync(e, "");
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(162),
      o = n(161),
      i = n(160);
    e.exports = {
      createFile: r.createFile,
      createFileSync: r.createFileSync,
      ensureFile: r.createFile,
      ensureFileSync: r.createFileSync,
      createLink: o.createLink,
      createLinkSync: o.createLinkSync,
      ensureLink: o.createLink,
      ensureLinkSync: o.createLinkSync,
      createSymlink: i.createSymlink,
      createSymlinkSync: i.createSymlinkSync,
      ensureSymlink: i.createSymlink,
      ensureSymlinkSync: i.createSymlinkSync,
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(13),
      i = n(0),
      c = n(8),
      s = n(25),
      a = r(function (e, t) {
        (t = t || function () {}),
          o.readdir(e, (n, r) => {
            if (n) return c.mkdirs(e, t);
            (r = r.map((t) => i.join(e, t))),
              (function e() {
                const n = r.pop();
                if (!n) return t();
                s.remove(n, (n) => {
                  if (n) return t(n);
                  e();
                });
              })();
          });
      });
    function u(e) {
      let t;
      try {
        t = o.readdirSync(e);
      } catch (t) {
        return c.mkdirsSync(e);
      }
      t.forEach((t) => {
        (t = i.join(e, t)), s.removeSync(t);
      });
    }
    e.exports = { emptyDirSync: u, emptydirSync: u, emptyDir: a, emptydir: a };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(60).copySync,
      c = n(25).removeSync,
      s = n(8).mkdirsSync,
      a = n(59);
    function u(e, t, n) {
      return r.statSync(e).isDirectory()
        ? (function (e, t, n) {
            const r = { overwrite: !1 };
            n ? (c(t), o()) : o();
            function o() {
              return i(e, t, r), c(e);
            }
          })(e, t, n)
        : (function (e, t, n) {
            const o = a(65536),
              i = n ? "w" : "wx",
              c = r.openSync(e, "r"),
              s = r.fstatSync(c),
              u = r.openSync(t, i, s.mode);
            let f = 1,
              l = 0;
            for (; f > 0; )
              (f = r.readSync(c, o, 0, 65536, l)),
                r.writeSync(u, o, 0, f),
                (l += f);
            return r.closeSync(c), r.closeSync(u), r.unlinkSync(e);
          })(e, t, n);
    }
    e.exports = {
      moveSync: function e(t, n, i) {
        const a = (i = i || {}).overwrite || i.clobber || !1;
        if (((t = o.resolve(t)), (n = o.resolve(n)), t === n))
          return r.accessSync(t);
        if (
          (function (e, t) {
            try {
              return (
                r.statSync(e).isDirectory() &&
                e !== t &&
                t.indexOf(e) > -1 &&
                t.split(o.dirname(e) + o.sep)[1].split(o.sep)[0] ===
                  o.basename(e)
              );
            } catch (e) {
              return !1;
            }
          })(t, n)
        )
          throw new Error(`Cannot move '${t}' into itself '${n}'.`);
        s(o.dirname(n)),
          (function () {
            if (a)
              try {
                r.renameSync(t, n);
              } catch (r) {
                if (
                  "ENOTEMPTY" === r.code ||
                  "EEXIST" === r.code ||
                  "EPERM" === r.code
                )
                  return c(n), (i.overwrite = !1), e(t, n, i);
                if ("EXDEV" !== r.code) throw r;
                return u(t, n, a);
              }
            else
              try {
                r.linkSync(t, n), r.unlinkSync(t);
              } catch (e) {
                if (
                  "EXDEV" === e.code ||
                  "EISDIR" === e.code ||
                  "EPERM" === e.code ||
                  "ENOTSUP" === e.code
                )
                  return u(t, n, a);
                throw e;
              }
          })();
      },
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(1),
      i = n(63),
      c = n(0),
      s = n(25).remove,
      a = n(8).mkdirs;
    function u(e, t, n, r) {
      o.stat(e, (i, c) => {
        if (i) return r(i);
        c.isDirectory()
          ? f(e, t, n, r)
          : (function (e, t, n, r) {
              const i = n ? "w" : "wx",
                c = o.createReadStream(e),
                s = o.createWriteStream(t, { flags: i });
              function a() {
                o.unlink(e, r);
              }
              c.on("error", (i) => {
                c.destroy(),
                  s.destroy(),
                  s.removeListener("close", a),
                  o.unlink(t, () => {
                    "EISDIR" === i.code || "EPERM" === i.code
                      ? f(e, t, n, r)
                      : r(i);
                  });
              }),
                s.on("error", (e) => {
                  c.destroy(), s.destroy(), s.removeListener("close", a), r(e);
                }),
                s.once("close", a),
                c.pipe(s);
            })(e, t, n, r);
      });
    }
    function f(e, t, n, r) {
      const o = { overwrite: !1 };
      function c() {
        i(e, t, o, (t) => {
          if (t) return r(t);
          s(e, r);
        });
      }
      n
        ? s(t, (e) => {
            if (e) return r(e);
            c();
          })
        : c();
    }
    e.exports = {
      move: r(function e(t, n, r, i) {
        "function" == typeof r && ((i = r), (r = {}));
        const f = r.overwrite || r.clobber || !1;
        !(function (e, t, n) {
          o.stat(e, (r, o) => {
            if (r) return n(r);
            if (o.isDirectory()) {
              const r = t.split(c.dirname(e) + c.sep)[1];
              if (r) {
                const o = r.split(c.sep)[0];
                return n(
                  null,
                  !!o && e !== t && t.indexOf(e) > -1 && o === c.basename(e),
                );
              }
              return n(null, !1);
            }
            return n(null, !1);
          });
        })(t, n, (l, d) =>
          l
            ? i(l)
            : d
            ? i(
                new Error(
                  `Cannot move '${t}' to a subdirectory of itself, '${n}'.`,
                ),
              )
            : void a(c.dirname(n), (a) => {
                if (a) return i(a);
                c.resolve(t) === c.resolve(n)
                  ? o.access(t, i)
                  : f
                  ? o.rename(t, n, (o) => {
                      if (!o) return i();
                      if ("ENOTEMPTY" !== o.code && "EEXIST" !== o.code) {
                        if ("EPERM" !== o.code)
                          return "EXDEV" !== o.code ? i(o) : void u(t, n, f, i);
                        setTimeout(() => {
                          s(n, (o) => {
                            if (o) return i(o);
                            (r.overwrite = !1), e(t, n, r, i);
                          });
                        }, 200);
                      } else
                        s(n, (o) => {
                          if (o) return i(o);
                          (r.overwrite = !1), e(t, n, r, i);
                        });
                    })
                  : o.link(t, n, (e) =>
                      e
                        ? "EXDEV" === e.code ||
                          "EISDIR" === e.code ||
                          "EPERM" === e.code ||
                          "ENOTSUP" === e.code
                          ? u(t, n, f, i)
                          : i(e)
                        : o.unlink(t, i),
                    );
              }),
        );
      }),
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(8),
      c = n(37);
    e.exports = function (e, t, n) {
      const s = o.dirname(e);
      r.existsSync(s) || i.mkdirsSync(s), c.writeJsonSync(e, t, n);
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(0),
      o = n(8),
      i = n(12).pathExists,
      c = n(37);
    e.exports = function (e, t, n, s) {
      "function" == typeof n && ((s = n), (n = {}));
      const a = r.dirname(e);
      i(a, (r, i) =>
        r
          ? s(r)
          : i
          ? c.writeJson(e, t, n, s)
          : void o.mkdirs(a, (r) => {
              if (r) return s(r);
              c.writeJson(e, t, n, s);
            }),
      );
    };
  },
  function (e, t, n) {
    var r;
    try {
      r = n(1);
    } catch (e) {
      r = n(13);
    }
    function o(e, t) {
      var n,
        r = "\n";
      return (
        "object" == typeof t &&
          null !== t &&
          (t.spaces && (n = t.spaces), t.EOL && (r = t.EOL)),
        JSON.stringify(e, t ? t.replacer : null, n).replace(/\n/g, r) + r
      );
    }
    function i(e) {
      return (
        Buffer.isBuffer(e) && (e = e.toString("utf8")),
        (e = e.replace(/^\uFEFF/, ""))
      );
    }
    var c = {
      readFile: function (e, t, n) {
        null == n && ((n = t), (t = {})),
          "string" == typeof t && (t = { encoding: t });
        var o = (t = t || {}).fs || r,
          c = !0;
        "throws" in t && (c = t.throws),
          o.readFile(e, t, function (r, o) {
            if (r) return n(r);
            var s;
            o = i(o);
            try {
              s = JSON.parse(o, t ? t.reviver : null);
            } catch (t) {
              return c
                ? ((t.message = e + ": " + t.message), n(t))
                : n(null, null);
            }
            n(null, s);
          });
      },
      readFileSync: function (e, t) {
        "string" == typeof (t = t || {}) && (t = { encoding: t });
        var n = t.fs || r,
          o = !0;
        "throws" in t && (o = t.throws);
        try {
          var c = n.readFileSync(e, t);
          return (c = i(c)), JSON.parse(c, t.reviver);
        } catch (t) {
          if (o) throw ((t.message = e + ": " + t.message), t);
          return null;
        }
      },
      writeFile: function (e, t, n, i) {
        null == i && ((i = n), (n = {}));
        var c = (n = n || {}).fs || r,
          s = "";
        try {
          s = o(t, n);
        } catch (e) {
          return void (i && i(e, null));
        }
        c.writeFile(e, s, n, i);
      },
      writeFileSync: function (e, t, n) {
        var i = (n = n || {}).fs || r,
          c = o(t, n);
        return i.writeFileSync(e, c, n);
      },
    };
    e.exports = c;
  },
  function (e, t, n) {
    "use strict";
    const r = n(2).fromCallback,
      o = n(37);
    (o.outputJson = r(n(168))),
      (o.outputJsonSync = n(167)),
      (o.outputJSON = o.outputJson),
      (o.outputJSONSync = o.outputJsonSync),
      (o.writeJSON = o.writeJson),
      (o.writeJSONSync = o.writeJsonSync),
      (o.readJSON = o.readJson),
      (o.readJSONSync = o.readJsonSync),
      (e.exports = o);
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(20),
      c = "win32" === process.platform;
    function s(e) {
      ["unlink", "chmod", "stat", "lstat", "rmdir", "readdir"].forEach((t) => {
        (e[t] = e[t] || r[t]), (e[(t += "Sync")] = e[t] || r[t]);
      }),
        (e.maxBusyTries = e.maxBusyTries || 3);
    }
    function a(e, t, n) {
      let r = 0;
      "function" == typeof t && ((n = t), (t = {})),
        i(e, "rimraf: missing path"),
        i.equal(typeof e, "string", "rimraf: path should be a string"),
        i.equal(typeof n, "function", "rimraf: callback function required"),
        i(t, "rimraf: invalid options argument provided"),
        i.equal(typeof t, "object", "rimraf: options should be object"),
        s(t),
        u(e, t, function o(i) {
          if (i) {
            if (
              ("EBUSY" === i.code ||
                "ENOTEMPTY" === i.code ||
                "EPERM" === i.code) &&
              r < t.maxBusyTries
            ) {
              return r++, setTimeout(() => u(e, t, o), 100 * r);
            }
            "ENOENT" === i.code && (i = null);
          }
          n(i);
        });
    }
    function u(e, t, n) {
      i(e),
        i(t),
        i("function" == typeof n),
        t.lstat(e, (r, o) =>
          r && "ENOENT" === r.code
            ? n(null)
            : r && "EPERM" === r.code && c
            ? f(e, t, r, n)
            : o && o.isDirectory()
            ? d(e, t, r, n)
            : void t.unlink(e, (r) => {
                if (r) {
                  if ("ENOENT" === r.code) return n(null);
                  if ("EPERM" === r.code)
                    return c ? f(e, t, r, n) : d(e, t, r, n);
                  if ("EISDIR" === r.code) return d(e, t, r, n);
                }
                return n(r);
              }),
        );
    }
    function f(e, t, n, r) {
      i(e),
        i(t),
        i("function" == typeof r),
        n && i(n instanceof Error),
        t.chmod(e, 438, (o) => {
          o
            ? r("ENOENT" === o.code ? null : n)
            : t.stat(e, (o, i) => {
                o
                  ? r("ENOENT" === o.code ? null : n)
                  : i.isDirectory()
                  ? d(e, t, n, r)
                  : t.unlink(e, r);
              });
        });
    }
    function l(e, t, n) {
      let r;
      i(e), i(t), n && i(n instanceof Error);
      try {
        t.chmodSync(e, 438);
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw n;
      }
      try {
        r = t.statSync(e);
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw n;
      }
      r.isDirectory() ? p(e, t, n) : t.unlinkSync(e);
    }
    function d(e, t, n, r) {
      i(e),
        i(t),
        n && i(n instanceof Error),
        i("function" == typeof r),
        t.rmdir(e, (c) => {
          !c ||
          ("ENOTEMPTY" !== c.code && "EEXIST" !== c.code && "EPERM" !== c.code)
            ? c && "ENOTDIR" === c.code
              ? r(n)
              : r(c)
            : (function (e, t, n) {
                i(e),
                  i(t),
                  i("function" == typeof n),
                  t.readdir(e, (r, i) => {
                    if (r) return n(r);
                    let c,
                      s = i.length;
                    if (0 === s) return t.rmdir(e, n);
                    i.forEach((r) => {
                      a(o.join(e, r), t, (r) => {
                        if (!c)
                          return r
                            ? n((c = r))
                            : void (0 == --s && t.rmdir(e, n));
                      });
                    });
                  });
              })(e, t, r);
        });
    }
    function y(e, t) {
      let n;
      s((t = t || {})),
        i(e, "rimraf: missing path"),
        i.equal(typeof e, "string", "rimraf: path should be a string"),
        i(t, "rimraf: missing options"),
        i.equal(typeof t, "object", "rimraf: options should be object");
      try {
        n = t.lstatSync(e);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        "EPERM" === n.code && c && l(e, t, n);
      }
      try {
        n && n.isDirectory() ? p(e, t, null) : t.unlinkSync(e);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        if ("EPERM" === n.code) return c ? l(e, t, n) : p(e, t, n);
        if ("EISDIR" !== n.code) throw n;
        p(e, t, n);
      }
    }
    function p(e, t, n) {
      i(e), i(t), n && i(n instanceof Error);
      try {
        t.rmdirSync(e);
      } catch (r) {
        if ("ENOTDIR" === r.code) throw n;
        if ("ENOTEMPTY" === r.code || "EEXIST" === r.code || "EPERM" === r.code)
          !(function (e, t) {
            i(e), i(t), t.readdirSync(e).forEach((n) => y(o.join(e, n), t));
            const n = c ? 100 : 1;
            let r = 0;
            for (;;) {
              let o = !0;
              try {
                const i = t.rmdirSync(e, t);
                return (o = !1), i;
              } finally {
                if (++r < n && o) continue;
              }
            }
          })(e, t);
        else if ("ENOENT" !== r.code) throw r;
      }
    }
    (e.exports = a), (a.sync = y);
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(8).mkdirsSync,
      c = n(61).utimesMillisSync,
      s = Symbol("notExist"),
      a = Symbol("existsReg");
    function u(e, t, n) {
      if (!n.filter || n.filter(e, t))
        return (function (e, t, n) {
          const i = (n.dereference ? r.statSync : r.lstatSync)(e);
          if (i.isDirectory())
            return (function (e, t, n, o) {
              const i = y(n);
              if (i === s) {
                if (p(t, n))
                  throw new Error(
                    `Cannot copy '${t}' to a subdirectory of itself, '${n}'.`,
                  );
                return (function (e, t, n, o) {
                  return (
                    r.mkdirSync(n, e.mode), r.chmodSync(n, e.mode), d(t, n, o)
                  );
                })(e, t, n, o);
              }
              if (i === a) {
                if (p(t, n))
                  throw new Error(
                    `Cannot copy '${t}' to a subdirectory of itself, '${n}'.`,
                  );
                return (function (e, t, n) {
                  if (!r.statSync(t).isDirectory())
                    throw new Error(
                      `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
                    );
                  return d(e, t, n);
                })(t, n, o);
              }
              if (t === i) return;
              return d(t, n, o);
            })(i, e, t, n);
          if (i.isFile() || i.isCharacterDevice() || i.isBlockDevice())
            return (function (e, t, n, r) {
              const o = y(n);
              if (o === s) return l(e, t, n, r);
              if (o === a) return f(e, t, n, r);
              if (t === o) return;
              return f(e, t, n, r);
            })(i, e, t, n);
          if (i.isSymbolicLink())
            return (function (e, t, n) {
              let i = r.readlinkSync(e);
              n.dereference && (i = o.resolve(process.cwd(), i));
              let c = y(t);
              if (c === s || c === a) return r.symlinkSync(i, t);
              if ((n.dereference && (c = o.resolve(process.cwd(), c)), c === i))
                return;
              if (r.statSync(t).isDirectory() && p(c, i))
                throw new Error(`Cannot overwrite '${c}' with '${i}'.`);
              return (function (e, t) {
                return r.unlinkSync(t), r.symlinkSync(e, t);
              })(i, t);
            })(e, t, n);
        })(e, t, n);
    }
    function f(e, t, n, o) {
      if (o.overwrite) return r.unlinkSync(n), l(e, t, n, o);
      if (o.errorOnExist) throw new Error(`'${n}' already exists`);
    }
    function l(e, t, o, i) {
      return "function" == typeof r.copyFileSync
        ? (r.copyFileSync(t, o),
          r.chmodSync(o, e.mode),
          i.preserveTimestamps ? c(o, e.atime, e.mtime) : void 0)
        : (function (e, t, o, i) {
            const c = n(59)(65536),
              s = r.openSync(t, "r"),
              a = r.openSync(o, "w", e.mode);
            let u = 1,
              f = 0;
            for (; u > 0; )
              (u = r.readSync(s, c, 0, 65536, f)),
                r.writeSync(a, c, 0, u),
                (f += u);
            i.preserveTimestamps && r.futimesSync(a, e.atime, e.mtime);
            r.closeSync(s), r.closeSync(a);
          })(e, t, o, i);
    }
    function d(e, t, n) {
      r.readdirSync(e).forEach((r) => {
        u(o.join(e, r), o.join(t, r), n);
      });
    }
    function y(e) {
      let t;
      try {
        t = r.readlinkSync(e);
      } catch (e) {
        if ("ENOENT" === e.code) return s;
        if ("EINVAL" === e.code || "UNKNOWN" === e.code) return a;
        throw e;
      }
      return t;
    }
    function p(e, t) {
      const n = t.split(o.dirname(e) + o.sep)[1];
      if (n) {
        const r = n.split(o.sep)[0];
        return !!r && e !== t && t.indexOf(e) > -1 && r === o.basename(e);
      }
      return !1;
    }
    e.exports = function (e, t, n) {
      if (
        ("function" == typeof n && (n = { filter: n }),
        ((n = n || {}).clobber = !("clobber" in n && !n.clobber)),
        (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
        n.preserveTimestamps &&
          "ia32" === process.arch &&
          console.warn(
            "fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269",
          ),
        (e = o.resolve(e)) === (t = o.resolve(t)))
      )
        throw new Error("Source and destination must not be the same.");
      if (n.filter && !n.filter(e, t)) return;
      const c = o.dirname(t);
      return r.existsSync(c) || i(c), u(e, t, n);
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(62).invalidWin32Path,
      c = parseInt("0777", 8);
    e.exports = function e(t, n, s) {
      (n && "object" == typeof n) || (n = { mode: n });
      let a = n.mode;
      const u = n.fs || r;
      if ("win32" === process.platform && i(t)) {
        const e = new Error(t + " contains invalid WIN32 path characters.");
        throw ((e.code = "EINVAL"), e);
      }
      void 0 === a && (a = c & ~process.umask()),
        s || (s = null),
        (t = o.resolve(t));
      try {
        u.mkdirSync(t, a), (s = s || t);
      } catch (r) {
        switch (r.code) {
          case "ENOENT":
            if (o.dirname(t) === t) throw r;
            (s = e(o.dirname(t), n, s)), e(t, n, s);
            break;
          default:
            let i;
            try {
              i = u.statSync(t);
            } catch (e) {
              throw r;
            }
            if (!i.isDirectory()) throw r;
        }
      }
      return s;
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(1),
      o = n(0),
      i = n(62).invalidWin32Path,
      c = parseInt("0777", 8);
    e.exports = function e(t, n, s, a) {
      if (
        ("function" == typeof n
          ? ((s = n), (n = {}))
          : (n && "object" == typeof n) || (n = { mode: n }),
        "win32" === process.platform && i(t))
      ) {
        const e = new Error(t + " contains invalid WIN32 path characters.");
        return (e.code = "EINVAL"), s(e);
      }
      let u = n.mode;
      const f = n.fs || r;
      void 0 === u && (u = c & ~process.umask()),
        a || (a = null),
        (s = s || function () {}),
        (t = o.resolve(t)),
        f.mkdir(t, u, (r) => {
          if (!r) return s(null, (a = a || t));
          switch (r.code) {
            case "ENOENT":
              if (o.dirname(t) === t) return s(r);
              e(o.dirname(t), n, (r, o) => {
                r ? s(r, o) : e(t, n, s, o);
              });
              break;
            default:
              f.stat(t, (e, t) => {
                e || !t.isDirectory() ? s(r, a) : s(null, a);
              });
          }
        });
    };
  },
  function (e, t, n) {
    const r = n(2).fromCallback;
    e.exports = { copy: r(n(63)) };
  },
  function (e, t, n) {
    "use strict";
    e.exports = function (e) {
      if (null === e || "object" != typeof e) return e;
      if (e instanceof Object) var t = { __proto__: r(e) };
      else var t = Object.create(null);
      return (
        Object.getOwnPropertyNames(e).forEach(function (n) {
          Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
        }),
        t
      );
    };
    var r =
      Object.getPrototypeOf ||
      function (e) {
        return e.__proto__;
      };
  },
  function (e, t) {
    e.exports = require("stream");
  },
  function (e, t, n) {
    var r = n(177).Stream;
    e.exports = function (e) {
      return {
        ReadStream: function t(n, o) {
          if (!(this instanceof t)) return new t(n, o);
          r.call(this);
          var i = this;
          this.path = n;
          this.fd = null;
          this.readable = !0;
          this.paused = !1;
          this.flags = "r";
          this.mode = 438;
          this.bufferSize = 65536;
          o = o || {};
          var c = Object.keys(o);
          for (var s = 0, a = c.length; s < a; s++) {
            var u = c[s];
            this[u] = o[u];
          }
          this.encoding && this.setEncoding(this.encoding);
          if (void 0 !== this.start) {
            if ("number" != typeof this.start)
              throw TypeError("start must be a Number");
            if (void 0 === this.end) this.end = 1 / 0;
            else if ("number" != typeof this.end)
              throw TypeError("end must be a Number");
            if (this.start > this.end) throw new Error("start must be <= end");
            this.pos = this.start;
          }
          if (null !== this.fd)
            return void process.nextTick(function () {
              i._read();
            });
          e.open(this.path, this.flags, this.mode, function (e, t) {
            if (e) return i.emit("error", e), void (i.readable = !1);
            (i.fd = t), i.emit("open", t), i._read();
          });
        },
        WriteStream: function t(n, o) {
          if (!(this instanceof t)) return new t(n, o);
          r.call(this);
          this.path = n;
          this.fd = null;
          this.writable = !0;
          this.flags = "w";
          this.encoding = "binary";
          this.mode = 438;
          this.bytesWritten = 0;
          o = o || {};
          var i = Object.keys(o);
          for (var c = 0, s = i.length; c < s; c++) {
            var a = i[c];
            this[a] = o[a];
          }
          if (void 0 !== this.start) {
            if ("number" != typeof this.start)
              throw TypeError("start must be a Number");
            if (this.start < 0) throw new Error("start must be >= zero");
            this.pos = this.start;
          }
          this.busy = !1;
          this._queue = [];
          null === this.fd &&
            ((this._open = e.open),
            this._queue.push([
              this._open,
              this.path,
              this.flags,
              this.mode,
              void 0,
            ]),
            this.flush());
        },
      };
    };
  },
  function (e, t) {
    e.exports = require("constants");
  },
  function (e, t, n) {
    var r = n(179),
      o = process.cwd,
      i = null,
      c = process.platform;
    process.cwd = function () {
      return i || (i = o.call(process)), i;
    };
    try {
      process.cwd();
    } catch (e) {}
    if ("function" == typeof process.chdir) {
      var s = process.chdir;
      (process.chdir = function (e) {
        (i = null), s.call(process, e);
      }),
        Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, s);
    }
    e.exports = function (e) {
      r.hasOwnProperty("O_SYMLINK") &&
        process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) &&
        (function (e) {
          (e.lchmod = function (t, n, o) {
            e.open(t, r.O_WRONLY | r.O_SYMLINK, n, function (t, r) {
              t
                ? o && o(t)
                : e.fchmod(r, n, function (t) {
                    e.close(r, function (e) {
                      o && o(t || e);
                    });
                  });
            });
          }),
            (e.lchmodSync = function (t, n) {
              var o,
                i = e.openSync(t, r.O_WRONLY | r.O_SYMLINK, n),
                c = !0;
              try {
                (o = e.fchmodSync(i, n)), (c = !1);
              } finally {
                if (c)
                  try {
                    e.closeSync(i);
                  } catch (e) {}
                else e.closeSync(i);
              }
              return o;
            });
        })(e);
      e.lutimes ||
        (function (e) {
          r.hasOwnProperty("O_SYMLINK") && e.futimes
            ? ((e.lutimes = function (t, n, o, i) {
                e.open(t, r.O_SYMLINK, function (t, r) {
                  t
                    ? i && i(t)
                    : e.futimes(r, n, o, function (t) {
                        e.close(r, function (e) {
                          i && i(t || e);
                        });
                      });
                });
              }),
              (e.lutimesSync = function (t, n, o) {
                var i,
                  c = e.openSync(t, r.O_SYMLINK),
                  s = !0;
                try {
                  (i = e.futimesSync(c, n, o)), (s = !1);
                } finally {
                  if (s)
                    try {
                      e.closeSync(c);
                    } catch (e) {}
                  else e.closeSync(c);
                }
                return i;
              }))
            : e.futimes &&
              ((e.lutimes = function (e, t, n, r) {
                r && process.nextTick(r);
              }),
              (e.lutimesSync = function () {}));
        })(e);
      (e.chown = o(e.chown)),
        (e.fchown = o(e.fchown)),
        (e.lchown = o(e.lchown)),
        (e.chmod = t(e.chmod)),
        (e.fchmod = t(e.fchmod)),
        (e.lchmod = t(e.lchmod)),
        (e.chownSync = i(e.chownSync)),
        (e.fchownSync = i(e.fchownSync)),
        (e.lchownSync = i(e.lchownSync)),
        (e.chmodSync = n(e.chmodSync)),
        (e.fchmodSync = n(e.fchmodSync)),
        (e.lchmodSync = n(e.lchmodSync)),
        (e.stat = s(e.stat)),
        (e.fstat = s(e.fstat)),
        (e.lstat = s(e.lstat)),
        (e.statSync = a(e.statSync)),
        (e.fstatSync = a(e.fstatSync)),
        (e.lstatSync = a(e.lstatSync)),
        e.chmod &&
          !e.lchmod &&
          ((e.lchmod = function (e, t, n) {
            n && process.nextTick(n);
          }),
          (e.lchmodSync = function () {}));
      e.chown &&
        !e.lchown &&
        ((e.lchown = function (e, t, n, r) {
          r && process.nextTick(r);
        }),
        (e.lchownSync = function () {}));
      "win32" === c &&
        (e.rename =
          "function" != typeof e.rename
            ? e.rename
            : (function (t) {
                function n(n, r, o) {
                  var i = Date.now(),
                    c = 0;
                  t(n, r, function s(a) {
                    if (
                      a &&
                      ("EACCES" === a.code || "EPERM" === a.code) &&
                      Date.now() - i < 6e4
                    )
                      return (
                        setTimeout(function () {
                          e.stat(r, function (e, i) {
                            e && "ENOENT" === e.code ? t(n, r, s) : o(a);
                          });
                        }, c),
                        void (c < 100 && (c += 10))
                      );
                    o && o(a);
                  });
                }
                return Object.setPrototypeOf && Object.setPrototypeOf(n, t), n;
              })(e.rename));
      function t(t) {
        return t
          ? function (n, r, o) {
              return t.call(e, n, r, function (e) {
                u(e) && (e = null), o && o.apply(this, arguments);
              });
            }
          : t;
      }
      function n(t) {
        return t
          ? function (n, r) {
              try {
                return t.call(e, n, r);
              } catch (e) {
                if (!u(e)) throw e;
              }
            }
          : t;
      }
      function o(t) {
        return t
          ? function (n, r, o, i) {
              return t.call(e, n, r, o, function (e) {
                u(e) && (e = null), i && i.apply(this, arguments);
              });
            }
          : t;
      }
      function i(t) {
        return t
          ? function (n, r, o) {
              try {
                return t.call(e, n, r, o);
              } catch (e) {
                if (!u(e)) throw e;
              }
            }
          : t;
      }
      function s(t) {
        return t
          ? function (n, r, o) {
              function i(e, t) {
                t &&
                  (t.uid < 0 && (t.uid += 4294967296),
                  t.gid < 0 && (t.gid += 4294967296)),
                  o && o.apply(this, arguments);
              }
              return (
                "function" == typeof r && ((o = r), (r = null)),
                r ? t.call(e, n, r, i) : t.call(e, n, i)
              );
            }
          : t;
      }
      function a(t) {
        return t
          ? function (n, r) {
              var o = r ? t.call(e, n, r) : t.call(e, n);
              return (
                o &&
                  (o.uid < 0 && (o.uid += 4294967296),
                  o.gid < 0 && (o.gid += 4294967296)),
                o
              );
            }
          : t;
      }
      function u(e) {
        if (!e) return !0;
        if ("ENOSYS" === e.code) return !0;
        var t = !process.getuid || 0 !== process.getuid();
        return !(!t || ("EINVAL" !== e.code && "EPERM" !== e.code));
      }
      (e.read =
        "function" != typeof e.read
          ? e.read
          : (function (t) {
              function n(n, r, o, i, c, s) {
                var a;
                if (s && "function" == typeof s) {
                  var u = 0;
                  a = function (f, l, d) {
                    if (f && "EAGAIN" === f.code && u < 10)
                      return u++, t.call(e, n, r, o, i, c, a);
                    s.apply(this, arguments);
                  };
                }
                return t.call(e, n, r, o, i, c, a);
              }
              return Object.setPrototypeOf && Object.setPrototypeOf(n, t), n;
            })(e.read)),
        (e.readSync =
          "function" != typeof e.readSync
            ? e.readSync
            : ((f = e.readSync),
              function (t, n, r, o, i) {
                for (var c = 0; ; )
                  try {
                    return f.call(e, t, n, r, o, i);
                  } catch (e) {
                    if ("EAGAIN" === e.code && c < 10) {
                      c++;
                      continue;
                    }
                    throw e;
                  }
              }));
      var f;
    };
  },
  function (e, t, n) {
    "use strict";
    e.exports = function () {
      const e = [].slice.call(arguments).filter((e) => e),
        t = e.shift();
      return (
        e.forEach((e) => {
          Object.keys(e).forEach((n) => {
            t[n] = e[n];
          });
        }),
        t
      );
    };
  },
  function (e, t, n) {
    "use strict";
    const r = n(181),
      o = {};
    r(o, n(65)),
      r(o, n(175)),
      r(o, n(60)),
      r(o, n(8)),
      r(o, n(25)),
      r(o, n(170)),
      r(o, n(166)),
      r(o, n(165)),
      r(o, n(164)),
      r(o, n(163)),
      r(o, n(157)),
      r(o, n(12)),
      (e.exports = o);
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.read = t.write = void 0);
    var r =
      Object.assign ||
      function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n)
            Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
        return e;
      };
    t.write =
      ((o = m(function* (e, t, n = {}) {
        if (
          !(n = r({ overwrite: !1 }, n)).overwrite &&
          (yield a.default.pathExists(e))
        )
          throw new Error(`${e} exists. Set 'overwrite' to true.`);
        var o = h(t, n);
        const i = o.encryptedData,
          c = o.blobKey,
          s = o.metadata;
        return yield a.default.outputFile(e, i), { blobKey: c, metadata: s };
      })),
      function (e, t) {
        return o.apply(this, arguments);
      });
    var o;
    t.read =
      ((i = m(function* (e, t) {
        let n,
          r = yield a.default.readFile(e);
        try {
          n = w(r, t);
        } catch (t) {
          if (
            t.message.match(
              /seco checksum does not match; data may be corrupted/,
            )
          )
            throw new Error(
              `${e}: seco checksum does not match; file may be corrupted`,
            );
          throw t;
        }
        return n;
      })),
      function (e, t) {
        return i.apply(this, arguments);
      });
    var i;
    (t.encryptData = h), (t.decryptData = w);
    var c,
      s = n(182),
      a = (c = s) && c.__esModule ? c : { default: c },
      u = p(n(19)),
      f = p(n(58)),
      l = p(n(35)),
      d = p(n(33)),
      y = p(n(32));
    function p(e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (null != e)
        for (var n in e)
          Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
      return (t.default = e), t;
    }
    function m(e) {
      return function () {
        var t = e.apply(this, arguments);
        return new Promise(function (e, n) {
          return (function r(o, i) {
            try {
              var c = t[o](i),
                s = c.value;
            } catch (e) {
              return void n(e);
            }
            if (!c.done)
              return Promise.resolve(s).then(
                function (e) {
                  r("next", e);
                },
                function (e) {
                  r("throw", e);
                },
              );
            e(s);
          })("next");
        });
      };
    }
    function h(e, t = {}) {
      t.header || console.warn("seco-file: should pass options.header.");
      let n,
        r,
        o = l.create(t.header);
      if (t.passphrase)
        (n = u.randomBytes(32)),
          (r = d.create()),
          d.encryptBlobKey(r, t.passphrase, n);
      else {
        if (!t.metadata || !t.blobKey)
          throw new Error(
            "Must set either passphrase or (metadata and blobKey)",
          );
        (n = t.blobKey), (r = t.metadata);
      }
      e = Buffer.isBuffer(e) ? e : Buffer.from(e, "utf8");
      let i = f.encrypt(e, r, n).blob;
      const c = l.serialize(o),
        s = d.serialize(r);
      let a = {
        header: c,
        checksum: y.computeChecksum(s, i),
        metadata: s,
        blob: i,
      };
      return { encryptedData: y.encode(a), blobKey: n, metadata: r };
    }
    function w(e, t) {
      const n = y.decode(e),
        r = y.computeChecksum(n.metadata, n.blob);
      if (!n.checksum.equals(r))
        throw new Error("seco checksum does not match; data may be corrupted");
      let o = d.decode(n.metadata),
        i = d.decryptBlobKey(o, t),
        c = l.decode(n.header);
      return {
        data: f.decrypt(n.blob, o, i),
        blobKey: i,
        metadata: o,
        header: c,
      };
    }
  },
  function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.default = function (e, t, n) {
        let i,
          c,
          s = !1;
        return {
          write: (a) =>
            o(function* () {
              if (s)
                throw new Error(
                  "seco-writer class has been destroyed, create a new one",
                );
              if (c)
                yield r.write(e, a, {
                  metadata: c,
                  blobKey: i,
                  overwrite: !0,
                  header: n,
                });
              else {
                const o = yield r.write(e, a, {
                  passphrase: t,
                  overwrite: !0,
                  header: n,
                });
                (i = o.blobKey), (c = o.metadata);
              }
            })(),
          read: () =>
            o(function* () {
              if (s)
                throw new Error(
                  "seco-writer class has been destroyed, create a new one",
                );
              const n = yield r.read(e, t);
              return (i = n.blobKey), (c = n.metadata), n.data;
            })(),
          destroy() {
            (s = !0), i && i.fill(0);
          },
        };
      });
    var r = (function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (null != e)
        for (var n in e)
          Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
      return (t.default = e), t;
    })(n(183));
    function o(e) {
      return function () {
        var t = e.apply(this, arguments);
        return new Promise(function (e, n) {
          return (function r(o, i) {
            try {
              var c = t[o](i),
                s = c.value;
            } catch (e) {
              return void n(e);
            }
            if (!c.done)
              return Promise.resolve(s).then(
                function (e) {
                  r("next", e);
                },
                function (e) {
                  r("throw", e);
                },
              );
            e(s);
          })("next");
        });
      };
    }
  },
  function (e, t) {
    e.exports = require("electron");
  },
  function (e, t, n) {
    "use strict";
    e.exports = {
      getProcessName: function () {
        return "core";
      },
    };
  },
  function (e, t, n) {
    "use strict";
    n.r(t),
      n.d(t, "allowedBuiltins", function () {
        return r;
      });
    const r = (e) => {
      const t = ["electron", "module"];
      switch (e) {
        case "main":
          return [
            ...t,
            "child_process",
            "tty",
            "crypto",
            "assert",
            "buffer",
            "constants",
            "events",
            "fs",
            "fs/promises",
            "os",
            "path",
            "stream",
            "url",
            "util",
            "zlib",
            ...[],
          ];
        case "monero":
          return [...t, "crypto", "buffer", "util", "stream"];
        case "core":
          return [
            ...t,
            "crypto",
            "assert",
            "constants",
            "fs",
            "os",
            "path",
            "stream",
            "util",
            "zlib",
          ];
        case "wallet":
          return [
            ...t,
            "crypto",
            "assert",
            "buffer",
            "constants",
            "events",
            "fs",
            "os",
            "path",
            "querystring",
            "stream",
            "url",
            "util",
            "zlib",
          ];
        case "ui":
          return [
            ...t,
            "crypto",
            "assert",
            "buffer",
            "constants",
            "events",
            "fs",
            "http",
            "https",
            "net",
            "os",
            "path",
            "querystring",
            "readline",
            "stream",
            "tls",
            "url",
            "util",
            "zlib",
          ];
      }
      return [];
    };
  },
  function (e, t, n) {
    const { builtinModules: r } = n(39),
      o = Function.prototype.call.bind(Array.prototype.includes);
    e.exports = (e) =>
      !e.startsWith("events/") &&
      !e.endsWith("/") &&
      ((e) => "electron" === e || o(r, e))(e.replace(/\/.*/, ""));
  },
  function (e, t, n) {
    if (globalThis.Buffer) {
      const Buffer = globalThis.Buffer;
      (Buffer.poolSize = 0),
        (Buffer.allocUnsafe = function (e) {
          return Buffer.alloc(e);
        }),
        (Buffer.allocUnsafeSlow = Buffer.allocUnsafe),
        Object.freeze(Buffer);
    }
    const r = Object.getPrototypeOf(Int8Array);
    for (const e of [
      ...[Object, Array, Number, String, Function, Set, Map, WeakSet, WeakMap],
      ...[Reflect, TypeError, BigInt, URL, Date, JSON, Math],
      ...[Int8Array, Int16Array, Int32Array, DataView],
      ...[Uint8Array, Uint16Array, Uint32Array, r],
    ])
      Object.freeze(e);
    crypto &&
      crypto.subtle &&
      (Object.freeze(crypto), Object.freeze(crypto.subtle));
    {
      const e = n(39),
        t = () => {
          throw new Error("require() of non-builtins has been disabled");
        };
      e._findPath = t;
      for (const n of Object.keys(e._extensions)) e._extensions[n] = t;
    }
    {
      const e = n(39),
        t = n(188),
        r = Function.prototype.call.bind(Array.prototype.includes),
        o = () => {
          const { allowedBuiltins: e } = n(187),
            { getProcessName: t } = n(186),
            r = t();
          return { processName: r, allowedModules: [...e(r)] };
        },
        { processName: i, allowedModules: c } = o(),
        s = (e, n) => {
          if ((t(e), "module" !== e && r(c, e))) return;
          throw new Error(
            `Requiring module "${e}" is not allowed` +
              ` in renderer process "${i}" (parent: ${n})`,
          );
        },
        a = e._resolveFilename.bind(e);
      e._resolveFilename = (e, t, ...n) => (s(e, t.id), a(e, t, ...n));
    }
    process.binding &&
      (process.binding = (e) => {
        throw new Error(
          `harden: process.binding(${JSON.stringify(e)}) has been disabled`,
        );
      });
  },
  function (e, t) {
    const n = (...e) => {
      const t = e
        .reduce(
          (e, t) =>
            e.concat(
              ((e) => e instanceof Error && e.stack)(t) ? t.stack : t,
              "\n",
            ),
          "",
        )
        .trim();
      console._errorOriginal(t);
    };
    console._errorOriginal ||
      ((console._errorOriginal = console.error.bind(console)),
      (console.error = n));
  },
  function (e, t, n) {
    n(190), n(189);
  },
  function (e, t, n) {
    n(191), n(73);
  },
]);
